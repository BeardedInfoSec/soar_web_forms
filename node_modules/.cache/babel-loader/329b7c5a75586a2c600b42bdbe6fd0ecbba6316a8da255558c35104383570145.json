{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSortedTabbableElements = getSortedTabbableElements;\nexports.isTabKey = isTabKey;\nexports.handleTab = handleTab;\nexports.takeFocus = takeFocus;\nexports.handleFocus = handleFocus;\nexports.updateTabIndex = exports.getNewIndex = exports.calculateIndex = exports.isHidden = void 0;\nvar _defer = _interopRequireDefault(require(\"lodash/defer\"));\nvar _filter = _interopRequireDefault(require(\"lodash/filter\"));\nvar _sortBy = _interopRequireDefault(require(\"lodash/sortBy\"));\nfunction _interopRequireDefault(e) {\n  return e && e.__esModule ? e : {\n    \"default\": e\n  };\n}\n/**\n * @file\n * Utilities for managing focus in the browser.\n */\n\nvar tabbableSelectors = ['a[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', '[contenteditable]'];\nvar tabbableSelectorsWithTabIndex = tabbableSelectors.concat(['[tabindex]']);\nvar isStyleVisible = function isStyleVisible(element) {\n  var style = window.getComputedStyle(element);\n  return style.display !== 'none' && style.visibility !== 'hidden';\n};\nvar isAttributeVisible = function isAttributeVisible(element) {\n  return !element.hasAttribute('hidden');\n};\nvar isElementVisible = function isElementVisible(element) {\n  var visibleByStyle = isStyleVisible(element);\n  var visibleByAttribute = isAttributeVisible(element);\n  return visibleByStyle && visibleByAttribute;\n};\n\n/**\n * Determines whether an element is considered hidden based on its dimensions or computed visibility style.\n *\n * This function is primarily used in environments where accurate layout-related properties\n * are available, like a real browser environment.\n *\n * @param {Element} element - The DOM element to check for visibility.\n * @returns {boolean} - Returns true if the element is hidden, otherwise false.\n *\n * @private Exported for testing purposes\n */\nvar isHidden = function isHidden(element) {\n  // SUI-6521: `element.getClientRects().length > 0` is used to distinguish between 'actual' 0-size elements and Jest 0-size elements.\n  // 'actual' 0-size elements typically still have a value from getClientRects.\n  var isZeroSize = element.getClientRects().length > 0 && (element.offsetWidth === 0 || element.offsetHeight === 0);\n  return isZeroSize || !isElementVisible(element);\n};\n\n/**\n * Sorts the tabbable elements in the provided container.\n *\n * @param {Element} container - The target container.\n * @param {Object} [options={ignoreTabIndex: false}] - Configuration options.\n * @param {boolean} [options.ignoreTabIndex=false] - If set to true, the function will neither use \"tabindex\" as an indicator of selectability nor disqualify elements based on \"tabindex=-1\".\n * @returns {Element[]} A sorted array of tabbable elements within the container.\n * @public\n */\nexports.isHidden = isHidden;\nfunction getSortedTabbableElements(container) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    ignoreTabIndex = _ref.ignoreTabIndex;\n  var tabbableElementSelector = (ignoreTabIndex ? tabbableSelectors : tabbableSelectorsWithTabIndex).join(', ');\n  var elems = container.querySelectorAll(tabbableElementSelector);\n  var tabbableElems = (0, _filter[\"default\"])(elems, function (el) {\n    var isValidTabIndex = ignoreTabIndex || el.tabIndex >= 0;\n    return !isHidden(el) && isValidTabIndex || el === document.activeElement;\n  });\n  var reducedElements = tabbableElems.reduce(function (accumulator, currentElement) {\n    var prevElement = accumulator[accumulator.length - 1];\n    var isPrevElementRadio = (prevElement === null || prevElement === void 0 ? void 0 : prevElement.getAttribute('type')) === 'radio';\n    var isCurrElementRadio = currentElement.getAttribute('type') === 'radio';\n    var sameRadioGroup = currentElement.getAttribute('name') === (prevElement === null || prevElement === void 0 ? void 0 : prevElement.getAttribute('name'));\n\n    // Reduce radio elements to a single Tab stop, ensuring only one per group is focusable\n    if (isPrevElementRadio && isCurrElementRadio && sameRadioGroup) {\n      if (currentElement.checked) {\n        // replace previous radio with current checked radio\n        accumulator.pop();\n        accumulator.push(currentElement);\n      }\n    } else {\n      accumulator.push(currentElement);\n    }\n    return accumulator;\n  }, []);\n  return (0, _sortBy[\"default\"])(reducedElements, function (el) {\n    if (el.tabIndex > 0) {\n      return -1 / el.tabIndex;\n    }\n    return 0;\n  });\n}\nfunction isTabKey(event) {\n  return !(event.key !== 'Tab' || event.metaKey || event.altKey || event.controlKey);\n}\n\n/**\n * A key event handler that moves focus among tabbable elements within a container.\n *\n * @param {Element} container - The target container.\n * @param {Event} event - The key event to handle.\n * @returns {Element|null} The element focus was applied to or `null` if focus was not applied.\n * @public\n */\nfunction handleTab(container, event) {\n  // Ignore events bubbling up from portals\n  if (!container.contains(document.activeElement)) {\n    return null;\n  }\n\n  // Ensure this is a valid event\n  if (!isTabKey(event)) {\n    return null;\n  }\n  var tabbableElements = getSortedTabbableElements(container);\n  if (tabbableElements.length === 0) {\n    // if the container is focused, don't allow the focus to leave.\n    if (document.activeElement === container) {\n      event.preventDefault();\n      return container;\n    }\n    return null;\n  }\n\n  // Find the current index or set default.\n  var currentElement = event && event.target || container.querySelector(':focus');\n  var currentIndex = tabbableElements.indexOf(currentElement);\n  if (currentIndex === -1) {\n    currentIndex = event.shiftKey ? 0 : tabbableElements.length - 1;\n  }\n\n  // Shift the array instead of the current index.\n  if (event.shiftKey) {\n    tabbableElements.unshift(tabbableElements.pop()); // move last to first\n  } else {\n    tabbableElements.push(tabbableElements.shift()); // move first to last\n  }\n\n  // Focus\n  event.preventDefault();\n  tabbableElements[currentIndex].focus();\n  return tabbableElements[currentIndex];\n}\n\n/**\n * A helper method that focuses on the first focusable element in a container.\n * If a contained element already has focus, focus does not shift.\n *\n * @param {Element} container - The container that takes focus.\n * @param {String} [defaultElement='first'] - The target of focus, either 'first' or 'container'.\n * @returns {Element|null} The element that was focused, or null if no element was focused.\n * @public\n */\nfunction takeFocus(container) {\n  var defaultElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'first';\n  var currentElement = container.querySelector(':focus');\n  if (currentElement) {\n    return currentElement;\n  }\n  if (defaultElement === 'first') {\n    var targetEl = getSortedTabbableElements(container)[0];\n    if (targetEl) {\n      (0, _defer[\"default\"])(function () {\n        return targetEl.focus();\n      });\n      return targetEl;\n    }\n  }\n  if (container.hasAttribute('tabIndex')) {\n    (0, _defer[\"default\"])(function () {\n      return container.focus();\n    });\n    return container;\n  }\n  return null;\n}\n\n/**\n * An enumeration of possible navigation directions.\n * @readonly\n * @enum {string}\n */\nvar focusMoveDirection = Object.freeze({\n  NONE: 'none',\n  NEXT: 'next',\n  PREVIOUS: 'previous'\n});\n\n/**\n * Helper function to calculate the new index from the current index.\n *\n * This function determines the new index for focus navigation based on the current index,\n * the direction of movement, and whether looping is enabled. It either caps at the start/end\n * of the array or loops around based on the `enableLoop` flag.\n *\n * @returns {number} - The new index. Returns the current index for invalid direction or out-of-bounds index when looping is disabled.\n */\nvar calculateIndex = function calculateIndex(_ref2) {\n  var itemsLength = _ref2.itemsLength,\n    currentIndex = _ref2.currentIndex,\n    direction = _ref2.direction,\n    enableLoop = _ref2.enableLoop;\n  // Check if the direction is valid\n  if (direction === focusMoveDirection.NONE || ![focusMoveDirection.NONE, focusMoveDirection.NEXT, focusMoveDirection.PREVIOUS].includes(direction)) {\n    return currentIndex; // Return current index for invalid direction\n  }\n  var increment = direction === focusMoveDirection.NEXT ? 1 : -1;\n  if (!enableLoop) {\n    var newIndex = currentIndex + increment;\n    if (newIndex >= itemsLength || newIndex < 0) {\n      return currentIndex;\n    }\n    return newIndex;\n  }\n  return (currentIndex + increment + itemsLength) % itemsLength;\n};\n\n/**\n * Helper function to get the new focusable index in the items array based on the key.\n *\n * This function calculates the next focusable index in a list of items, depending on the provided key\n * (e.g. arrow keys, Home, End, Tab). It takes into account the current focus index, orientation of navigation\n * (horizontal or vertical), looping behavior, and specific key handling rules.\n *\n * @returns {number} - The new focusable index. Returns -1 if no valid index is found.\n */\nexports.calculateIndex = calculateIndex;\nvar getNewIndex = function getNewIndex(key, itemsLength, currentIndex, _ref3) {\n  var enableLoop = _ref3.enableLoop,\n    orientation = _ref3.orientation,\n    enableTab = _ref3.enableTab,\n    enableHomeEnd = _ref3.enableHomeEnd;\n  // If the current focused item is not in the actionItems, then focus on the first focusable item.\n  if (currentIndex < 0 || currentIndex >= itemsLength) {\n    return 0;\n  }\n  if (key === 'Home') {\n    return enableHomeEnd ? 0 : -1;\n  }\n  if (key === 'End') {\n    return enableHomeEnd ? itemsLength - 1 : -1;\n  }\n  var direction = focusMoveDirection.NONE;\n  if (orientation === 'horizontal') {\n    if (key === 'ArrowLeft') {\n      direction = focusMoveDirection.PREVIOUS;\n    }\n    if (key === 'ArrowRight') {\n      direction = focusMoveDirection.NEXT;\n    }\n  } else if (orientation === 'vertical') {\n    if (key === 'ArrowUp') {\n      direction = focusMoveDirection.PREVIOUS;\n    }\n    if (key === 'ArrowDown') {\n      direction = focusMoveDirection.NEXT;\n    }\n  }\n  if (enableTab) {\n    // tabShift is a custom key we defined in Menu\n    if (key === 'tabShift') {\n      direction = focusMoveDirection.PREVIOUS;\n    }\n    if (key === 'Tab') {\n      direction = focusMoveDirection.NEXT;\n    }\n  }\n  if (direction !== focusMoveDirection.NONE) {\n    return calculateIndex({\n      itemsLength: itemsLength,\n      currentIndex: currentIndex,\n      direction: direction,\n      enableLoop: enableLoop\n    });\n  }\n  return -1;\n};\n\n/**\n *  Helper function to update the tabindex of action items, setting the active item to be focusable\n */\nexports.getNewIndex = getNewIndex;\nvar updateTabIndex = function updateTabIndex(activeIndex, actionItems) {\n  actionItems.forEach(function (el, index) {\n    return el.setAttribute('tabindex', index === activeIndex ? '0' : '-1');\n  });\n};\n\n/**\n * Handles focus navigation for a list of action items based on key presses.\n *\n * @param {string} key - The key value obtained from KeyboardEvent.key, representing the keyboard key pressed.\n * @param {HTMLElement[]} actionItems - An array of HTML elements representing the action items.\n * @param {number} currentIndex - The current index of the focused item.\n * @param {Object} [options={ enableLoop: false, orientation: 'horizontal', enableTab: false, enableHomeEnd: true }] - Configuration options.\n * @param {boolean} [options.enableLoop=false] - Whether navigation should loop around the ends of the list.\n * @param {string} [options.orientation='horizontal'] - Navigation orientation: 'horizontal' (left/right arrow keys) or 'vertical' (up/down arrow keys).\n * @param {boolean} [options.enableTab=false] - Enable navigation with the Tab key.\n * @param {boolean} [options.enableHomeEnd=true] - Enable navigation with Home and End keys.\n * @public\n */\nexports.updateTabIndex = updateTabIndex;\nfunction handleFocus(key, actionItems, currentIndex) {\n  var _ref4 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n    _ref4$enableLoop = _ref4.enableLoop,\n    enableLoop = _ref4$enableLoop === void 0 ? false : _ref4$enableLoop,\n    _ref4$orientation = _ref4.orientation,\n    orientation = _ref4$orientation === void 0 ? 'horizontal' : _ref4$orientation,\n    _ref4$enableTab = _ref4.enableTab,\n    enableTab = _ref4$enableTab === void 0 ? false : _ref4$enableTab,\n    _ref4$enableHomeEnd = _ref4.enableHomeEnd,\n    enableHomeEnd = _ref4$enableHomeEnd === void 0 ? true : _ref4$enableHomeEnd;\n  var itemsLength = actionItems.length;\n\n  // If tab key navigation is disabled, the group should have only one tab stop.\n  // `updateTabIndex` adjusts the tabindex of all items accordingly for forward navigation.\n  if (!enableTab && key === 'Tab') {\n    updateTabIndex(0, actionItems);\n    return;\n  }\n  var newIndex = getNewIndex(key, itemsLength, currentIndex, {\n    enableLoop: enableLoop,\n    orientation: orientation,\n    enableTab: enableTab,\n    enableHomeEnd: enableHomeEnd\n  });\n  if (newIndex >= 0 && newIndex < itemsLength) {\n    var _actionItems$newIndex, _actionItems$newIndex2;\n    updateTabIndex(newIndex, actionItems);\n    (_actionItems$newIndex = (_actionItems$newIndex2 = actionItems[newIndex]).focus) === null || _actionItems$newIndex === void 0 ? void 0 : _actionItems$newIndex.call(_actionItems$newIndex2);\n  }\n\n  // If tab key navigation is disabled, the group should only have one tab stop.\n  // `updateTabIndex` adjusts the tabindex of all items accordingly for the backward navigation.\n  // tabShift is a custom key we defined in Menu\n  if (newIndex === -1 && !enableTab && key === 'tabShift') {\n    updateTabIndex(currentIndex, actionItems);\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","getSortedTabbableElements","isTabKey","handleTab","takeFocus","handleFocus","updateTabIndex","getNewIndex","calculateIndex","isHidden","_defer","_interopRequireDefault","require","_filter","_sortBy","e","__esModule","tabbableSelectors","tabbableSelectorsWithTabIndex","concat","isStyleVisible","element","style","window","getComputedStyle","display","visibility","isAttributeVisible","hasAttribute","isElementVisible","visibleByStyle","visibleByAttribute","isZeroSize","getClientRects","length","offsetWidth","offsetHeight","container","_ref","arguments","undefined","ignoreTabIndex","tabbableElementSelector","join","elems","querySelectorAll","tabbableElems","el","isValidTabIndex","tabIndex","document","activeElement","reducedElements","reduce","accumulator","currentElement","prevElement","isPrevElementRadio","getAttribute","isCurrElementRadio","sameRadioGroup","checked","pop","push","event","key","metaKey","altKey","controlKey","contains","tabbableElements","preventDefault","target","querySelector","currentIndex","indexOf","shiftKey","unshift","shift","focus","defaultElement","targetEl","focusMoveDirection","freeze","NONE","NEXT","PREVIOUS","_ref2","itemsLength","direction","enableLoop","includes","increment","newIndex","_ref3","orientation","enableTab","enableHomeEnd","activeIndex","actionItems","forEach","index","setAttribute","_ref4","_ref4$enableLoop","_ref4$orientation","_ref4$enableTab","_ref4$enableHomeEnd","_actionItems$newIndex","_actionItems$newIndex2","call"],"sources":["/Users/abarbas/Desktop/soar_web_forms/node_modules/@splunk/ui-utils/focus.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSortedTabbableElements = getSortedTabbableElements;\nexports.isTabKey = isTabKey;\nexports.handleTab = handleTab;\nexports.takeFocus = takeFocus;\nexports.handleFocus = handleFocus;\nexports.updateTabIndex = exports.getNewIndex = exports.calculateIndex = exports.isHidden = void 0;\nvar _defer = _interopRequireDefault(require(\"lodash/defer\"));\nvar _filter = _interopRequireDefault(require(\"lodash/filter\"));\nvar _sortBy = _interopRequireDefault(require(\"lodash/sortBy\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { \"default\": e }; }\n/**\n * @file\n * Utilities for managing focus in the browser.\n */\n\nvar tabbableSelectors = ['a[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', '[contenteditable]'];\nvar tabbableSelectorsWithTabIndex = tabbableSelectors.concat(['[tabindex]']);\nvar isStyleVisible = function isStyleVisible(element) {\n  var style = window.getComputedStyle(element);\n  return style.display !== 'none' && style.visibility !== 'hidden';\n};\nvar isAttributeVisible = function isAttributeVisible(element) {\n  return !element.hasAttribute('hidden');\n};\nvar isElementVisible = function isElementVisible(element) {\n  var visibleByStyle = isStyleVisible(element);\n  var visibleByAttribute = isAttributeVisible(element);\n  return visibleByStyle && visibleByAttribute;\n};\n\n/**\n * Determines whether an element is considered hidden based on its dimensions or computed visibility style.\n *\n * This function is primarily used in environments where accurate layout-related properties\n * are available, like a real browser environment.\n *\n * @param {Element} element - The DOM element to check for visibility.\n * @returns {boolean} - Returns true if the element is hidden, otherwise false.\n *\n * @private Exported for testing purposes\n */\nvar isHidden = function isHidden(element) {\n  // SUI-6521: `element.getClientRects().length > 0` is used to distinguish between 'actual' 0-size elements and Jest 0-size elements.\n  // 'actual' 0-size elements typically still have a value from getClientRects.\n  var isZeroSize = element.getClientRects().length > 0 && (element.offsetWidth === 0 || element.offsetHeight === 0);\n  return isZeroSize || !isElementVisible(element);\n};\n\n/**\n * Sorts the tabbable elements in the provided container.\n *\n * @param {Element} container - The target container.\n * @param {Object} [options={ignoreTabIndex: false}] - Configuration options.\n * @param {boolean} [options.ignoreTabIndex=false] - If set to true, the function will neither use \"tabindex\" as an indicator of selectability nor disqualify elements based on \"tabindex=-1\".\n * @returns {Element[]} A sorted array of tabbable elements within the container.\n * @public\n */\nexports.isHidden = isHidden;\nfunction getSortedTabbableElements(container) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    ignoreTabIndex = _ref.ignoreTabIndex;\n  var tabbableElementSelector = (ignoreTabIndex ? tabbableSelectors : tabbableSelectorsWithTabIndex).join(', ');\n  var elems = container.querySelectorAll(tabbableElementSelector);\n  var tabbableElems = (0, _filter[\"default\"])(elems, function (el) {\n    var isValidTabIndex = ignoreTabIndex || el.tabIndex >= 0;\n    return !isHidden(el) && isValidTabIndex || el === document.activeElement;\n  });\n  var reducedElements = tabbableElems.reduce(function (accumulator, currentElement) {\n    var prevElement = accumulator[accumulator.length - 1];\n    var isPrevElementRadio = (prevElement === null || prevElement === void 0 ? void 0 : prevElement.getAttribute('type')) === 'radio';\n    var isCurrElementRadio = currentElement.getAttribute('type') === 'radio';\n    var sameRadioGroup = currentElement.getAttribute('name') === (prevElement === null || prevElement === void 0 ? void 0 : prevElement.getAttribute('name'));\n\n    // Reduce radio elements to a single Tab stop, ensuring only one per group is focusable\n    if (isPrevElementRadio && isCurrElementRadio && sameRadioGroup) {\n      if (currentElement.checked) {\n        // replace previous radio with current checked radio\n        accumulator.pop();\n        accumulator.push(currentElement);\n      }\n    } else {\n      accumulator.push(currentElement);\n    }\n    return accumulator;\n  }, []);\n  return (0, _sortBy[\"default\"])(reducedElements, function (el) {\n    if (el.tabIndex > 0) {\n      return -1 / el.tabIndex;\n    }\n    return 0;\n  });\n}\nfunction isTabKey(event) {\n  return !(event.key !== 'Tab' || event.metaKey || event.altKey || event.controlKey);\n}\n\n/**\n * A key event handler that moves focus among tabbable elements within a container.\n *\n * @param {Element} container - The target container.\n * @param {Event} event - The key event to handle.\n * @returns {Element|null} The element focus was applied to or `null` if focus was not applied.\n * @public\n */\nfunction handleTab(container, event) {\n  // Ignore events bubbling up from portals\n  if (!container.contains(document.activeElement)) {\n    return null;\n  }\n\n  // Ensure this is a valid event\n  if (!isTabKey(event)) {\n    return null;\n  }\n  var tabbableElements = getSortedTabbableElements(container);\n  if (tabbableElements.length === 0) {\n    // if the container is focused, don't allow the focus to leave.\n    if (document.activeElement === container) {\n      event.preventDefault();\n      return container;\n    }\n    return null;\n  }\n\n  // Find the current index or set default.\n  var currentElement = event && event.target || container.querySelector(':focus');\n  var currentIndex = tabbableElements.indexOf(currentElement);\n  if (currentIndex === -1) {\n    currentIndex = event.shiftKey ? 0 : tabbableElements.length - 1;\n  }\n\n  // Shift the array instead of the current index.\n  if (event.shiftKey) {\n    tabbableElements.unshift(tabbableElements.pop()); // move last to first\n  } else {\n    tabbableElements.push(tabbableElements.shift()); // move first to last\n  }\n\n  // Focus\n  event.preventDefault();\n  tabbableElements[currentIndex].focus();\n  return tabbableElements[currentIndex];\n}\n\n/**\n * A helper method that focuses on the first focusable element in a container.\n * If a contained element already has focus, focus does not shift.\n *\n * @param {Element} container - The container that takes focus.\n * @param {String} [defaultElement='first'] - The target of focus, either 'first' or 'container'.\n * @returns {Element|null} The element that was focused, or null if no element was focused.\n * @public\n */\nfunction takeFocus(container) {\n  var defaultElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'first';\n  var currentElement = container.querySelector(':focus');\n  if (currentElement) {\n    return currentElement;\n  }\n  if (defaultElement === 'first') {\n    var targetEl = getSortedTabbableElements(container)[0];\n    if (targetEl) {\n      (0, _defer[\"default\"])(function () {\n        return targetEl.focus();\n      });\n      return targetEl;\n    }\n  }\n  if (container.hasAttribute('tabIndex')) {\n    (0, _defer[\"default\"])(function () {\n      return container.focus();\n    });\n    return container;\n  }\n  return null;\n}\n\n/**\n * An enumeration of possible navigation directions.\n * @readonly\n * @enum {string}\n */\nvar focusMoveDirection = Object.freeze({\n  NONE: 'none',\n  NEXT: 'next',\n  PREVIOUS: 'previous'\n});\n\n/**\n * Helper function to calculate the new index from the current index.\n *\n * This function determines the new index for focus navigation based on the current index,\n * the direction of movement, and whether looping is enabled. It either caps at the start/end\n * of the array or loops around based on the `enableLoop` flag.\n *\n * @returns {number} - The new index. Returns the current index for invalid direction or out-of-bounds index when looping is disabled.\n */\nvar calculateIndex = function calculateIndex(_ref2) {\n  var itemsLength = _ref2.itemsLength,\n    currentIndex = _ref2.currentIndex,\n    direction = _ref2.direction,\n    enableLoop = _ref2.enableLoop;\n  // Check if the direction is valid\n  if (direction === focusMoveDirection.NONE || ![focusMoveDirection.NONE, focusMoveDirection.NEXT, focusMoveDirection.PREVIOUS].includes(direction)) {\n    return currentIndex; // Return current index for invalid direction\n  }\n  var increment = direction === focusMoveDirection.NEXT ? 1 : -1;\n  if (!enableLoop) {\n    var newIndex = currentIndex + increment;\n    if (newIndex >= itemsLength || newIndex < 0) {\n      return currentIndex;\n    }\n    return newIndex;\n  }\n  return (currentIndex + increment + itemsLength) % itemsLength;\n};\n\n/**\n * Helper function to get the new focusable index in the items array based on the key.\n *\n * This function calculates the next focusable index in a list of items, depending on the provided key\n * (e.g. arrow keys, Home, End, Tab). It takes into account the current focus index, orientation of navigation\n * (horizontal or vertical), looping behavior, and specific key handling rules.\n *\n * @returns {number} - The new focusable index. Returns -1 if no valid index is found.\n */\nexports.calculateIndex = calculateIndex;\nvar getNewIndex = function getNewIndex(key, itemsLength, currentIndex, _ref3) {\n  var enableLoop = _ref3.enableLoop,\n    orientation = _ref3.orientation,\n    enableTab = _ref3.enableTab,\n    enableHomeEnd = _ref3.enableHomeEnd;\n  // If the current focused item is not in the actionItems, then focus on the first focusable item.\n  if (currentIndex < 0 || currentIndex >= itemsLength) {\n    return 0;\n  }\n  if (key === 'Home') {\n    return enableHomeEnd ? 0 : -1;\n  }\n  if (key === 'End') {\n    return enableHomeEnd ? itemsLength - 1 : -1;\n  }\n  var direction = focusMoveDirection.NONE;\n  if (orientation === 'horizontal') {\n    if (key === 'ArrowLeft') {\n      direction = focusMoveDirection.PREVIOUS;\n    }\n    if (key === 'ArrowRight') {\n      direction = focusMoveDirection.NEXT;\n    }\n  } else if (orientation === 'vertical') {\n    if (key === 'ArrowUp') {\n      direction = focusMoveDirection.PREVIOUS;\n    }\n    if (key === 'ArrowDown') {\n      direction = focusMoveDirection.NEXT;\n    }\n  }\n  if (enableTab) {\n    // tabShift is a custom key we defined in Menu\n    if (key === 'tabShift') {\n      direction = focusMoveDirection.PREVIOUS;\n    }\n    if (key === 'Tab') {\n      direction = focusMoveDirection.NEXT;\n    }\n  }\n  if (direction !== focusMoveDirection.NONE) {\n    return calculateIndex({\n      itemsLength: itemsLength,\n      currentIndex: currentIndex,\n      direction: direction,\n      enableLoop: enableLoop\n    });\n  }\n  return -1;\n};\n\n/**\n *  Helper function to update the tabindex of action items, setting the active item to be focusable\n */\nexports.getNewIndex = getNewIndex;\nvar updateTabIndex = function updateTabIndex(activeIndex, actionItems) {\n  actionItems.forEach(function (el, index) {\n    return el.setAttribute('tabindex', index === activeIndex ? '0' : '-1');\n  });\n};\n\n/**\n * Handles focus navigation for a list of action items based on key presses.\n *\n * @param {string} key - The key value obtained from KeyboardEvent.key, representing the keyboard key pressed.\n * @param {HTMLElement[]} actionItems - An array of HTML elements representing the action items.\n * @param {number} currentIndex - The current index of the focused item.\n * @param {Object} [options={ enableLoop: false, orientation: 'horizontal', enableTab: false, enableHomeEnd: true }] - Configuration options.\n * @param {boolean} [options.enableLoop=false] - Whether navigation should loop around the ends of the list.\n * @param {string} [options.orientation='horizontal'] - Navigation orientation: 'horizontal' (left/right arrow keys) or 'vertical' (up/down arrow keys).\n * @param {boolean} [options.enableTab=false] - Enable navigation with the Tab key.\n * @param {boolean} [options.enableHomeEnd=true] - Enable navigation with Home and End keys.\n * @public\n */\nexports.updateTabIndex = updateTabIndex;\nfunction handleFocus(key, actionItems, currentIndex) {\n  var _ref4 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n    _ref4$enableLoop = _ref4.enableLoop,\n    enableLoop = _ref4$enableLoop === void 0 ? false : _ref4$enableLoop,\n    _ref4$orientation = _ref4.orientation,\n    orientation = _ref4$orientation === void 0 ? 'horizontal' : _ref4$orientation,\n    _ref4$enableTab = _ref4.enableTab,\n    enableTab = _ref4$enableTab === void 0 ? false : _ref4$enableTab,\n    _ref4$enableHomeEnd = _ref4.enableHomeEnd,\n    enableHomeEnd = _ref4$enableHomeEnd === void 0 ? true : _ref4$enableHomeEnd;\n  var itemsLength = actionItems.length;\n\n  // If tab key navigation is disabled, the group should have only one tab stop.\n  // `updateTabIndex` adjusts the tabindex of all items accordingly for forward navigation.\n  if (!enableTab && key === 'Tab') {\n    updateTabIndex(0, actionItems);\n    return;\n  }\n  var newIndex = getNewIndex(key, itemsLength, currentIndex, {\n    enableLoop: enableLoop,\n    orientation: orientation,\n    enableTab: enableTab,\n    enableHomeEnd: enableHomeEnd\n  });\n  if (newIndex >= 0 && newIndex < itemsLength) {\n    var _actionItems$newIndex, _actionItems$newIndex2;\n    updateTabIndex(newIndex, actionItems);\n    (_actionItems$newIndex = (_actionItems$newIndex2 = actionItems[newIndex]).focus) === null || _actionItems$newIndex === void 0 ? void 0 : _actionItems$newIndex.call(_actionItems$newIndex2);\n  }\n\n  // If tab key navigation is disabled, the group should only have one tab stop.\n  // `updateTabIndex` adjusts the tabindex of all items accordingly for the backward navigation.\n  // tabShift is a custom key we defined in Menu\n  if (newIndex === -1 && !enableTab && key === 'tabShift') {\n    updateTabIndex(currentIndex, actionItems);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}