{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSortedTabbableElements = getSortedTabbableElements;\nexports.isTabKey = isTabKey;\nexports.handleTab = handleTab;\nexports.takeFocus = takeFocus;\nexports.handleFocus = handleFocus;\nexports.updateTabIndex = exports.getNewIndex = exports.calculateIndex = exports.isHidden = void 0;\nvar _keyboard = require(\"@splunk/ui-utils/keyboard\");\nvar _defer = _interopRequireDefault(require(\"lodash/defer\"));\nvar _filter = _interopRequireDefault(require(\"lodash/filter\"));\nvar _sortBy = _interopRequireDefault(require(\"lodash/sortBy\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\n/**\n * @file\n * Utilities for managing focus in the browser.\n */\nvar tabbableSelectors = ['a[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', '[contenteditable]'];\nvar tabbableSelectorsWithTabIndex = tabbableSelectors.concat(['[tabindex]']);\nvar isStyleVisible = function isStyleVisible(element) {\n  var style = window.getComputedStyle(element);\n  return style.display !== 'none' && style.visibility !== 'hidden';\n};\nvar isAttributeVisible = function isAttributeVisible(element) {\n  return !element.hasAttribute('hidden');\n};\nvar isElementVisible = function isElementVisible(element) {\n  var visibleByStyle = isStyleVisible(element);\n  var visibleByAttribute = isAttributeVisible(element);\n  return visibleByStyle && visibleByAttribute;\n};\n/**\n * Determines whether an element is considered hidden based on its dimensions or computed visibility style.\n *\n * This function is primarily used in environments where accurate layout-related properties\n * are available, like a real browser environment.\n *\n * @param {Element} element - The DOM element to check for visibility.\n * @returns {boolean} - Returns true if the element is hidden, otherwise false.\n *\n * @private Exported for testing purposes\n */\n\nvar isHidden = function isHidden(element) {\n  // SUI-6521: `element.getClientRects().length > 0` is used to distinguish between 'actual' 0-size elements and Jest 0-size elements.\n  // 'actual' 0-size elements typically still have a value from getClientRects.\n  var isZeroSize = element.getClientRects().length > 0 && (element.offsetWidth === 0 || element.offsetHeight === 0);\n  return isZeroSize || !isElementVisible(element);\n};\n/**\n * Sorts the tabbable elements in the provided container.\n *\n * @param {Element} container - The target container.\n * @param {Object} [options={ignoreTabIndex: false}] - Configuration options.\n * @param {boolean} [options.ignoreTabIndex=false] - If set to true, the function will neither use \"tabindex\" as an indicator of selectability nor disqualify elements based on \"tabindex=-1\".\n * @returns {Element[]} A sorted array of tabbable elements within the container.\n * @public\n */\n\nexports.isHidden = isHidden;\nfunction getSortedTabbableElements(container) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    ignoreTabIndex = _ref.ignoreTabIndex;\n  var tabbableElementSelector = (ignoreTabIndex ? tabbableSelectors : tabbableSelectorsWithTabIndex).join(', ');\n  var elems = container.querySelectorAll(tabbableElementSelector);\n  var tabbableElems = (0, _filter[\"default\"])(elems, function (el) {\n    var isValidTabIndex = ignoreTabIndex || el.tabIndex >= 0;\n    return !isHidden(el) && isValidTabIndex || el === document.activeElement;\n  });\n  var reducedElements = tabbableElems.reduce(function (accumulator, currentElement) {\n    var prevElement = accumulator[accumulator.length - 1];\n    var isPrevElementRadio = (prevElement === null || prevElement === void 0 ? void 0 : prevElement.getAttribute('type')) === 'radio';\n    var isCurrElementRadio = currentElement.getAttribute('type') === 'radio';\n    var sameRadioGroup = currentElement.getAttribute('name') === (prevElement === null || prevElement === void 0 ? void 0 : prevElement.getAttribute('name')); // Reduce radio elements to a single Tab stop, ensuring only one per group is focusable\n\n    if (isPrevElementRadio && isCurrElementRadio && sameRadioGroup) {\n      if (currentElement.checked) {\n        // replace previous radio with current checked radio\n        accumulator.pop();\n        accumulator.push(currentElement);\n      }\n    } else {\n      accumulator.push(currentElement);\n    }\n    return accumulator;\n  }, []);\n  return (0, _sortBy[\"default\"])(reducedElements, function (el) {\n    if (el.tabIndex > 0) {\n      return -1 / el.tabIndex;\n    }\n    return 0;\n  });\n}\nfunction isTabKey(event) {\n  return !((0, _keyboard.keycode)(event) !== 'tab' || event.metaKey || event.altKey || event.controlKey);\n}\n/**\n * A key event handler that moves focus among tabbable elements within a container.\n *\n * @param {Element} container - The target container.\n * @param {Event} event - The key event to handle.\n * @returns {Element|null} The element focus was applied to or `null` if focus was not applied.\n * @public\n */\n\nfunction handleTab(container, event) {\n  // Ignore events bubbling up from portals\n  if (!container.contains(document.activeElement)) {\n    return null;\n  } // Ensure this is a valid event\n\n  if (!isTabKey(event)) {\n    return null;\n  }\n  var tabbableElements = getSortedTabbableElements(container);\n  if (tabbableElements.length === 0) {\n    // if the container is focused, don't allow the focus to leave.\n    if (document.activeElement === container) {\n      event.preventDefault();\n      return container;\n    }\n    return null;\n  } // Find the current index or set default.\n\n  var currentElement = event && event.target || container.querySelector(':focus');\n  var currentIndex = tabbableElements.indexOf(currentElement);\n  if (currentIndex === -1) {\n    currentIndex = event.shiftKey ? 0 : tabbableElements.length - 1;\n  } // Shift the array instead of the current index.\n\n  if (event.shiftKey) {\n    tabbableElements.unshift(tabbableElements.pop()); // move last to first\n  } else {\n    tabbableElements.push(tabbableElements.shift()); // move first to last\n  } // Focus\n\n  event.preventDefault();\n  tabbableElements[currentIndex].focus();\n  return tabbableElements[currentIndex];\n}\n/**\n * A helper method that focuses on the first focusable element in a container.\n * If a contained element already has focus, focus does not shift.\n *\n * @param {Element} container - The container that takes focus.\n * @param {String} [defaultElement='first'] - The target of focus, either 'first' or 'container'.\n * @returns {Element|null} The element that was focused, or null if no element was focused.\n * @public\n */\n\nfunction takeFocus(container) {\n  var defaultElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'first';\n  var currentElement = container.querySelector(':focus');\n  if (currentElement) {\n    return currentElement;\n  }\n  if (defaultElement === 'first') {\n    var targetEl = getSortedTabbableElements(container)[0];\n    if (targetEl) {\n      (0, _defer[\"default\"])(function () {\n        return targetEl.focus();\n      });\n      return targetEl;\n    }\n  }\n  if (container.hasAttribute('tabIndex')) {\n    (0, _defer[\"default\"])(function () {\n      return container.focus();\n    });\n    return container;\n  }\n  return null;\n}\n/**\n * An enumeration of possible navigation directions.\n * @readonly\n * @enum {string}\n */\n\nvar focusMoveDirection = Object.freeze({\n  NONE: 'none',\n  NEXT: 'next',\n  PREVIOUS: 'previous'\n});\n/**\n * Helper function to calculate the new index from the current index.\n *\n * This function determines the new index for focus navigation based on the current index,\n * the direction of movement, and whether looping is enabled. It either caps at the start/end\n * of the array or loops around based on the `enableLoop` flag.\n *\n * @returns {number} - The new index. Returns the current index for invalid direction or out-of-bounds index when looping is disabled.\n */\n\nvar calculateIndex = function calculateIndex(_ref2) {\n  var itemsLength = _ref2.itemsLength,\n    currentIndex = _ref2.currentIndex,\n    direction = _ref2.direction,\n    enableLoop = _ref2.enableLoop;\n\n  // Check if the direction is valid\n  if (direction === focusMoveDirection.NONE || ![focusMoveDirection.NONE, focusMoveDirection.NEXT, focusMoveDirection.PREVIOUS].includes(direction)) {\n    return currentIndex; // Return current index for invalid direction\n  }\n  var increment = direction === focusMoveDirection.NEXT ? 1 : -1;\n  if (!enableLoop) {\n    var newIndex = currentIndex + increment;\n    if (newIndex >= itemsLength || newIndex < 0) {\n      return currentIndex;\n    }\n    return newIndex;\n  }\n  return (currentIndex + increment + itemsLength) % itemsLength;\n};\n/**\n * Helper function to get the new focusable index in the items array based on the keyCode.\n *\n * This function calculates the next focusable index in a list of items, depending on the provided keyCode\n * (e.g., arrow keys, home, end, tab). It takes into account the current focus index, orientation of navigation\n * (horizontal or vertical), looping behavior, and specific key handling rules.\n *\n * @returns {number} - The new focusable index. Returns -1 if no valid index is found.\n */\n\nexports.calculateIndex = calculateIndex;\nvar getNewIndex = function getNewIndex(keyCode, itemsLength, currentIndex, _ref3) {\n  var enableLoop = _ref3.enableLoop,\n    orientation = _ref3.orientation,\n    enableTab = _ref3.enableTab,\n    enableHomeEnd = _ref3.enableHomeEnd;\n\n  // If the current focused item is not in the actionItems, then focus on the first focusable item.\n  if (currentIndex < 0 || currentIndex >= itemsLength) {\n    return 0;\n  }\n  if (keyCode === 'home') {\n    return enableHomeEnd ? 0 : -1;\n  }\n  if (keyCode === 'end') {\n    return enableHomeEnd ? itemsLength - 1 : -1;\n  }\n  var direction = focusMoveDirection.NONE;\n  if (orientation === 'horizontal') {\n    if (keyCode === 'left') {\n      direction = focusMoveDirection.PREVIOUS;\n    }\n    if (keyCode === 'right') {\n      direction = focusMoveDirection.NEXT;\n    }\n  } else if (orientation === 'vertical') {\n    if (keyCode === 'up') {\n      direction = focusMoveDirection.PREVIOUS;\n    }\n    if (keyCode === 'down') {\n      direction = focusMoveDirection.NEXT;\n    }\n  }\n  if (enableTab) {\n    if (keyCode === 'tabShift') {\n      direction = focusMoveDirection.PREVIOUS;\n    }\n    if (keyCode === 'tab') {\n      direction = focusMoveDirection.NEXT;\n    }\n  }\n  if (direction !== focusMoveDirection.NONE) {\n    return calculateIndex({\n      itemsLength: itemsLength,\n      currentIndex: currentIndex,\n      direction: direction,\n      enableLoop: enableLoop\n    });\n  }\n  return -1;\n};\n/**\n *  Helper function to update the tabindex of action items, setting the active item to be focusable\n */\n\nexports.getNewIndex = getNewIndex;\nvar updateTabIndex = function updateTabIndex(activeIndex, actionItems) {\n  actionItems.forEach(function (el, index) {\n    return el.setAttribute('tabindex', index === activeIndex ? '0' : '-1');\n  });\n};\n/**\n * Handles focus navigation for a list of action items based on key presses.\n *\n * @param {string} key - The key code representing the key pressed. The key value is obtained from the `keycode` method from '@splunk/ui-utils/keyboard'.\n * @param {HTMLElement[]} actionItems - An array of HTML elements representing the action items.\n * @param {number} currentIndex - The current index of the focused item.\n * @param {Object} [options={ enableLoop: false, orientation: 'horizontal', enableTab: false, enableHomeEnd: true }] - Configuration options.\n * @param {boolean} [options.enableLoop=false] - Whether navigation should loop around the ends of the list.\n * @param {string} [options.orientation='horizontal'] - Navigation orientation: 'horizontal' (left/right arrow keys) or 'vertical' (up/down arrow keys).\n * @param {boolean} [options.enableTab=false] - Enable navigation with the Tab key.\n * @param {boolean} [options.enableHomeEnd=true] - Enable navigation with Home and End keys.\n * @public\n */\n\nexports.updateTabIndex = updateTabIndex;\nfunction handleFocus(key, actionItems, currentIndex) {\n  var _ref4 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n    _ref4$enableLoop = _ref4.enableLoop,\n    enableLoop = _ref4$enableLoop === void 0 ? false : _ref4$enableLoop,\n    _ref4$orientation = _ref4.orientation,\n    orientation = _ref4$orientation === void 0 ? 'horizontal' : _ref4$orientation,\n    _ref4$enableTab = _ref4.enableTab,\n    enableTab = _ref4$enableTab === void 0 ? false : _ref4$enableTab,\n    _ref4$enableHomeEnd = _ref4.enableHomeEnd,\n    enableHomeEnd = _ref4$enableHomeEnd === void 0 ? true : _ref4$enableHomeEnd;\n  var itemsLength = actionItems.length; // If tab key navigation is disabled, the group should have only one tab stop.\n  // `updateTabIndex` adjusts the tabindex of all items accordingly for forward navigation.\n\n  if (!enableTab && key === 'tab') {\n    updateTabIndex(0, actionItems);\n    return;\n  }\n  var newIndex = getNewIndex(key, itemsLength, currentIndex, {\n    enableLoop: enableLoop,\n    orientation: orientation,\n    enableTab: enableTab,\n    enableHomeEnd: enableHomeEnd\n  });\n  if (newIndex >= 0 && newIndex < itemsLength) {\n    var _actionItems$newIndex, _actionItems$newIndex2;\n    updateTabIndex(newIndex, actionItems);\n    (_actionItems$newIndex = (_actionItems$newIndex2 = actionItems[newIndex]).focus) === null || _actionItems$newIndex === void 0 ? void 0 : _actionItems$newIndex.call(_actionItems$newIndex2);\n  } // If tab key navigation is disabled, the group should only have one tab stop.\n  // `updateTabIndex` adjusts the tabindex of all items accordingly for the backward navigation.\n\n  if (newIndex === -1 && !enableTab && key === 'tabShift') {\n    updateTabIndex(currentIndex, actionItems);\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","getSortedTabbableElements","isTabKey","handleTab","takeFocus","handleFocus","updateTabIndex","getNewIndex","calculateIndex","isHidden","_keyboard","require","_defer","_interopRequireDefault","_filter","_sortBy","obj","__esModule","tabbableSelectors","tabbableSelectorsWithTabIndex","concat","isStyleVisible","element","style","window","getComputedStyle","display","visibility","isAttributeVisible","hasAttribute","isElementVisible","visibleByStyle","visibleByAttribute","isZeroSize","getClientRects","length","offsetWidth","offsetHeight","container","_ref","arguments","undefined","ignoreTabIndex","tabbableElementSelector","join","elems","querySelectorAll","tabbableElems","el","isValidTabIndex","tabIndex","document","activeElement","reducedElements","reduce","accumulator","currentElement","prevElement","isPrevElementRadio","getAttribute","isCurrElementRadio","sameRadioGroup","checked","pop","push","event","keycode","metaKey","altKey","controlKey","contains","tabbableElements","preventDefault","target","querySelector","currentIndex","indexOf","shiftKey","unshift","shift","focus","defaultElement","targetEl","focusMoveDirection","freeze","NONE","NEXT","PREVIOUS","_ref2","itemsLength","direction","enableLoop","includes","increment","newIndex","keyCode","_ref3","orientation","enableTab","enableHomeEnd","activeIndex","actionItems","forEach","index","setAttribute","key","_ref4","_ref4$enableLoop","_ref4$orientation","_ref4$enableTab","_ref4$enableHomeEnd","_actionItems$newIndex","_actionItems$newIndex2","call"],"sources":["C:/Users/abarbas/Desktop/soar_web_forms/node_modules/@splunk/ui-utils/focus.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSortedTabbableElements = getSortedTabbableElements;\nexports.isTabKey = isTabKey;\nexports.handleTab = handleTab;\nexports.takeFocus = takeFocus;\nexports.handleFocus = handleFocus;\nexports.updateTabIndex = exports.getNewIndex = exports.calculateIndex = exports.isHidden = void 0;\n\nvar _keyboard = require(\"@splunk/ui-utils/keyboard\");\n\nvar _defer = _interopRequireDefault(require(\"lodash/defer\"));\n\nvar _filter = _interopRequireDefault(require(\"lodash/filter\"));\n\nvar _sortBy = _interopRequireDefault(require(\"lodash/sortBy\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * @file\n * Utilities for managing focus in the browser.\n */\nvar tabbableSelectors = ['a[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', '[contenteditable]'];\nvar tabbableSelectorsWithTabIndex = tabbableSelectors.concat(['[tabindex]']);\n\nvar isStyleVisible = function isStyleVisible(element) {\n  var style = window.getComputedStyle(element);\n  return style.display !== 'none' && style.visibility !== 'hidden';\n};\n\nvar isAttributeVisible = function isAttributeVisible(element) {\n  return !element.hasAttribute('hidden');\n};\n\nvar isElementVisible = function isElementVisible(element) {\n  var visibleByStyle = isStyleVisible(element);\n  var visibleByAttribute = isAttributeVisible(element);\n  return visibleByStyle && visibleByAttribute;\n};\n/**\n * Determines whether an element is considered hidden based on its dimensions or computed visibility style.\n *\n * This function is primarily used in environments where accurate layout-related properties\n * are available, like a real browser environment.\n *\n * @param {Element} element - The DOM element to check for visibility.\n * @returns {boolean} - Returns true if the element is hidden, otherwise false.\n *\n * @private Exported for testing purposes\n */\n\n\nvar isHidden = function isHidden(element) {\n  // SUI-6521: `element.getClientRects().length > 0` is used to distinguish between 'actual' 0-size elements and Jest 0-size elements.\n  // 'actual' 0-size elements typically still have a value from getClientRects.\n  var isZeroSize = element.getClientRects().length > 0 && (element.offsetWidth === 0 || element.offsetHeight === 0);\n  return isZeroSize || !isElementVisible(element);\n};\n/**\n * Sorts the tabbable elements in the provided container.\n *\n * @param {Element} container - The target container.\n * @param {Object} [options={ignoreTabIndex: false}] - Configuration options.\n * @param {boolean} [options.ignoreTabIndex=false] - If set to true, the function will neither use \"tabindex\" as an indicator of selectability nor disqualify elements based on \"tabindex=-1\".\n * @returns {Element[]} A sorted array of tabbable elements within the container.\n * @public\n */\n\n\nexports.isHidden = isHidden;\n\nfunction getSortedTabbableElements(container) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      ignoreTabIndex = _ref.ignoreTabIndex;\n\n  var tabbableElementSelector = (ignoreTabIndex ? tabbableSelectors : tabbableSelectorsWithTabIndex).join(', ');\n  var elems = container.querySelectorAll(tabbableElementSelector);\n  var tabbableElems = (0, _filter[\"default\"])(elems, function (el) {\n    var isValidTabIndex = ignoreTabIndex || el.tabIndex >= 0;\n    return !isHidden(el) && isValidTabIndex || el === document.activeElement;\n  });\n  var reducedElements = tabbableElems.reduce(function (accumulator, currentElement) {\n    var prevElement = accumulator[accumulator.length - 1];\n    var isPrevElementRadio = (prevElement === null || prevElement === void 0 ? void 0 : prevElement.getAttribute('type')) === 'radio';\n    var isCurrElementRadio = currentElement.getAttribute('type') === 'radio';\n    var sameRadioGroup = currentElement.getAttribute('name') === (prevElement === null || prevElement === void 0 ? void 0 : prevElement.getAttribute('name')); // Reduce radio elements to a single Tab stop, ensuring only one per group is focusable\n\n    if (isPrevElementRadio && isCurrElementRadio && sameRadioGroup) {\n      if (currentElement.checked) {\n        // replace previous radio with current checked radio\n        accumulator.pop();\n        accumulator.push(currentElement);\n      }\n    } else {\n      accumulator.push(currentElement);\n    }\n\n    return accumulator;\n  }, []);\n  return (0, _sortBy[\"default\"])(reducedElements, function (el) {\n    if (el.tabIndex > 0) {\n      return -1 / el.tabIndex;\n    }\n\n    return 0;\n  });\n}\n\nfunction isTabKey(event) {\n  return !((0, _keyboard.keycode)(event) !== 'tab' || event.metaKey || event.altKey || event.controlKey);\n}\n/**\n * A key event handler that moves focus among tabbable elements within a container.\n *\n * @param {Element} container - The target container.\n * @param {Event} event - The key event to handle.\n * @returns {Element|null} The element focus was applied to or `null` if focus was not applied.\n * @public\n */\n\n\nfunction handleTab(container, event) {\n  // Ignore events bubbling up from portals\n  if (!container.contains(document.activeElement)) {\n    return null;\n  } // Ensure this is a valid event\n\n\n  if (!isTabKey(event)) {\n    return null;\n  }\n\n  var tabbableElements = getSortedTabbableElements(container);\n\n  if (tabbableElements.length === 0) {\n    // if the container is focused, don't allow the focus to leave.\n    if (document.activeElement === container) {\n      event.preventDefault();\n      return container;\n    }\n\n    return null;\n  } // Find the current index or set default.\n\n\n  var currentElement = event && event.target || container.querySelector(':focus');\n  var currentIndex = tabbableElements.indexOf(currentElement);\n\n  if (currentIndex === -1) {\n    currentIndex = event.shiftKey ? 0 : tabbableElements.length - 1;\n  } // Shift the array instead of the current index.\n\n\n  if (event.shiftKey) {\n    tabbableElements.unshift(tabbableElements.pop()); // move last to first\n  } else {\n    tabbableElements.push(tabbableElements.shift()); // move first to last\n  } // Focus\n\n\n  event.preventDefault();\n  tabbableElements[currentIndex].focus();\n  return tabbableElements[currentIndex];\n}\n/**\n * A helper method that focuses on the first focusable element in a container.\n * If a contained element already has focus, focus does not shift.\n *\n * @param {Element} container - The container that takes focus.\n * @param {String} [defaultElement='first'] - The target of focus, either 'first' or 'container'.\n * @returns {Element|null} The element that was focused, or null if no element was focused.\n * @public\n */\n\n\nfunction takeFocus(container) {\n  var defaultElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'first';\n  var currentElement = container.querySelector(':focus');\n\n  if (currentElement) {\n    return currentElement;\n  }\n\n  if (defaultElement === 'first') {\n    var targetEl = getSortedTabbableElements(container)[0];\n\n    if (targetEl) {\n      (0, _defer[\"default\"])(function () {\n        return targetEl.focus();\n      });\n      return targetEl;\n    }\n  }\n\n  if (container.hasAttribute('tabIndex')) {\n    (0, _defer[\"default\"])(function () {\n      return container.focus();\n    });\n    return container;\n  }\n\n  return null;\n}\n/**\n * An enumeration of possible navigation directions.\n * @readonly\n * @enum {string}\n */\n\n\nvar focusMoveDirection = Object.freeze({\n  NONE: 'none',\n  NEXT: 'next',\n  PREVIOUS: 'previous'\n});\n/**\n * Helper function to calculate the new index from the current index.\n *\n * This function determines the new index for focus navigation based on the current index,\n * the direction of movement, and whether looping is enabled. It either caps at the start/end\n * of the array or loops around based on the `enableLoop` flag.\n *\n * @returns {number} - The new index. Returns the current index for invalid direction or out-of-bounds index when looping is disabled.\n */\n\nvar calculateIndex = function calculateIndex(_ref2) {\n  var itemsLength = _ref2.itemsLength,\n      currentIndex = _ref2.currentIndex,\n      direction = _ref2.direction,\n      enableLoop = _ref2.enableLoop;\n\n  // Check if the direction is valid\n  if (direction === focusMoveDirection.NONE || ![focusMoveDirection.NONE, focusMoveDirection.NEXT, focusMoveDirection.PREVIOUS].includes(direction)) {\n    return currentIndex; // Return current index for invalid direction\n  }\n\n  var increment = direction === focusMoveDirection.NEXT ? 1 : -1;\n\n  if (!enableLoop) {\n    var newIndex = currentIndex + increment;\n\n    if (newIndex >= itemsLength || newIndex < 0) {\n      return currentIndex;\n    }\n\n    return newIndex;\n  }\n\n  return (currentIndex + increment + itemsLength) % itemsLength;\n};\n/**\n * Helper function to get the new focusable index in the items array based on the keyCode.\n *\n * This function calculates the next focusable index in a list of items, depending on the provided keyCode\n * (e.g., arrow keys, home, end, tab). It takes into account the current focus index, orientation of navigation\n * (horizontal or vertical), looping behavior, and specific key handling rules.\n *\n * @returns {number} - The new focusable index. Returns -1 if no valid index is found.\n */\n\n\nexports.calculateIndex = calculateIndex;\n\nvar getNewIndex = function getNewIndex(keyCode, itemsLength, currentIndex, _ref3) {\n  var enableLoop = _ref3.enableLoop,\n      orientation = _ref3.orientation,\n      enableTab = _ref3.enableTab,\n      enableHomeEnd = _ref3.enableHomeEnd;\n\n  // If the current focused item is not in the actionItems, then focus on the first focusable item.\n  if (currentIndex < 0 || currentIndex >= itemsLength) {\n    return 0;\n  }\n\n  if (keyCode === 'home') {\n    return enableHomeEnd ? 0 : -1;\n  }\n\n  if (keyCode === 'end') {\n    return enableHomeEnd ? itemsLength - 1 : -1;\n  }\n\n  var direction = focusMoveDirection.NONE;\n\n  if (orientation === 'horizontal') {\n    if (keyCode === 'left') {\n      direction = focusMoveDirection.PREVIOUS;\n    }\n\n    if (keyCode === 'right') {\n      direction = focusMoveDirection.NEXT;\n    }\n  } else if (orientation === 'vertical') {\n    if (keyCode === 'up') {\n      direction = focusMoveDirection.PREVIOUS;\n    }\n\n    if (keyCode === 'down') {\n      direction = focusMoveDirection.NEXT;\n    }\n  }\n\n  if (enableTab) {\n    if (keyCode === 'tabShift') {\n      direction = focusMoveDirection.PREVIOUS;\n    }\n\n    if (keyCode === 'tab') {\n      direction = focusMoveDirection.NEXT;\n    }\n  }\n\n  if (direction !== focusMoveDirection.NONE) {\n    return calculateIndex({\n      itemsLength: itemsLength,\n      currentIndex: currentIndex,\n      direction: direction,\n      enableLoop: enableLoop\n    });\n  }\n\n  return -1;\n};\n/**\n *  Helper function to update the tabindex of action items, setting the active item to be focusable\n */\n\n\nexports.getNewIndex = getNewIndex;\n\nvar updateTabIndex = function updateTabIndex(activeIndex, actionItems) {\n  actionItems.forEach(function (el, index) {\n    return el.setAttribute('tabindex', index === activeIndex ? '0' : '-1');\n  });\n};\n/**\n * Handles focus navigation for a list of action items based on key presses.\n *\n * @param {string} key - The key code representing the key pressed. The key value is obtained from the `keycode` method from '@splunk/ui-utils/keyboard'.\n * @param {HTMLElement[]} actionItems - An array of HTML elements representing the action items.\n * @param {number} currentIndex - The current index of the focused item.\n * @param {Object} [options={ enableLoop: false, orientation: 'horizontal', enableTab: false, enableHomeEnd: true }] - Configuration options.\n * @param {boolean} [options.enableLoop=false] - Whether navigation should loop around the ends of the list.\n * @param {string} [options.orientation='horizontal'] - Navigation orientation: 'horizontal' (left/right arrow keys) or 'vertical' (up/down arrow keys).\n * @param {boolean} [options.enableTab=false] - Enable navigation with the Tab key.\n * @param {boolean} [options.enableHomeEnd=true] - Enable navigation with Home and End keys.\n * @public\n */\n\n\nexports.updateTabIndex = updateTabIndex;\n\nfunction handleFocus(key, actionItems, currentIndex) {\n  var _ref4 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n      _ref4$enableLoop = _ref4.enableLoop,\n      enableLoop = _ref4$enableLoop === void 0 ? false : _ref4$enableLoop,\n      _ref4$orientation = _ref4.orientation,\n      orientation = _ref4$orientation === void 0 ? 'horizontal' : _ref4$orientation,\n      _ref4$enableTab = _ref4.enableTab,\n      enableTab = _ref4$enableTab === void 0 ? false : _ref4$enableTab,\n      _ref4$enableHomeEnd = _ref4.enableHomeEnd,\n      enableHomeEnd = _ref4$enableHomeEnd === void 0 ? true : _ref4$enableHomeEnd;\n\n  var itemsLength = actionItems.length; // If tab key navigation is disabled, the group should have only one tab stop.\n  // `updateTabIndex` adjusts the tabindex of all items accordingly for forward navigation.\n\n  if (!enableTab && key === 'tab') {\n    updateTabIndex(0, actionItems);\n    return;\n  }\n\n  var newIndex = getNewIndex(key, itemsLength, currentIndex, {\n    enableLoop: enableLoop,\n    orientation: orientation,\n    enableTab: enableTab,\n    enableHomeEnd: enableHomeEnd\n  });\n\n  if (newIndex >= 0 && newIndex < itemsLength) {\n    var _actionItems$newIndex, _actionItems$newIndex2;\n\n    updateTabIndex(newIndex, actionItems);\n    (_actionItems$newIndex = (_actionItems$newIndex2 = actionItems[newIndex]).focus) === null || _actionItems$newIndex === void 0 ? void 0 : _actionItems$newIndex.call(_actionItems$newIndex2);\n  } // If tab key navigation is disabled, the group should only have one tab stop.\n  // `updateTabIndex` adjusts the tabindex of all items accordingly for the backward navigation.\n\n\n  if (newIndex === -1 && !enableTab && key === 'tabShift') {\n    updateTabIndex(currentIndex, actionItems);\n  }\n}"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,yBAAyB,GAAGA,yBAAyB;AAC7DF,OAAO,CAACG,QAAQ,GAAGA,QAAQ;AAC3BH,OAAO,CAACI,SAAS,GAAGA,SAAS;AAC7BJ,OAAO,CAACK,SAAS,GAAGA,SAAS;AAC7BL,OAAO,CAACM,WAAW,GAAGA,WAAW;AACjCN,OAAO,CAACO,cAAc,GAAGP,OAAO,CAACQ,WAAW,GAAGR,OAAO,CAACS,cAAc,GAAGT,OAAO,CAACU,QAAQ,GAAG,KAAK,CAAC;AAEjG,IAAIC,SAAS,GAAGC,OAAO,CAAC,2BAA2B,CAAC;AAEpD,IAAIC,MAAM,GAAGC,sBAAsB,CAACF,OAAO,CAAC,cAAc,CAAC,CAAC;AAE5D,IAAIG,OAAO,GAAGD,sBAAsB,CAACF,OAAO,CAAC,eAAe,CAAC,CAAC;AAE9D,IAAII,OAAO,GAAGF,sBAAsB,CAACF,OAAO,CAAC,eAAe,CAAC,CAAC;AAE9D,SAASE,sBAAsBA,CAACG,GAAG,EAAE;EAAE,OAAOA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAGD,GAAG,GAAG;IAAE,SAAS,EAAEA;EAAI,CAAC;AAAE;;AAEhG;AACA;AACA;AACA;AACA,IAAIE,iBAAiB,GAAG,CAAC,SAAS,EAAE,uBAAuB,EAAE,wBAAwB,EAAE,0BAA0B,EAAE,wBAAwB,EAAE,mBAAmB,CAAC;AACjK,IAAIC,6BAA6B,GAAGD,iBAAiB,CAACE,MAAM,CAAC,CAAC,YAAY,CAAC,CAAC;AAE5E,IAAIC,cAAc,GAAG,SAASA,cAAcA,CAACC,OAAO,EAAE;EACpD,IAAIC,KAAK,GAAGC,MAAM,CAACC,gBAAgB,CAACH,OAAO,CAAC;EAC5C,OAAOC,KAAK,CAACG,OAAO,KAAK,MAAM,IAAIH,KAAK,CAACI,UAAU,KAAK,QAAQ;AAClE,CAAC;AAED,IAAIC,kBAAkB,GAAG,SAASA,kBAAkBA,CAACN,OAAO,EAAE;EAC5D,OAAO,CAACA,OAAO,CAACO,YAAY,CAAC,QAAQ,CAAC;AACxC,CAAC;AAED,IAAIC,gBAAgB,GAAG,SAASA,gBAAgBA,CAACR,OAAO,EAAE;EACxD,IAAIS,cAAc,GAAGV,cAAc,CAACC,OAAO,CAAC;EAC5C,IAAIU,kBAAkB,GAAGJ,kBAAkB,CAACN,OAAO,CAAC;EACpD,OAAOS,cAAc,IAAIC,kBAAkB;AAC7C,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,IAAIvB,QAAQ,GAAG,SAASA,QAAQA,CAACa,OAAO,EAAE;EACxC;EACA;EACA,IAAIW,UAAU,GAAGX,OAAO,CAACY,cAAc,CAAC,CAAC,CAACC,MAAM,GAAG,CAAC,KAAKb,OAAO,CAACc,WAAW,KAAK,CAAC,IAAId,OAAO,CAACe,YAAY,KAAK,CAAC,CAAC;EACjH,OAAOJ,UAAU,IAAI,CAACH,gBAAgB,CAACR,OAAO,CAAC;AACjD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGAvB,OAAO,CAACU,QAAQ,GAAGA,QAAQ;AAE3B,SAASR,yBAAyBA,CAACqC,SAAS,EAAE;EAC5C,IAAIC,IAAI,GAAGC,SAAS,CAACL,MAAM,GAAG,CAAC,IAAIK,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IAC7EE,cAAc,GAAGH,IAAI,CAACG,cAAc;EAExC,IAAIC,uBAAuB,GAAG,CAACD,cAAc,GAAGxB,iBAAiB,GAAGC,6BAA6B,EAAEyB,IAAI,CAAC,IAAI,CAAC;EAC7G,IAAIC,KAAK,GAAGP,SAAS,CAACQ,gBAAgB,CAACH,uBAAuB,CAAC;EAC/D,IAAII,aAAa,GAAG,CAAC,CAAC,EAAEjC,OAAO,CAAC,SAAS,CAAC,EAAE+B,KAAK,EAAE,UAAUG,EAAE,EAAE;IAC/D,IAAIC,eAAe,GAAGP,cAAc,IAAIM,EAAE,CAACE,QAAQ,IAAI,CAAC;IACxD,OAAO,CAACzC,QAAQ,CAACuC,EAAE,CAAC,IAAIC,eAAe,IAAID,EAAE,KAAKG,QAAQ,CAACC,aAAa;EAC1E,CAAC,CAAC;EACF,IAAIC,eAAe,GAAGN,aAAa,CAACO,MAAM,CAAC,UAAUC,WAAW,EAAEC,cAAc,EAAE;IAChF,IAAIC,WAAW,GAAGF,WAAW,CAACA,WAAW,CAACpB,MAAM,GAAG,CAAC,CAAC;IACrD,IAAIuB,kBAAkB,GAAG,CAACD,WAAW,KAAK,IAAI,IAAIA,WAAW,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,WAAW,CAACE,YAAY,CAAC,MAAM,CAAC,MAAM,OAAO;IACjI,IAAIC,kBAAkB,GAAGJ,cAAc,CAACG,YAAY,CAAC,MAAM,CAAC,KAAK,OAAO;IACxE,IAAIE,cAAc,GAAGL,cAAc,CAACG,YAAY,CAAC,MAAM,CAAC,MAAMF,WAAW,KAAK,IAAI,IAAIA,WAAW,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,WAAW,CAACE,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;;IAE3J,IAAID,kBAAkB,IAAIE,kBAAkB,IAAIC,cAAc,EAAE;MAC9D,IAAIL,cAAc,CAACM,OAAO,EAAE;QAC1B;QACAP,WAAW,CAACQ,GAAG,CAAC,CAAC;QACjBR,WAAW,CAACS,IAAI,CAACR,cAAc,CAAC;MAClC;IACF,CAAC,MAAM;MACLD,WAAW,CAACS,IAAI,CAACR,cAAc,CAAC;IAClC;IAEA,OAAOD,WAAW;EACpB,CAAC,EAAE,EAAE,CAAC;EACN,OAAO,CAAC,CAAC,EAAExC,OAAO,CAAC,SAAS,CAAC,EAAEsC,eAAe,EAAE,UAAUL,EAAE,EAAE;IAC5D,IAAIA,EAAE,CAACE,QAAQ,GAAG,CAAC,EAAE;MACnB,OAAO,CAAC,CAAC,GAAGF,EAAE,CAACE,QAAQ;IACzB;IAEA,OAAO,CAAC;EACV,CAAC,CAAC;AACJ;AAEA,SAAShD,QAAQA,CAAC+D,KAAK,EAAE;EACvB,OAAO,EAAE,CAAC,CAAC,EAAEvD,SAAS,CAACwD,OAAO,EAAED,KAAK,CAAC,KAAK,KAAK,IAAIA,KAAK,CAACE,OAAO,IAAIF,KAAK,CAACG,MAAM,IAAIH,KAAK,CAACI,UAAU,CAAC;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,SAASlE,SAASA,CAACmC,SAAS,EAAE2B,KAAK,EAAE;EACnC;EACA,IAAI,CAAC3B,SAAS,CAACgC,QAAQ,CAACnB,QAAQ,CAACC,aAAa,CAAC,EAAE;IAC/C,OAAO,IAAI;EACb,CAAC,CAAC;;EAGF,IAAI,CAAClD,QAAQ,CAAC+D,KAAK,CAAC,EAAE;IACpB,OAAO,IAAI;EACb;EAEA,IAAIM,gBAAgB,GAAGtE,yBAAyB,CAACqC,SAAS,CAAC;EAE3D,IAAIiC,gBAAgB,CAACpC,MAAM,KAAK,CAAC,EAAE;IACjC;IACA,IAAIgB,QAAQ,CAACC,aAAa,KAAKd,SAAS,EAAE;MACxC2B,KAAK,CAACO,cAAc,CAAC,CAAC;MACtB,OAAOlC,SAAS;IAClB;IAEA,OAAO,IAAI;EACb,CAAC,CAAC;;EAGF,IAAIkB,cAAc,GAAGS,KAAK,IAAIA,KAAK,CAACQ,MAAM,IAAInC,SAAS,CAACoC,aAAa,CAAC,QAAQ,CAAC;EAC/E,IAAIC,YAAY,GAAGJ,gBAAgB,CAACK,OAAO,CAACpB,cAAc,CAAC;EAE3D,IAAImB,YAAY,KAAK,CAAC,CAAC,EAAE;IACvBA,YAAY,GAAGV,KAAK,CAACY,QAAQ,GAAG,CAAC,GAAGN,gBAAgB,CAACpC,MAAM,GAAG,CAAC;EACjE,CAAC,CAAC;;EAGF,IAAI8B,KAAK,CAACY,QAAQ,EAAE;IAClBN,gBAAgB,CAACO,OAAO,CAACP,gBAAgB,CAACR,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;EACpD,CAAC,MAAM;IACLQ,gBAAgB,CAACP,IAAI,CAACO,gBAAgB,CAACQ,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;EACnD,CAAC,CAAC;;EAGFd,KAAK,CAACO,cAAc,CAAC,CAAC;EACtBD,gBAAgB,CAACI,YAAY,CAAC,CAACK,KAAK,CAAC,CAAC;EACtC,OAAOT,gBAAgB,CAACI,YAAY,CAAC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,SAASvE,SAASA,CAACkC,SAAS,EAAE;EAC5B,IAAI2C,cAAc,GAAGzC,SAAS,CAACL,MAAM,GAAG,CAAC,IAAIK,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAG,OAAO;EAChG,IAAIgB,cAAc,GAAGlB,SAAS,CAACoC,aAAa,CAAC,QAAQ,CAAC;EAEtD,IAAIlB,cAAc,EAAE;IAClB,OAAOA,cAAc;EACvB;EAEA,IAAIyB,cAAc,KAAK,OAAO,EAAE;IAC9B,IAAIC,QAAQ,GAAGjF,yBAAyB,CAACqC,SAAS,CAAC,CAAC,CAAC,CAAC;IAEtD,IAAI4C,QAAQ,EAAE;MACZ,CAAC,CAAC,EAAEtE,MAAM,CAAC,SAAS,CAAC,EAAE,YAAY;QACjC,OAAOsE,QAAQ,CAACF,KAAK,CAAC,CAAC;MACzB,CAAC,CAAC;MACF,OAAOE,QAAQ;IACjB;EACF;EAEA,IAAI5C,SAAS,CAACT,YAAY,CAAC,UAAU,CAAC,EAAE;IACtC,CAAC,CAAC,EAAEjB,MAAM,CAAC,SAAS,CAAC,EAAE,YAAY;MACjC,OAAO0B,SAAS,CAAC0C,KAAK,CAAC,CAAC;IAC1B,CAAC,CAAC;IACF,OAAO1C,SAAS;EAClB;EAEA,OAAO,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;;AAGA,IAAI6C,kBAAkB,GAAGtF,MAAM,CAACuF,MAAM,CAAC;EACrCC,IAAI,EAAE,MAAM;EACZC,IAAI,EAAE,MAAM;EACZC,QAAQ,EAAE;AACZ,CAAC,CAAC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI/E,cAAc,GAAG,SAASA,cAAcA,CAACgF,KAAK,EAAE;EAClD,IAAIC,WAAW,GAAGD,KAAK,CAACC,WAAW;IAC/Bd,YAAY,GAAGa,KAAK,CAACb,YAAY;IACjCe,SAAS,GAAGF,KAAK,CAACE,SAAS;IAC3BC,UAAU,GAAGH,KAAK,CAACG,UAAU;;EAEjC;EACA,IAAID,SAAS,KAAKP,kBAAkB,CAACE,IAAI,IAAI,CAAC,CAACF,kBAAkB,CAACE,IAAI,EAAEF,kBAAkB,CAACG,IAAI,EAAEH,kBAAkB,CAACI,QAAQ,CAAC,CAACK,QAAQ,CAACF,SAAS,CAAC,EAAE;IACjJ,OAAOf,YAAY,CAAC,CAAC;EACvB;EAEA,IAAIkB,SAAS,GAAGH,SAAS,KAAKP,kBAAkB,CAACG,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;EAE9D,IAAI,CAACK,UAAU,EAAE;IACf,IAAIG,QAAQ,GAAGnB,YAAY,GAAGkB,SAAS;IAEvC,IAAIC,QAAQ,IAAIL,WAAW,IAAIK,QAAQ,GAAG,CAAC,EAAE;MAC3C,OAAOnB,YAAY;IACrB;IAEA,OAAOmB,QAAQ;EACjB;EAEA,OAAO,CAACnB,YAAY,GAAGkB,SAAS,GAAGJ,WAAW,IAAIA,WAAW;AAC/D,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA1F,OAAO,CAACS,cAAc,GAAGA,cAAc;AAEvC,IAAID,WAAW,GAAG,SAASA,WAAWA,CAACwF,OAAO,EAAEN,WAAW,EAAEd,YAAY,EAAEqB,KAAK,EAAE;EAChF,IAAIL,UAAU,GAAGK,KAAK,CAACL,UAAU;IAC7BM,WAAW,GAAGD,KAAK,CAACC,WAAW;IAC/BC,SAAS,GAAGF,KAAK,CAACE,SAAS;IAC3BC,aAAa,GAAGH,KAAK,CAACG,aAAa;;EAEvC;EACA,IAAIxB,YAAY,GAAG,CAAC,IAAIA,YAAY,IAAIc,WAAW,EAAE;IACnD,OAAO,CAAC;EACV;EAEA,IAAIM,OAAO,KAAK,MAAM,EAAE;IACtB,OAAOI,aAAa,GAAG,CAAC,GAAG,CAAC,CAAC;EAC/B;EAEA,IAAIJ,OAAO,KAAK,KAAK,EAAE;IACrB,OAAOI,aAAa,GAAGV,WAAW,GAAG,CAAC,GAAG,CAAC,CAAC;EAC7C;EAEA,IAAIC,SAAS,GAAGP,kBAAkB,CAACE,IAAI;EAEvC,IAAIY,WAAW,KAAK,YAAY,EAAE;IAChC,IAAIF,OAAO,KAAK,MAAM,EAAE;MACtBL,SAAS,GAAGP,kBAAkB,CAACI,QAAQ;IACzC;IAEA,IAAIQ,OAAO,KAAK,OAAO,EAAE;MACvBL,SAAS,GAAGP,kBAAkB,CAACG,IAAI;IACrC;EACF,CAAC,MAAM,IAAIW,WAAW,KAAK,UAAU,EAAE;IACrC,IAAIF,OAAO,KAAK,IAAI,EAAE;MACpBL,SAAS,GAAGP,kBAAkB,CAACI,QAAQ;IACzC;IAEA,IAAIQ,OAAO,KAAK,MAAM,EAAE;MACtBL,SAAS,GAAGP,kBAAkB,CAACG,IAAI;IACrC;EACF;EAEA,IAAIY,SAAS,EAAE;IACb,IAAIH,OAAO,KAAK,UAAU,EAAE;MAC1BL,SAAS,GAAGP,kBAAkB,CAACI,QAAQ;IACzC;IAEA,IAAIQ,OAAO,KAAK,KAAK,EAAE;MACrBL,SAAS,GAAGP,kBAAkB,CAACG,IAAI;IACrC;EACF;EAEA,IAAII,SAAS,KAAKP,kBAAkB,CAACE,IAAI,EAAE;IACzC,OAAO7E,cAAc,CAAC;MACpBiF,WAAW,EAAEA,WAAW;MACxBd,YAAY,EAAEA,YAAY;MAC1Be,SAAS,EAAEA,SAAS;MACpBC,UAAU,EAAEA;IACd,CAAC,CAAC;EACJ;EAEA,OAAO,CAAC,CAAC;AACX,CAAC;AACD;AACA;AACA;;AAGA5F,OAAO,CAACQ,WAAW,GAAGA,WAAW;AAEjC,IAAID,cAAc,GAAG,SAASA,cAAcA,CAAC8F,WAAW,EAAEC,WAAW,EAAE;EACrEA,WAAW,CAACC,OAAO,CAAC,UAAUtD,EAAE,EAAEuD,KAAK,EAAE;IACvC,OAAOvD,EAAE,CAACwD,YAAY,CAAC,UAAU,EAAED,KAAK,KAAKH,WAAW,GAAG,GAAG,GAAG,IAAI,CAAC;EACxE,CAAC,CAAC;AACJ,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGArG,OAAO,CAACO,cAAc,GAAGA,cAAc;AAEvC,SAASD,WAAWA,CAACoG,GAAG,EAAEJ,WAAW,EAAE1B,YAAY,EAAE;EACnD,IAAI+B,KAAK,GAAGlE,SAAS,CAACL,MAAM,GAAG,CAAC,IAAIK,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IAC9EmE,gBAAgB,GAAGD,KAAK,CAACf,UAAU;IACnCA,UAAU,GAAGgB,gBAAgB,KAAK,KAAK,CAAC,GAAG,KAAK,GAAGA,gBAAgB;IACnEC,iBAAiB,GAAGF,KAAK,CAACT,WAAW;IACrCA,WAAW,GAAGW,iBAAiB,KAAK,KAAK,CAAC,GAAG,YAAY,GAAGA,iBAAiB;IAC7EC,eAAe,GAAGH,KAAK,CAACR,SAAS;IACjCA,SAAS,GAAGW,eAAe,KAAK,KAAK,CAAC,GAAG,KAAK,GAAGA,eAAe;IAChEC,mBAAmB,GAAGJ,KAAK,CAACP,aAAa;IACzCA,aAAa,GAAGW,mBAAmB,KAAK,KAAK,CAAC,GAAG,IAAI,GAAGA,mBAAmB;EAE/E,IAAIrB,WAAW,GAAGY,WAAW,CAAClE,MAAM,CAAC,CAAC;EACtC;;EAEA,IAAI,CAAC+D,SAAS,IAAIO,GAAG,KAAK,KAAK,EAAE;IAC/BnG,cAAc,CAAC,CAAC,EAAE+F,WAAW,CAAC;IAC9B;EACF;EAEA,IAAIP,QAAQ,GAAGvF,WAAW,CAACkG,GAAG,EAAEhB,WAAW,EAAEd,YAAY,EAAE;IACzDgB,UAAU,EAAEA,UAAU;IACtBM,WAAW,EAAEA,WAAW;IACxBC,SAAS,EAAEA,SAAS;IACpBC,aAAa,EAAEA;EACjB,CAAC,CAAC;EAEF,IAAIL,QAAQ,IAAI,CAAC,IAAIA,QAAQ,GAAGL,WAAW,EAAE;IAC3C,IAAIsB,qBAAqB,EAAEC,sBAAsB;IAEjD1G,cAAc,CAACwF,QAAQ,EAAEO,WAAW,CAAC;IACrC,CAACU,qBAAqB,GAAG,CAACC,sBAAsB,GAAGX,WAAW,CAACP,QAAQ,CAAC,EAAEd,KAAK,MAAM,IAAI,IAAI+B,qBAAqB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,qBAAqB,CAACE,IAAI,CAACD,sBAAsB,CAAC;EAC7L,CAAC,CAAC;EACF;;EAGA,IAAIlB,QAAQ,KAAK,CAAC,CAAC,IAAI,CAACI,SAAS,IAAIO,GAAG,KAAK,UAAU,EAAE;IACvDnG,cAAc,CAACqE,YAAY,EAAE0B,WAAW,CAAC;EAC3C;AACF","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}