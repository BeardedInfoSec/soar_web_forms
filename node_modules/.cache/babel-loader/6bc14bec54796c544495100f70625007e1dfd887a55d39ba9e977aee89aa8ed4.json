{"ast":null,"code":"function n(n, r, t) {\n  return {\n    r: 255 * t(n.r / 255, r.r / 255),\n    g: 255 * t(n.g / 255, r.g / 255),\n    b: 255 * t(n.b / 255, r.b / 255)\n  };\n}\nfunction r(n, r) {\n  return r;\n}\nfunction t(n, r) {\n  return n * r;\n}\nfunction u(n, r) {\n  return n + r - n * r;\n}\nfunction o(n, r) {\n  return f(r, n);\n}\nfunction i(n, r) {\n  return Math.min(n, r);\n}\nfunction a(n, r) {\n  return Math.min(Math.max(n, r), 1);\n}\nfunction e(n, r) {\n  return 0 === n ? 0 : 1 === r ? 1 : Math.min(1, n / (1 - r));\n}\nfunction c(n, r) {\n  return 1 === n ? 1 : 0 === r ? 0 : 1 - Math.min(1, (1 - n) / r);\n}\nfunction f(n, r) {\n  return r <= .5 ? t(n, 2 * r) : u(n, 2 * r - 1);\n}\nfunction g(n, r) {\n  return r <= .5 ? n - (1 - 2 * r) * n * (1 - n) : n + (2 * r - 1) * ((n <= .25 ? ((16 * n - 12) * n + 4) * n : Math.sqrt(n)) - n);\n}\nfunction b(n, r) {\n  return Math.abs(n - r);\n}\nfunction s(n, r) {\n  return n + r - 2 * n * r;\n}\nfunction h(n, r, t) {\n  return Math.min(Math.max(n, r), t);\n}\nfunction M(n) {\n  return {\n    r: h(n.r, 0, 255),\n    g: h(n.g, 0, 255),\n    b: h(n.b, 0, 255),\n    a: h(n.a, 0, 1)\n  };\n}\nfunction m(n) {\n  return {\n    r: 255 * n.r,\n    g: 255 * n.g,\n    b: 255 * n.b,\n    a: n.a\n  };\n}\nfunction d(n) {\n  return {\n    r: n.r / 255,\n    g: n.g / 255,\n    b: n.b / 255,\n    a: n.a\n  };\n}\nfunction l(n, r) {\n  void 0 === r && (r = 0);\n  var t = Math.pow(10, r);\n  return {\n    r: Math.round(n.r * t) / t,\n    g: Math.round(n.g * t) / t,\n    b: Math.round(n.b * t) / t,\n    a: n.a\n  };\n}\nfunction p(n, r, t, u, o, i) {\n  return (1 - r / t) * u + r / t * Math.round((1 - n) * o + n * i);\n}\nfunction v(n, r, t, u, o) {\n  void 0 === o && (o = {\n    unitInput: !1,\n    unitOutput: !1,\n    roundOutput: !0\n  }), o.unitInput && (n = m(n), r = m(r)), n = M(n);\n  var i = (r = M(r)).a + n.a - r.a * n.a,\n    a = t(n, r, u),\n    e = M({\n      r: p(n.a, r.a, i, n.r, r.r, a.r),\n      g: p(n.a, r.a, i, n.g, r.g, a.g),\n      b: p(n.a, r.a, i, n.b, r.b, a.b),\n      a: i\n    });\n  return o.unitOutput ? d(e) : o.roundOutput ? l(e) : l(e, 9);\n}\nfunction x(n, r, t) {\n  return m(t(d(n), d(r)));\n}\nfunction O(n) {\n  return .3 * n.r + .59 * n.g + .11 * n.b;\n}\nfunction y(n, r) {\n  var t = r - O(n);\n  return function (n) {\n    var r = O(n),\n      t = n.r,\n      u = n.g,\n      o = n.b,\n      i = Math.min(t, u, o),\n      a = Math.max(t, u, o);\n    function e(n) {\n      return r + (n - r) * r / (r - i);\n    }\n    function c(n) {\n      return r + (n - r) * (1 - r) / (a - r);\n    }\n    return i < 0 && (t = e(t), u = e(u), o = e(o)), a > 1 && (t = c(t), u = c(u), o = c(o)), {\n      r: t,\n      g: u,\n      b: o\n    };\n  }({\n    r: n.r + t,\n    g: n.g + t,\n    b: n.b + t\n  });\n}\nfunction I(n) {\n  return Math.max(n.r, n.g, n.b) - Math.min(n.r, n.g, n.b);\n}\nfunction L(n, r) {\n  var t = [\"r\", \"g\", \"b\"].sort(function (r, t) {\n      return n[r] - n[t];\n    }),\n    u = t[0],\n    o = t[1],\n    i = t[2],\n    a = {\n      r: n.r,\n      g: n.g,\n      b: n.b\n    };\n  return a[i] > a[u] ? (a[o] = (a[o] - a[u]) * r / (a[i] - a[u]), a[i] = r) : a[o] = a[i] = 0, a[u] = 0, a;\n}\nfunction k(n, r) {\n  return y(L(r, I(n)), O(n));\n}\nfunction q(n, r) {\n  return y(L(n, I(r)), O(n));\n}\nfunction w(n, r) {\n  return y(r, O(n));\n}\nfunction B(n, r) {\n  return y(n, O(r));\n}\nfunction D(t, u) {\n  return v(t, u, n, r);\n}\nfunction j(r, u) {\n  return v(r, u, n, t);\n}\nfunction z(r, t) {\n  return v(r, t, n, u);\n}\nfunction A(r, t) {\n  return v(r, t, n, o);\n}\nfunction C(r, t) {\n  return v(r, t, n, i);\n}\nfunction E(r, t) {\n  return v(r, t, n, a);\n}\nfunction F(r, t) {\n  return v(r, t, n, e);\n}\nfunction G(r, t) {\n  return v(r, t, n, c);\n}\nfunction H(r, t) {\n  return v(r, t, n, f);\n}\nfunction J(r, t) {\n  return v(r, t, n, g);\n}\nfunction K(r, t) {\n  return v(r, t, n, b);\n}\nfunction N(r, t) {\n  return v(r, t, n, s);\n}\nfunction P(n, r) {\n  return v(n, r, x, k);\n}\nfunction Q(n, r) {\n  return v(n, r, x, q);\n}\nfunction R(n, r) {\n  return v(n, r, x, w);\n}\nfunction S(n, r) {\n  return v(n, r, x, B);\n}\nexport { D as normal, j as multiply, z as screen, A as overlay, C as darken, E as lighten, F as colorDodge, G as colorBurn, H as hardLight, J as softLight, K as difference, N as exclusion, P as hue, Q as saturation, R as color, S as luminosity };","map":{"version":3,"names":["n","r","t","g","b","u","o","f","i","Math","min","a","max","e","c","sqrt","abs","s","h","M","m","d","l","pow","round","p","v","unitInput","unitOutput","roundOutput","x","O","y","I","L","sort","k","q","w","B","D","j","z","A","C","E","F","G","H","J","K","N","P","Q","R","S","normal","multiply","screen","overlay","darken","lighten","colorDodge","colorBurn","hardLight","softLight","difference","exclusion","hue","saturation","color","luminosity"],"sources":["C:\\Users\\abarbas\\Desktop\\soar_web_forms\\node_modules\\color-blend\\src\\separable-blend.ts","C:\\Users\\abarbas\\Desktop\\soar_web_forms\\node_modules\\color-blend\\src\\separable-modes.ts","C:\\Users\\abarbas\\Desktop\\soar_web_forms\\node_modules\\color-blend\\src\\helpers.ts","C:\\Users\\abarbas\\Desktop\\soar_web_forms\\node_modules\\color-blend\\src\\non-separable-blend.ts","C:\\Users\\abarbas\\Desktop\\soar_web_forms\\node_modules\\color-blend\\src\\non-separable-modes.ts","C:\\Users\\abarbas\\Desktop\\soar_web_forms\\node_modules\\color-blend\\src\\index.ts"],"sourcesContent":["import { ChannelBlender, RGB, RGBA } from './types'\n\n/**\n * Blend two colors in a separable way (i.e. each color channel individually)\n *\n * @param backdrop The RGBA backdrop color\n * @param source   The RGBA source color\n * @param callback The blend mode callback to apply\n */\nexport default function separableBlend(\n  backdrop: RGBA,\n  source: RGBA,\n  callback: ChannelBlender\n): RGB {\n  return {\n    r: callback(backdrop.r / 255, source.r / 255) * 255,\n    g: callback(backdrop.g / 255, source.g / 255) * 255,\n    b: callback(backdrop.b / 255, source.b / 255) * 255\n  }\n}\n","/**\n * Algorithms for separable blend modes (i.e. where the same algorithms is applied to each color channel)\n * @see https://www.w3.org/TR/compositing-1/#blendingseparable\n */\n\n/**\n * Blend two color channels with the \"normal\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\n// @ts-ignore the unused first parameter to comply with the interface\nexport function normal(backdrop: number, source: number) {\n  return source\n}\n\n/**\n * Blend two color channels with the \"multiply\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function multiply(backdrop: number, source: number) {\n  return backdrop * source\n}\n\n/**\n * Blend two color channels with the \"screen\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function screen(backdrop: number, source: number) {\n  return backdrop + source - backdrop * source\n}\n\n/**\n * Blend two color channels with the \"overlay\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function overlay(backdrop: number, source: number) {\n  return hardLight(source, backdrop)\n}\n\n/**\n * Blend two color channels with the \"darken\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function darken(backdrop: number, source: number) {\n  return Math.min(backdrop, source)\n}\n\n/**\n * Blend two color channels with the \"lighten\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function lighten(backdrop: number, source: number) {\n  return Math.min(Math.max(backdrop, source), 1)\n}\n\n/**\n * Blend two color channels with the \"color dodge\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function colorDodge(backdrop: number, source: number) {\n  return backdrop === 0\n    ? 0\n    : source === 1\n    ? 1\n    : Math.min(1, backdrop / (1 - source))\n}\n\n/**\n * Blend two color channels with the \"color burn\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function colorBurn(backdrop: number, source: number) {\n  return backdrop === 1\n    ? 1\n    : source === 0\n    ? 0\n    : 1 - Math.min(1, (1 - backdrop) / source)\n}\n\n/**\n * Blend two color channels with the \"hard light\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function hardLight(backdrop: number, source: number) {\n  return source <= 0.5\n    ? multiply(backdrop, 2 * source)\n    : screen(backdrop, 2 * source - 1)\n}\n\n/**\n * Blend two color channels with the \"soft light\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function softLight(backdrop: number, source: number) {\n  return source <= 0.5\n    ? backdrop - (1 - 2 * source) * backdrop * (1 - backdrop)\n    : backdrop +\n        (2 * source - 1) *\n          ((backdrop <= 0.25\n            ? ((16 * backdrop - 12) * backdrop + 4) * backdrop\n            : Math.sqrt(backdrop)) -\n            backdrop)\n}\n\n/**\n * Blend two color channels with the \"difference\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function difference(backdrop: number, source: number) {\n  return Math.abs(backdrop - source)\n}\n\n/**\n * Blend two color channels with the \"exclusion\" blend mode\n *\n * @param backdrop The background color channel as an integer from 0 to 255\n * @param source   The foreground color channel as an integer from 0 to 255\n * @return The blended channel value\n */\nexport function exclusion(backdrop: number, source: number) {\n  return backdrop + source - 2 * backdrop * source\n}\n","import { ChannelBlender, NoAlphaBlender, RGB, RGBA } from './types'\n\n// Some utility (no actual blend-related algorithms) for color handling\n\n/**\n * Restricts a number to given boundaries\n * @param value The number to restrict\n * @param from  The lower boundary\n * @param to    The upper boundary\n * @return The restricted value\n */\nfunction restrictNumber(value: number, from: number, to: number) {\n  return Math.min(Math.max(value, from), to)\n}\n\n/**\n * Restricts an { r,g,b,a } color to its boundaries (0..255 color channels, 0..1 alpha channel)\n * @param color The { r,g,b,a } color to restrict\n * @return The restricted color\n */\nfunction restrictColor(color: RGBA): RGBA {\n  return {\n    r: restrictNumber(color.r, 0, 255),\n    g: restrictNumber(color.g, 0, 255),\n    b: restrictNumber(color.b, 0, 255),\n    a: restrictNumber(color.a, 0, 1)\n  }\n}\n\n/**\n * Converts a color from unit color channels [0..1] to 8-bit color channels [0..255]\n * @param color The { r,g,b,a } color to convert\n * @return The { r,g,b,a } with 8-bit color channels\n */\nexport function convertFromUnit(color: RGBA): RGBA\nexport function convertFromUnit(color: RGB): RGB\nexport function convertFromUnit(color: any): RGB | RGBA {\n  return {\n    r: color.r * 255,\n    g: color.g * 255,\n    b: color.b * 255,\n    a: color.a\n  }\n}\n\n/**\n * Converts a color from 8-bit color channels [0..255] to unit color channels [0..1]\n * @param color The { r,g,b,a } color to convert\n * @return The { r,g,b,a } with unit color channels\n */\nexport function convertToUnit(color: RGBA): RGBA\nexport function convertToUnit(color: RGB): RGB\nexport function convertToUnit(color: any): RGB | RGBA {\n  return {\n    r: color.r / 255,\n    g: color.g / 255,\n    b: color.b / 255,\n    a: color.a\n  }\n}\n\n/**\n * Rounds the color channels of an RGBA color\n * @param color     The { r,g,b,a } color to handle\n * @param precision How many decimals? Defaults to 0\n * @return The { r,g,b,a } with rounded color channels\n */\nfunction roundChannels(color: RGBA, precision?: number): RGBA\nfunction roundChannels(color: RGB, precision?: number): RGB\nfunction roundChannels(color: any, precision: number = 0): RGB | RGBA {\n  const multiplier = Math.pow(10, precision)\n\n  return {\n    r: Math.round(color.r * multiplier) / multiplier,\n    g: Math.round(color.g * multiplier) / multiplier,\n    b: Math.round(color.b * multiplier) / multiplier,\n    a: color.a\n  }\n}\n\n/**\n * Rounds the color channels of an RGBA color with high precision to aviod IEEE 754 related issues\n * @param color The { r,g,b,a } color to handle\n * @return The { r,g,b,a } with rounded color channels\n */\nfunction roundChannelsBinaryFloat(color: RGBA): RGBA {\n  return roundChannels(color, 9)\n}\n\n/**\n * Applies the appropriate alpha blending to a blend process.\n * @see https://www.w3.org/TR/compositing-1/#blending\n * @param backdropAlpha  The alpha channel of the backdrop color [0..1]\n * @param sourceAlpha    The alpha channel of the source color [0..1]\n * @param compositeAlpha The alpha channel of the composite color [0..1]\n * @param backdropColor  A color channel (R, G or B) of the backdrop color [0..255]\n * @param sourceColor    A color channel (R, G or B) of the source color [0..255]\n * @param compositeColor A color channel (R, G or B) of the composite color [0..255]\n * @return The resulting color channel\n */\nfunction alphaCompose(\n  backdropAlpha: number,\n  sourceAlpha: number,\n  compositeAlpha: number,\n  backdropColor: number,\n  sourceColor: number,\n  compositeColor: number\n) {\n  return (\n    (1 - sourceAlpha / compositeAlpha) * backdropColor +\n    (sourceAlpha / compositeAlpha) *\n      Math.round(\n        (1 - backdropAlpha) * sourceColor + backdropAlpha * compositeColor\n      )\n  )\n}\n\nexport interface BlendOptions {\n  unitInput: boolean\n  unitOutput: boolean\n  roundOutput: boolean\n}\n\n/**\n * Blend two colors\n * All RGBA objects are { r,g,b,a } with [0..255] for RGB and [0..1] for alpha\n * @param source               The { r,g,b,a } color to be put on top\n * @param backdrop             The { r,g,b,a } color to be put below the source\n * @param abstractModeCallback The abstract blend mode function (separable vs. non-separable)\n * @param concreteModeCallback The concrete blend mode function (normal, multiply, ...)\n * @param options              The options to apply\n * @return The { r,g,b,a } result object, channel values are not rounded\n */\nexport function performBlend(\n  backdrop: RGBA,\n  source: RGBA,\n  abstractModeCallback: (\n    backdrop: RGBA,\n    source: RGBA,\n    concreteModeCallback: ChannelBlender\n  ) => RGB,\n  concreteModeCallback: ChannelBlender,\n  options?: Partial<BlendOptions>\n): RGBA\nexport function performBlend(\n  backdrop: RGBA,\n  source: RGBA,\n  abstractModeCallback: (\n    backdrop: RGBA,\n    source: RGBA,\n    concreteModeCallback: NoAlphaBlender\n  ) => RGB,\n  concreteModeCallback: NoAlphaBlender,\n  options?: Partial<BlendOptions>\n): RGBA\nexport function performBlend(\n  backdrop: RGBA,\n  source: RGBA,\n  abstractModeCallback: (\n    backdrop: RGBA,\n    source: RGBA,\n    concreteModeCallback: any\n  ) => RGB,\n  concreteModeCallback: ChannelBlender | NoAlphaBlender,\n  options: Partial<BlendOptions> = {\n    unitInput: false,\n    unitOutput: false,\n    roundOutput: true\n  }\n) {\n  // Handle unit input if needed\n  if (options.unitInput) {\n    backdrop = convertFromUnit(backdrop)\n    source = convertFromUnit(source)\n  }\n\n  // Remove out-of-bounds values\n  backdrop = restrictColor(backdrop)\n  source = restrictColor(source)\n\n  // Calculate resulting alpha\n  const a = source.a + backdrop.a - source.a * backdrop.a\n\n  // Calculate resulting RGB\n  const resultRGB = abstractModeCallback(backdrop, source, concreteModeCallback)\n\n  // Calculate actual RGBs from backdrop, source and result + alpha values\n  // Since blending may result in out-of-bounds color channels, cut those\n  let resultRGBA = restrictColor({\n    r: alphaCompose(backdrop.a, source.a, a, backdrop.r, source.r, resultRGB.r),\n    g: alphaCompose(backdrop.a, source.a, a, backdrop.g, source.g, resultRGB.g),\n    b: alphaCompose(backdrop.a, source.a, a, backdrop.b, source.b, resultRGB.b),\n    a: a\n  })\n\n  // Convert color channels to unit values if needed\n  if (options.unitOutput) {\n    resultRGBA = convertToUnit(resultRGBA)\n\n    // Round 8-bit color channels if needed\n  } else if (options.roundOutput) {\n    resultRGBA = roundChannels(resultRGBA)\n\n    // Round anyways to get rid of JavaScript floating point issues\n  } else {\n    resultRGBA = roundChannelsBinaryFloat(resultRGBA)\n  }\n\n  return resultRGBA\n}\n","import { convertFromUnit, convertToUnit } from './helpers'\nimport { NoAlphaBlender, RGBA } from './types'\n\n/**\n * Blend two colors in a non-separable way\n *\n * @param backdrop The background color as an { r,g,b,a } object\n * @param source   The foreground color as an { r,g,b,a } object\n * @param callback The blend mode callback to apply\n */\nexport default function nonSeparableBlend(\n  backdrop: RGBA,\n  source: RGBA,\n  callback: NoAlphaBlender\n) {\n  return convertFromUnit(\n    callback(convertToUnit(backdrop), convertToUnit(source))\n  )\n}\n","/**\n * Algorithms for non-separable blend modes (based on HSV/HSL color space)\n * @see https://www.w3.org/TR/compositing-1/#blendingnonseparable\n */\n\nimport { RGB } from './types'\n\n/**\n * Get the luminosity of a color\n *\n * @param rgb The color as an { r,g,b } object with each channel as a fraction\n */\nfunction getLuminosity(rgb: RGB) {\n  return 0.3 * rgb.r + 0.59 * rgb.g + 0.11 * rgb.b\n}\n\n/**\n * Clip the channels of a color\n *\n * @param rgb The color as an { r,g,b } object with each channel as a fraction\n */\nfunction clipColor(rgb: RGB): RGB {\n  const luminosity = getLuminosity(rgb)\n  let { r, g, b } = rgb\n\n  const lowestChannel = Math.min(r, g, b)\n  const highestChannel = Math.max(r, g, b)\n\n  function clipLowest(channel: number) {\n    return (\n      luminosity +\n      ((channel - luminosity) * luminosity) / (luminosity - lowestChannel)\n    )\n  }\n\n  function clipHighest(channel: number) {\n    return (\n      luminosity +\n      ((channel - luminosity) * (1 - luminosity)) /\n        (highestChannel - luminosity)\n    )\n  }\n\n  if (lowestChannel < 0) {\n    r = clipLowest(r)\n    g = clipLowest(g)\n    b = clipLowest(b)\n  }\n\n  if (highestChannel > 1) {\n    r = clipHighest(r)\n    g = clipHighest(g)\n    b = clipHighest(b)\n  }\n\n  return { r, g, b }\n}\n\n/**\n * Set luminosity on a color\n *\n * @param rgb        The color as an { r,g,b } object with each channel as a fraction\n * @param luminosity The luminosity to apply\n */\nfunction setLuminosity(rgb: RGB, luminosity: number) {\n  const delta = luminosity - getLuminosity(rgb)\n\n  return clipColor({\n    r: rgb.r + delta,\n    g: rgb.g + delta,\n    b: rgb.b + delta\n  })\n}\n\n/**\n * Get the saturation of a color\n *\n * @param rgb The color as an { r,g,b } object with each channel as a fraction\n */\nfunction getSaturation(rgb: RGB) {\n  return Math.max(rgb.r, rgb.g, rgb.b) - Math.min(rgb.r, rgb.g, rgb.b)\n}\n\n/**\n * Set saturation on a color\n *\n * @param rgb        The color as an { r,g,b } object with each channel as a fraction\n * @param saturation The saturation to apply\n */\nfunction setSaturation(rgb: RGB, saturation: number) {\n  const sortedChannels = ['r', 'g', 'b'].sort(\n    (a, b) => rgb[a as keyof RGB] - rgb[b as keyof RGB]\n  ) as [keyof RGB, keyof RGB, keyof RGB]\n  const channelMin = sortedChannels[0]\n  const channelMid = sortedChannels[1]\n  const channelMax = sortedChannels[2]\n\n  const result = {\n    r: rgb.r,\n    g: rgb.g,\n    b: rgb.b\n  }\n\n  if (result[channelMax] > result[channelMin]) {\n    result[channelMid] =\n      ((result[channelMid] - result[channelMin]) * saturation) /\n      (result[channelMax] - result[channelMin])\n    result[channelMax] = saturation\n  } else {\n    result[channelMid] = result[channelMax] = 0\n  }\n\n  result[channelMin] = 0\n\n  return result\n}\n\n/**\n * Blend two colors with the \"hue\" blend mode\n *\n * @param backdrop The background color channel as an { r,g,b } object with each channel represented as a fraction\n * @param source   The foreground color channel as an { r,g,b } object with each channel represented as a fraction\n * @return The blended color\n */\nexport function hue(backdrop: RGB, source: RGB) {\n  return setLuminosity(\n    setSaturation(source, getSaturation(backdrop)),\n    getLuminosity(backdrop)\n  )\n}\n\n/**\n * Blend two colors with the \"saturation\" blend mode\n *\n * @param backdrop The background color channel as an { r,g,b } object with each channel represented as a fraction\n * @param source   The foreground color channel as an { r,g,b } object with each channel represented as a fraction\n * @return The blended color\n */\nexport function saturation(backdrop: RGB, source: RGB) {\n  return setLuminosity(\n    setSaturation(backdrop, getSaturation(source)),\n    getLuminosity(backdrop)\n  )\n}\n\n/**\n * Blend two colors with the \"color\" blend mode\n *\n * @param backdrop The background color channel as an { r,g,b } object with each channel represented as a fraction\n * @param source   The foreground color channel as an { r,g,b } object with each channel represented as a fraction\n * @return The blended color\n */\nexport function color(backdrop: RGB, source: RGB) {\n  return setLuminosity(source, getLuminosity(backdrop))\n}\n\n/**\n * Blend two colors with the \"luminosity\" blend mode\n *\n * @param backdrop The background color channel as an { r,g,b } object with each channel represented as a fraction\n * @param source   The foreground color channel as an { r,g,b } object with each channel represented as a fraction\n * @return The blended color\n */\nexport function luminosity(backdrop: RGB, source: RGB) {\n  return setLuminosity(backdrop, getLuminosity(source))\n}\n","import separableBlend from './separable-blend'\nimport * as separableBlendModes from './separable-modes'\n\nimport nonSeparableBlend from './non-separable-blend'\nimport * as nonSeparableBlendModes from './non-separable-modes'\n\nimport { performBlend } from './helpers'\nimport { RGBA } from './types'\n\n/**\n * Blend two colors with the \"normal\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function normal(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.normal\n  )\n}\n\n/**\n * Blend two colors with the \"multiply\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function multiply(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.multiply\n  )\n}\n\n/**\n * Blend two colors with the \"screen\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function screen(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.screen\n  )\n}\n\n/**\n * Blend two colors with the \"overlay\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function overlay(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.overlay\n  )\n}\n\n/**\n * Blend two colors with the \"darken\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function darken(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.darken\n  )\n}\n\n/**\n * Blend two colors with the \"lighten\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function lighten(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.lighten\n  )\n}\n\n/**\n * Blend two colors with the \"color dodge\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function colorDodge(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.colorDodge\n  )\n}\n\n/**\n * Blend two colors with the \"color burn\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function colorBurn(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.colorBurn\n  )\n}\n\n/**\n * Blend two colors with the \"hard light\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function hardLight(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.hardLight\n  )\n}\n\n/**\n * Blend two colors with the \"soft light\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function softLight(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.softLight\n  )\n}\n\n/**\n * Blend two colors with the \"difference\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function difference(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.difference\n  )\n}\n\n/**\n * Blend two colors with the \"exclusion\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function exclusion(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    separableBlend,\n    separableBlendModes.exclusion\n  )\n}\n\n/**\n * Blend two colors with the \"hue\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function hue(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    nonSeparableBlend,\n    nonSeparableBlendModes.hue\n  )\n}\n\n/**\n * Blend two colors with the \"saturation\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function saturation(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    nonSeparableBlend,\n    nonSeparableBlendModes.saturation\n  )\n}\n\n/**\n * Blend two colors with the \"color\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function color(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    nonSeparableBlend,\n    nonSeparableBlendModes.color\n  )\n}\n\n/**\n * Blend two colors with the \"luminosity\" blend mode\n *\n * @param backdrop The background color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @param source   The foreground color object { r,g,b,a } with the color channels being integers in the [0..255] range and the alpha channel being a fraction in [0..1]\n * @return The blended color\n */\nexport function luminosity(backdrop: RGBA, source: RGBA) {\n  return performBlend(\n    backdrop,\n    source,\n    nonSeparableBlend,\n    nonSeparableBlendModes.luminosity\n  )\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}