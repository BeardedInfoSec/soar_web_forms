"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSortedTabbableElements = getSortedTabbableElements;
exports.isTabKey = isTabKey;
exports.handleTab = handleTab;
exports.takeFocus = takeFocus;
exports.handleFocus = handleFocus;
exports.updateTabIndex = exports.getNewIndex = exports.calculateIndex = exports.isHidden = void 0;
var _defer = _interopRequireDefault(require("lodash/defer"));
var _filter = _interopRequireDefault(require("lodash/filter"));
var _sortBy = _interopRequireDefault(require("lodash/sortBy"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
/**
 * @file
 * Utilities for managing focus in the browser.
 */

var tabbableSelectors = ['a[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', '[contenteditable]'];
var tabbableSelectorsWithTabIndex = tabbableSelectors.concat(['[tabindex]']);
var isStyleVisible = function isStyleVisible(element) {
  var style = window.getComputedStyle(element);
  return style.display !== 'none' && style.visibility !== 'hidden';
};
var isAttributeVisible = function isAttributeVisible(element) {
  return !element.hasAttribute('hidden');
};
var isElementVisible = function isElementVisible(element) {
  var visibleByStyle = isStyleVisible(element);
  var visibleByAttribute = isAttributeVisible(element);
  return visibleByStyle && visibleByAttribute;
};

/**
 * Determines whether an element is considered hidden based on its dimensions or computed visibility style.
 *
 * This function is primarily used in environments where accurate layout-related properties
 * are available, like a real browser environment.
 *
 * @param {Element} element - The DOM element to check for visibility.
 * @returns {boolean} - Returns true if the element is hidden, otherwise false.
 *
 * @private Exported for testing purposes
 */
var isHidden = function isHidden(element) {
  // SUI-6521: `element.getClientRects().length > 0` is used to distinguish between 'actual' 0-size elements and Jest 0-size elements.
  // 'actual' 0-size elements typically still have a value from getClientRects.
  var isZeroSize = element.getClientRects().length > 0 && (element.offsetWidth === 0 || element.offsetHeight === 0);
  return isZeroSize || !isElementVisible(element);
};

/**
 * Sorts the tabbable elements in the provided container.
 *
 * @param {Element} container - The target container.
 * @param {Object} [options={ignoreTabIndex: false}] - Configuration options.
 * @param {boolean} [options.ignoreTabIndex=false] - If set to true, the function will neither use "tabindex" as an indicator of selectability nor disqualify elements based on "tabindex=-1".
 * @returns {Element[]} A sorted array of tabbable elements within the container.
 * @public
 */
exports.isHidden = isHidden;
function getSortedTabbableElements(container) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    ignoreTabIndex = _ref.ignoreTabIndex;
  var tabbableElementSelector = (ignoreTabIndex ? tabbableSelectors : tabbableSelectorsWithTabIndex).join(', ');
  var elems = container.querySelectorAll(tabbableElementSelector);
  var tabbableElems = (0, _filter["default"])(elems, function (el) {
    var isValidTabIndex = ignoreTabIndex || el.tabIndex >= 0;
    return !isHidden(el) && isValidTabIndex || el === document.activeElement;
  });
  var reducedElements = tabbableElems.reduce(function (accumulator, currentElement) {
    var prevElement = accumulator[accumulator.length - 1];
    var isPrevElementRadio = (prevElement === null || prevElement === void 0 ? void 0 : prevElement.getAttribute('type')) === 'radio';
    var isCurrElementRadio = currentElement.getAttribute('type') === 'radio';
    var sameRadioGroup = currentElement.getAttribute('name') === (prevElement === null || prevElement === void 0 ? void 0 : prevElement.getAttribute('name'));

    // Reduce radio elements to a single Tab stop, ensuring only one per group is focusable
    if (isPrevElementRadio && isCurrElementRadio && sameRadioGroup) {
      if (currentElement.checked) {
        // replace previous radio with current checked radio
        accumulator.pop();
        accumulator.push(currentElement);
      }
    } else {
      accumulator.push(currentElement);
    }
    return accumulator;
  }, []);
  return (0, _sortBy["default"])(reducedElements, function (el) {
    if (el.tabIndex > 0) {
      return -1 / el.tabIndex;
    }
    return 0;
  });
}
function isTabKey(event) {
  return !(event.key !== 'Tab' || event.metaKey || event.altKey || event.controlKey);
}

/**
 * A key event handler that moves focus among tabbable elements within a container.
 *
 * @param {Element} container - The target container.
 * @param {Event} event - The key event to handle.
 * @returns {Element|null} The element focus was applied to or `null` if focus was not applied.
 * @public
 */
function handleTab(container, event) {
  // Ignore events bubbling up from portals
  if (!container.contains(document.activeElement)) {
    return null;
  }

  // Ensure this is a valid event
  if (!isTabKey(event)) {
    return null;
  }
  var tabbableElements = getSortedTabbableElements(container);
  if (tabbableElements.length === 0) {
    // if the container is focused, don't allow the focus to leave.
    if (document.activeElement === container) {
      event.preventDefault();
      return container;
    }
    return null;
  }

  // Find the current index or set default.
  var currentElement = event && event.target || container.querySelector(':focus');
  var currentIndex = tabbableElements.indexOf(currentElement);
  if (currentIndex === -1) {
    currentIndex = event.shiftKey ? 0 : tabbableElements.length - 1;
  }

  // Shift the array instead of the current index.
  if (event.shiftKey) {
    tabbableElements.unshift(tabbableElements.pop()); // move last to first
  } else {
    tabbableElements.push(tabbableElements.shift()); // move first to last
  }

  // Focus
  event.preventDefault();
  tabbableElements[currentIndex].focus();
  return tabbableElements[currentIndex];
}

/**
 * A helper method that focuses on the first focusable element in a container.
 * If a contained element already has focus, focus does not shift.
 *
 * @param {Element} container - The container that takes focus.
 * @param {String} [defaultElement='first'] - The target of focus, either 'first' or 'container'.
 * @returns {Element|null} The element that was focused, or null if no element was focused.
 * @public
 */
function takeFocus(container) {
  var defaultElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'first';
  var currentElement = container.querySelector(':focus');
  if (currentElement) {
    return currentElement;
  }
  if (defaultElement === 'first') {
    var targetEl = getSortedTabbableElements(container)[0];
    if (targetEl) {
      (0, _defer["default"])(function () {
        return targetEl.focus();
      });
      return targetEl;
    }
  }
  if (container.hasAttribute('tabIndex')) {
    (0, _defer["default"])(function () {
      return container.focus();
    });
    return container;
  }
  return null;
}

/**
 * An enumeration of possible navigation directions.
 * @readonly
 * @enum {string}
 */
var focusMoveDirection = Object.freeze({
  NONE: 'none',
  NEXT: 'next',
  PREVIOUS: 'previous'
});

/**
 * Helper function to calculate the new index from the current index.
 *
 * This function determines the new index for focus navigation based on the current index,
 * the direction of movement, and whether looping is enabled. It either caps at the start/end
 * of the array or loops around based on the `enableLoop` flag.
 *
 * @returns {number} - The new index. Returns the current index for invalid direction or out-of-bounds index when looping is disabled.
 */
var calculateIndex = function calculateIndex(_ref2) {
  var itemsLength = _ref2.itemsLength,
    currentIndex = _ref2.currentIndex,
    direction = _ref2.direction,
    enableLoop = _ref2.enableLoop;
  // Check if the direction is valid
  if (direction === focusMoveDirection.NONE || ![focusMoveDirection.NONE, focusMoveDirection.NEXT, focusMoveDirection.PREVIOUS].includes(direction)) {
    return currentIndex; // Return current index for invalid direction
  }
  var increment = direction === focusMoveDirection.NEXT ? 1 : -1;
  if (!enableLoop) {
    var newIndex = currentIndex + increment;
    if (newIndex >= itemsLength || newIndex < 0) {
      return currentIndex;
    }
    return newIndex;
  }
  return (currentIndex + increment + itemsLength) % itemsLength;
};

/**
 * Helper function to get the new focusable index in the items array based on the key.
 *
 * This function calculates the next focusable index in a list of items, depending on the provided key
 * (e.g. arrow keys, Home, End, Tab). It takes into account the current focus index, orientation of navigation
 * (horizontal or vertical), looping behavior, and specific key handling rules.
 *
 * @returns {number} - The new focusable index. Returns -1 if no valid index is found.
 */
exports.calculateIndex = calculateIndex;
var getNewIndex = function getNewIndex(key, itemsLength, currentIndex, _ref3) {
  var enableLoop = _ref3.enableLoop,
    orientation = _ref3.orientation,
    enableTab = _ref3.enableTab,
    enableHomeEnd = _ref3.enableHomeEnd;
  // If the current focused item is not in the actionItems, then focus on the first focusable item.
  if (currentIndex < 0 || currentIndex >= itemsLength) {
    return 0;
  }
  if (key === 'Home') {
    return enableHomeEnd ? 0 : -1;
  }
  if (key === 'End') {
    return enableHomeEnd ? itemsLength - 1 : -1;
  }
  var direction = focusMoveDirection.NONE;
  if (orientation === 'horizontal') {
    if (key === 'ArrowLeft') {
      direction = focusMoveDirection.PREVIOUS;
    }
    if (key === 'ArrowRight') {
      direction = focusMoveDirection.NEXT;
    }
  } else if (orientation === 'vertical') {
    if (key === 'ArrowUp') {
      direction = focusMoveDirection.PREVIOUS;
    }
    if (key === 'ArrowDown') {
      direction = focusMoveDirection.NEXT;
    }
  }
  if (enableTab) {
    // tabShift is a custom key we defined in Menu
    if (key === 'tabShift') {
      direction = focusMoveDirection.PREVIOUS;
    }
    if (key === 'Tab') {
      direction = focusMoveDirection.NEXT;
    }
  }
  if (direction !== focusMoveDirection.NONE) {
    return calculateIndex({
      itemsLength: itemsLength,
      currentIndex: currentIndex,
      direction: direction,
      enableLoop: enableLoop
    });
  }
  return -1;
};

/**
 *  Helper function to update the tabindex of action items, setting the active item to be focusable
 */
exports.getNewIndex = getNewIndex;
var updateTabIndex = function updateTabIndex(activeIndex, actionItems) {
  actionItems.forEach(function (el, index) {
    return el.setAttribute('tabindex', index === activeIndex ? '0' : '-1');
  });
};

/**
 * Handles focus navigation for a list of action items based on key presses.
 *
 * @param {string} key - The key value obtained from KeyboardEvent.key, representing the keyboard key pressed.
 * @param {HTMLElement[]} actionItems - An array of HTML elements representing the action items.
 * @param {number} currentIndex - The current index of the focused item.
 * @param {Object} [options={ enableLoop: false, orientation: 'horizontal', enableTab: false, enableHomeEnd: true }] - Configuration options.
 * @param {boolean} [options.enableLoop=false] - Whether navigation should loop around the ends of the list.
 * @param {string} [options.orientation='horizontal'] - Navigation orientation: 'horizontal' (left/right arrow keys) or 'vertical' (up/down arrow keys).
 * @param {boolean} [options.enableTab=false] - Enable navigation with the Tab key.
 * @param {boolean} [options.enableHomeEnd=true] - Enable navigation with Home and End keys.
 * @public
 */
exports.updateTabIndex = updateTabIndex;
function handleFocus(key, actionItems, currentIndex) {
  var _ref4 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
    _ref4$enableLoop = _ref4.enableLoop,
    enableLoop = _ref4$enableLoop === void 0 ? false : _ref4$enableLoop,
    _ref4$orientation = _ref4.orientation,
    orientation = _ref4$orientation === void 0 ? 'horizontal' : _ref4$orientation,
    _ref4$enableTab = _ref4.enableTab,
    enableTab = _ref4$enableTab === void 0 ? false : _ref4$enableTab,
    _ref4$enableHomeEnd = _ref4.enableHomeEnd,
    enableHomeEnd = _ref4$enableHomeEnd === void 0 ? true : _ref4$enableHomeEnd;
  var itemsLength = actionItems.length;

  // If tab key navigation is disabled, the group should have only one tab stop.
  // `updateTabIndex` adjusts the tabindex of all items accordingly for forward navigation.
  if (!enableTab && key === 'Tab') {
    updateTabIndex(0, actionItems);
    return;
  }
  var newIndex = getNewIndex(key, itemsLength, currentIndex, {
    enableLoop: enableLoop,
    orientation: orientation,
    enableTab: enableTab,
    enableHomeEnd: enableHomeEnd
  });
  if (newIndex >= 0 && newIndex < itemsLength) {
    var _actionItems$newIndex, _actionItems$newIndex2;
    updateTabIndex(newIndex, actionItems);
    (_actionItems$newIndex = (_actionItems$newIndex2 = actionItems[newIndex]).focus) === null || _actionItems$newIndex === void 0 ? void 0 : _actionItems$newIndex.call(_actionItems$newIndex2);
  }

  // If tab key navigation is disabled, the group should only have one tab stop.
  // `updateTabIndex` adjusts the tabindex of all items accordingly for the backward navigation.
  // tabShift is a custom key we defined in Menu
  if (newIndex === -1 && !enableTab && key === 'tabShift') {
    updateTabIndex(currentIndex, actionItems);
  }
}