/******/ (() => {
    // webpackBootstrap
    /******/ "use strict";
    /******/ // The require scope
    /******/    var e = {};
    /******/
    /************************************************************************/
    /******/ /* webpack/runtime/compat get default export */
    /******/    (() => {
        /******/ // getDefaultExport function for compatibility with non-harmony modules
        /******/ e.n = o => {
            /******/ var t = o && o.__esModule ? 
            /******/ () => o["default"]
            /******/ : () => o
            /******/;
            e.d(t, {
                a: t
            });
            /******/            return t;
            /******/        };
        /******/    })();
    /******/
    /******/ /* webpack/runtime/define property getters */
    /******/    (() => {
        /******/ // define getter functions for harmony exports
        /******/ e.d = (o, t) => {
            /******/ for (var n in t) {
                /******/ if (e.o(t, n) && !e.o(o, n)) {
                    /******/ Object.defineProperty(o, n, {
                        enumerable: true,
                        get: t[n]
                    });
                    /******/                }
                /******/            }
            /******/        };
        /******/    })();
    /******/
    /******/ /* webpack/runtime/hasOwnProperty shorthand */
    /******/    (() => {
        /******/ e.o = (e, o) => Object.prototype.hasOwnProperty.call(e, o)
        /******/;
    })();
    /******/
    /******/ /* webpack/runtime/make namespace object */
    /******/    (() => {
        /******/ // define __esModule on exports
        /******/ e.r = e => {
            /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                /******/ Object.defineProperty(e, Symbol.toStringTag, {
                    value: "Module"
                });
                /******/            }
            /******/            Object.defineProperty(e, "__esModule", {
                value: true
            });
            /******/        };
        /******/    })();
    /******/
    /************************************************************************/    var o = {};
    // ESM COMPAT FLAG
        e.r(o);
    // EXPORTS
        e.d(o, {
        default: () => /* reexport */ U,
        legacyRefMode: () => /* reexport */ N
    });
    // CONCATENATED MODULE: external "react"
    const t = require("react");
    var n =  e.n(t);
    // CONCATENATED MODULE: external "prop-types"
    const r = require("prop-types");
    var i =  e.n(r);
    // CONCATENATED MODULE: external "lodash/has"
    const l = require("lodash/has");
    var a =  e.n(l);
    // CONCATENATED MODULE: external "lodash/includes"
    const s = require("lodash/includes");
    var c =  e.n(s);
    // CONCATENATED MODULE: external "lodash/isEmpty"
    const p = require("lodash/isEmpty");
    // CONCATENATED MODULE: external "lodash/isFunction"
    const u = require("lodash/isFunction");
    var f =  e.n(u);
    // CONCATENATED MODULE: external "lodash/keys"
    const d = require("lodash/keys");
    var v =  e.n(d);
    // CONCATENATED MODULE: external "lodash/omit"
    const g = require("lodash/omit");
    var y =  e.n(g);
    // CONCATENATED MODULE: external "@splunk/ui-utils/id"
    const h = require("@splunk/ui-utils/id");
    // CONCATENATED MODULE: external "@splunk/ui-utils/keyboard"
    const b = require("@splunk/ui-utils/keyboard");
    // CONCATENATED MODULE: external "@splunk/react-ui/Popover"
    const O = require("@splunk/react-ui/Popover");
    var m =  e.n(O);
    // CONCATENATED MODULE: ./src/utils/updateReactRef.ts
    /**
 * Updates a React ref. Callback refs and object refs (from `createRef` and `useRef`) are supported.
 *
 * @param ref - The React callback or object ref. Can be `null` or `undefined`.
 * @param current - The new value of the ref.
 */
    function w(e, o) {
        if (e) {
            if (typeof e === "function") {
                e(o);
            } else {
                // the public signature of this util uses React.Ref<T> to mirror the way React types refs.
                // the intention here is to signal "we will take care of setting 'current', not you".
                e.current = o;
 // eslint-disable-line no-param-reassign
                        }
        }
    }
    // CONCATENATED MODULE: ./src/Dropdown/Dropdown.tsx
    function C(e) {
        "@babel/helpers - typeof";
        return C = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e;
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        }, C(e);
    }
    function k(e, o) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var n = Object.getOwnPropertySymbols(e);
            o && (n = n.filter((function(o) {
                return Object.getOwnPropertyDescriptor(e, o).enumerable;
            }))), t.push.apply(t, n);
        }
        return t;
    }
    function R(e) {
        for (var o = 1; o < arguments.length; o++) {
            var t = null != arguments[o] ? arguments[o] : {};
            o % 2 ? k(Object(t), !0).forEach((function(o) {
                _(e, o, t[o]);
            })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : k(Object(t)).forEach((function(o) {
                Object.defineProperty(e, o, Object.getOwnPropertyDescriptor(t, o));
            }));
        }
        return e;
    }
    function j(e, o) {
        if (!(e instanceof o)) throw new TypeError("Cannot call a class as a function");
    }
    function P(e, o) {
        for (var t = 0; t < o.length; t++) {
            var n = o[t];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
            Object.defineProperty(e, F(n.key), n);
        }
    }
    function S(e, o, t) {
        return o && P(e.prototype, o), t && P(e, t), Object.defineProperty(e, "prototype", {
            writable: !1
        }), e;
    }
    function q(e, o) {
        if ("function" != typeof o && null !== o) throw new TypeError("Super expression must either be null or a function");
        e.prototype = Object.create(o && o.prototype, {
            constructor: {
                value: e,
                writable: !0,
                configurable: !0
            }
        }), Object.defineProperty(e, "prototype", {
            writable: !1
        }), o && T(e, o);
    }
    function T(e, o) {
        return T = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, o) {
            return e.__proto__ = o, e;
        }, T(e, o);
    }
    function E(e) {
        var o = K();
        return function() {
            var t, n = M(e);
            if (o) {
                var r = M(this).constructor;
                t = Reflect.construct(n, arguments, r);
            } else t = n.apply(this, arguments);
            return D(this, t);
        };
    }
    function D(e, o) {
        if (o && ("object" == C(o) || "function" == typeof o)) return o;
        if (void 0 !== o) throw new TypeError("Derived constructors may only return object or undefined");
        return I(e);
    }
    function I(e) {
        if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e;
    }
    function K() {
        try {
            var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
        } catch (e) {}
        return (K = function o() {
            return !!e;
        })();
    }
    function M(e) {
        return M = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e);
        }, M(e);
    }
    function _(e, o, t) {
        return (o = F(o)) in e ? Object.defineProperty(e, o, {
            value: t,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[o] = t, e;
    }
    function F(e) {
        var o = A(e, "string");
        return "symbol" == C(o) ? o : o + "";
    }
    function A(e, o) {
        if ("object" != C(e) || !e) return e;
        var t = e[Symbol.toPrimitive];
        if (void 0 !== t) {
            var n = t.call(e, o || "default");
            if ("object" != C(n)) return n;
            throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === o ? String : Number)(e);
    }
    /** @public */
    /** @public */
    /** @public */
    /** @public */
    /** @public */
    /** @public */
    /** @public */
    /** @public */    var x = [ "clickAway", "contentClick", "escapeKey", "offScreen", "tabKey", "toggleClick" ];
    var W = {
        align: i().oneOf([ "center", "edge", "theme", "end" ]),
        canCoverAnchor: i().bool,
        children: i().oneOfType([ i().node, i().func ]),
        closeReasons: i().arrayOf(i().oneOf(x)),
        defaultPlacement: i().oneOf([ "above", "below", "left", "right", "vertical", "horizontal" ]),
        elementRef: i().oneOfType([ i().func, i().object ]),
        focusToggleReasons: i().arrayOf(i().oneOf(x)),
        inputId: i().string,
        onRequestClose: i().func,
        onRequestOpen: i().func,
        open: i().bool,
        openWithArrowKeys: i().bool,
        repositionMode: i().oneOf([ "none", "flip", "any" ]),
        retainFocus: i().bool,
        takeFocus: i().bool,
        toggle: i().element.isRequired
    };
    var B = {
        align: "theme",
        canCoverAnchor: true,
        closeReasons: x,
        defaultPlacement: "below",
        focusToggleReasons: [ "contentClick", "escapeKey", "tabKey", "toggleClick" ],
        repositionMode: "flip",
        retainFocus: false,
        openWithArrowKeys: false,
        takeFocus: true
    };
    var N = Symbol("Dropdown legacy ref mode marker");
    var z =  function(e) {
        q(r, e);
        var o = E(r);
        // @docs-props-type DropdownPropsBase
        /**
   * Enumeration of the possible reasons for closing the Select.
   * 'clickAway', 'escapeKey', and 'offScreen' are inherited from Popover, but repeated here for
   * docs extraction.
   */        function r(e) {
            var t;
            j(this, r);
            t = o.call(this, e);
            _(I(t), "controlledExternally", void 0);
            _(I(t), "popoverId", void 0);
            _(I(t), "toggleRef", null);
            _(I(t), "toggleId", void 0);
            _(I(t), "handleToggleMount", (function(e) {
                t.toggleRef = e;
                t.setState({
                    anchor: e
                });
                if (t.props.toggle.type[N]) {
                    // TS: assume that legacy ref mode toggles support elementRef
                    w(t.props.toggle.props.elementRef, e);
                } else {
                    // TS: ref does not exist on React.ReactElement - technically, this is undocumented API
                    w(t.props.toggle.ref, e);
                }
            }));
            _(I(t), "handleToggleClick", (function(e) {
                var o, n;
                (o = (n = t.props.toggle.props).onClick) === null || o === void 0 ? void 0 : o.call(n, e);
                if (t.isOpen()) {
                    t.handleRequestClose({
                        reason: "toggleClick",
                        event: e
                    });
                } else {
                    var r, i;
                    (r = (i = t.props).onRequestOpen) === null || r === void 0 ? void 0 : r.call(i, e, {
                        reason: "toggleClick"
                    });
                    if (!t.isControlled()) {
                        t.setState({
                            open: true
                        });
                    }
                }
            }));
            _(I(t), "handleToggleKeyDownOpen", (function(e) {
                var o, n;
                (o = (n = t.props.toggle.props).onKeyDown) === null || o === void 0 ? void 0 : o.call(n, e);
                if (!t.props.openWithArrowKeys) {
                    return;
                }
                var r = (0, b.keycode)(e.nativeEvent);
                if (r === "up" || r === "down") {
                    var i, l;
                    e.preventDefault();
                    (i = (l = t.props).onRequestOpen) === null || i === void 0 ? void 0 : i.call(l, e, {
                        reason: "toggleKeydown"
                    });
                    if (!t.isControlled()) {
                        t.setState({
                            open: true
                        });
                    }
                }
            }));
            _(I(t), "handleRequestClose", (function(e) {
                var o = e.event, n = e.reason;
                var r = t.props, i = r.closeReasons, l = r.focusToggleReasons, a = r.onRequestClose;
                if (o && n === "clickAway") {
                    var s = o.target;
                    var p = t.props.inputId || t.props.toggle.props.id || t.toggleId;
                    while (s) {
                        // Ignore clicks on toggle.
                        if (s.id === p) {
                            return;
                        }
                        s = s.parentNode;
                    }
                }
                if (t.isOpen() && c()(i, n)) {
                    if (c()(l, n)) {
                        t.focus();
                    }
                    if (!t.isControlled()) {
                        t.setState({
                            open: false
                        });
                    }
                    a === null || a === void 0 ? void 0 : a(e);
                }
            }));
            _(I(t), "handleContentClick", (function(e) {
                t.handleRequestClose({
                    reason: "contentClick",
                    event: e
                });
            }));
            t.state = {
                anchor: null,
                open: false
            };
            t.controlledExternally = a()(e, "open");
            t.popoverId = (0, h.createDOMID)("popover");
            t.toggleId = (0, h.createDOMID)("toggle");
            return t;
        }
        S(r, [ {
            key: "componentDidUpdate",
            value: function e() {
                if (false) {}
                var o = R({}, y()(this.props, v()(r.propTypes), "aria-labelledby", "id", "value"));
                if (false) {}
            }
        }, {
            key: "isOpen",
            value: function e() {
                return this.isControlled() ? this.props.open : this.state.open;
            }
            /**
     * Places focus on the toggle.
     */        }, {
            key: "focus",
            value: function e() {
                var o;
                (o = this.toggleRef) === null || o === void 0 ? void 0 : o.focus();
            }
        }, {
            key: "isControlled",
            value: function e() {
                return this.controlledExternally;
            }
        }, {
            key: "renderToggle",
            value: function e() {
                var o;
                
                return (0, t.cloneElement)(this.props.toggle, (o = {
                    onClick: this.handleToggleClick,
                    onKeyDown: this.handleToggleKeyDownOpen
                }, _(o, this.props.toggle.type[N] ? "elementRef" : "ref", this.handleToggleMount), 
                _(o, "aria-controls", this.isOpen() ? this.popoverId : undefined), _(o, "aria-haspopup", this.props.toggle.props["aria-haspopup"] || true), 
                _(o, "aria-expanded", this.isOpen()), _(o, "data-test", this.props.toggle.props["data-test"] || "dropdown"), 
                _(o, "data-test-popover-id", this.popoverId), _(o, "id", this.props.inputId || this.props.toggle.props.id || this.toggleId), 
                o));
            }
        }, {
            key: "render",
            value: function e() {
                var o;
                var t = this.props, r = t.align, i = t.canCoverAnchor, l = t.children, a = t.closeReasons, s = t.defaultPlacement, p = t.elementRef, u = t.repositionMode, d = t.retainFocus, v = t.takeFocus;
                var g = this.state.anchor;
                var y = this.handleRequestClose, h = this.handleContentClick;
                var b = this.renderToggle();
                
                return n().createElement(n().Fragment, null, b,  n().createElement(m(), {
                    align: r,
                    open: !!g && this.isOpen(),
                    autoCloseWhenOffScreen: c()(a, "offScreen"),
                    anchor: g,
                    canCoverAnchor: i,
                    elementRef: p,
                    retainFocus: d,
                    defaultPlacement: s,
                    onRequestClose: y,
                    repositionMode: u,
                    id: this.popoverId,
                    "aria-labelledby": "".concat((o = this.props["aria-labelledby"]) !== null && o !== void 0 ? o : "", " ").concat(this.props.inputId || this.props.toggle.props.id || this.toggleId).trim(),
                    takeFocus: v
                }, f()(l) ? 
                // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
                function() {
                    
                    return n().createElement("div", {
                        onClick: h
                    }, l.apply(void 0, arguments));
                } : 
                
                // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
                n().createElement("div", {
                    onClick: h
                }, l)));
            }
        } ]);
        return r;
    }(t.Component);
    _(z, "possibleCloseReasons", x);
    _(z, "propTypes", W);
    _(z, "defaultProps", B);
    /* harmony default export */    const U = z;
    // CONCATENATED MODULE: ./src/Dropdown/index.ts
    module.exports = o;
    /******/})();