/******/ (() => {
    // webpackBootstrap
    /******/ var e = {
        /***/ 6283: 
        /***/ (e, t, n) => {
            "use strict";
            // EXPORTS
                        n.d(t, {
                default: () => /* reexport */ p
            });
            // EXTERNAL MODULE: external "react"
                        var r = n(9497);
            // CONCATENATED MODULE: ./src/useResizeObserver/useResizeObserver.ts
            function a(e, t) {
                return u(e) || l(e, t) || i(e, t) || s();
            }
            function s() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function i(e, t) {
                if (e) {
                    if ("string" == typeof e) return o(e, t);
                    var n = {}.toString.call(e).slice(8, -1);
                    return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? o(e, t) : void 0;
                }
            }
            function o(e, t) {
                (null == t || t > e.length) && (t = e.length);
                for (var n = 0, r = Array(t); n < t; n++) {
                    r[n] = e[n];
                }
                return r;
            }
            function l(e, t) {
                var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                if (null != n) {
                    var r, a, s, i, o = [], l = !0, u = !1;
                    try {
                        if (s = (n = n.call(e)).next, 0 === t) {
                            if (Object(n) !== n) return;
                            l = !1;
                        } else for (;!(l = (r = s.call(n)).done) && (o.push(r.value), o.length !== t); l = !0) {
                        }
                    } catch (e) {
                        u = !0, a = e;
                    } finally {
                        try {
                            if (!l && null != n["return"] && (i = n["return"](), Object(i) !== i)) return;
                        } finally {
                            if (u) throw a;
                        }
                    }
                    return o;
                }
            }
            function u(e) {
                if (Array.isArray(e)) return e;
            }
            /**
 * Watches a React ref element for changes in size.
 *
 * @param ref - The React ref to observe size changes on
 */            var c = function e(t) {
                var n = (0, r.useState)({
                    width: 0,
                    height: 0
                }), s = a(n, 2), i = s[0], o = s[1];
                (0, r.useEffect)((function() {
                    var e = t.current;
                    if (typeof window !== "undefined" && window.ResizeObserver) {
                        var n = new ResizeObserver((function(e) {
                            if (e[0]) {
                                var n, r;
                                o({
                                    width: (t === null || t === void 0 ? void 0 : (n = t.current) === null || n === void 0 ? void 0 : n.getBoundingClientRect().width) || 0,
                                    height: (t === null || t === void 0 ? void 0 : (r = t.current) === null || r === void 0 ? void 0 : r.getBoundingClientRect().height) || 0
                                });
                            }
                        }));
                        if (e) {
                            n.observe(e);
                        }
                        return function() {
                            if (e) {
                                n.unobserve(e);
                            }
                        };
                    }
                    // Return a no-op function to satisfy consistent-return rule
                                        return function() {};
                }), [ t ]);
                return i;
            };
            /* harmony default export */            const p = c;
        } // CONCATENATED MODULE: ./src/useResizeObserver/index.ts
        /***/ ,
        /***/ 74: 
        /***/ e => {
            (function() {
                var t = undefined;
                var n = undefined;
                /// <reference lib="WebWorker"/>
                                var r = typeof t !== "undefined" ? t : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
                /**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */                var a = function(e) {
                    // Private helper vars
                    var n = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
                    var r = 0;
                    // The grammar object for plaintext
                                        var a = {};
                    var s = {
                        /**
		 * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
		 * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
		 * additional languages or plugins yourself.
		 *
		 * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
		 *
		 * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
		 * empty Prism object into the global scope before loading the Prism script like this:
		 *
		 * ```js
		 * window.Prism = window.Prism || {};
		 * Prism.manual = true;
		 * // add a new <script> to load Prism's script
		 * ```
		 *
		 * @default false
		 * @type {boolean}
		 * @memberof Prism
		 * @public
		 */
                        manual: e.Prism && e.Prism.manual,
                        /**
		 * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
		 * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
		 * own worker, you don't want it to do this.
		 *
		 * By setting this value to `true`, Prism will not add its own listeners to the worker.
		 *
		 * You obviously have to change this value before Prism executes. To do this, you can add an
		 * empty Prism object into the global scope before loading the Prism script like this:
		 *
		 * ```js
		 * window.Prism = window.Prism || {};
		 * Prism.disableWorkerMessageHandler = true;
		 * // Load Prism's script
		 * ```
		 *
		 * @default false
		 * @type {boolean}
		 * @memberof Prism
		 * @public
		 */
                        disableWorkerMessageHandler: e.Prism && e.Prism.disableWorkerMessageHandler,
                        /**
		 * A namespace for utility methods.
		 *
		 * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
		 * change or disappear at any time.
		 *
		 * @namespace
		 * @memberof Prism
		 */
                        util: {
                            encode: function e(t) {
                                if (t instanceof i) {
                                    return new i(t.type, e(t.content), t.alias);
                                } else if (Array.isArray(t)) {
                                    return t.map(e);
                                } else {
                                    return t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
                                }
                            },
                            /**
			 * Returns the name of the type of the given value.
			 *
			 * @param {any} o
			 * @returns {string}
			 * @example
			 * type(null)      === 'Null'
			 * type(undefined) === 'Undefined'
			 * type(123)       === 'Number'
			 * type('foo')     === 'String'
			 * type(true)      === 'Boolean'
			 * type([1, 2])    === 'Array'
			 * type({})        === 'Object'
			 * type(String)    === 'Function'
			 * type(/abc+/)    === 'RegExp'
			 */
                            type: function(e) {
                                return Object.prototype.toString.call(e).slice(8, -1);
                            },
                            /**
			 * Returns a unique number for the given object. Later calls will still return the same number.
			 *
			 * @param {Object} obj
			 * @returns {number}
			 */
                            objId: function(e) {
                                if (!e["__id"]) {
                                    Object.defineProperty(e, "__id", {
                                        value: ++r
                                    });
                                }
                                return e["__id"];
                            },
                            /**
			 * Creates a deep clone of the given object.
			 *
			 * The main intended use of this function is to clone language definitions.
			 *
			 * @param {T} o
			 * @param {Record<number, any>} [visited]
			 * @returns {T}
			 * @template T
			 */
                            clone: function e(t, n) {
                                n = n || {};
                                var r;
                                var a;
                                switch (s.util.type(t)) {
                                  case "Object":
                                    a = s.util.objId(t);
                                    if (n[a]) {
                                        return n[a];
                                    }
                                    r = /** @type {Record<string, any>} */ {};
                                    n[a] = r;
                                    for (var i in t) {
                                        if (t.hasOwnProperty(i)) {
                                            r[i] = e(t[i], n);
                                        }
                                    }
                                    /** @type {any} */
                                    return r;

                                  case "Array":
                                    a = s.util.objId(t);
                                    if (n[a]) {
                                        return n[a];
                                    }
                                    r = [];
                                    n[a] = r;
                                    /** @type {Array} */ /** @type {any} */ t.forEach((function(t, a) {
                                        r[a] = e(t, n);
                                    }));
                                    /** @type {any} */
                                    return r;

                                  default:
                                    return t;
                                }
                            },
                            /**
			 * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
			 *
			 * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
			 *
			 * @param {Element} element
			 * @returns {string}
			 */
                            getLanguage: function(e) {
                                while (e) {
                                    var t = n.exec(e.className);
                                    if (t) {
                                        return t[1].toLowerCase();
                                    }
                                    e = e.parentElement;
                                }
                                return "none";
                            },
                            /**
			 * Sets the Prism `language-xxxx` class of the given element.
			 *
			 * @param {Element} element
			 * @param {string} language
			 * @returns {void}
			 */
                            setLanguage: function(e, t) {
                                // remove all `language-xxxx` classes
                                // (this might leave behind a leading space)
                                e.className = e.className.replace(RegExp(n, "gi"), "");
                                // add the new `language-xxxx` class
                                // (using `classList` will automatically clean up spaces for us)
                                                                e.classList.add("language-" + t);
                            },
                            /**
			 * Returns the script element that is currently executing.
			 *
			 * This does __not__ work for line script element.
			 *
			 * @returns {HTMLScriptElement | null}
			 */
                            currentScript: function() {
                                if (typeof document === "undefined") {
                                    return null;
                                }
                                if ("currentScript" in document && 1 < 2 /* hack to trip TS' flow analysis */) {
                                    /** @type {any} */
                                    return document.currentScript;
                                }
                                // IE11 workaround
                                // we'll get the src of the current script by parsing IE11's error stack trace
                                // this will not work for inline scripts
                                                                try {
                                    throw new Error;
                                } catch (r) {
                                    // Get file src url from stack. Specifically works with the format of stack traces in IE.
                                    // A stack will look like this:
                                    // Error
                                    //    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
                                    //    at Global code (http://localhost/components/prism-core.js:606:1)
                                    var e = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(r.stack) || [])[1];
                                    if (e) {
                                        var t = document.getElementsByTagName("script");
                                        for (var n in t) {
                                            if (t[n].src == e) {
                                                return t[n];
                                            }
                                        }
                                    }
                                    return null;
                                }
                            },
                            /**
			 * Returns whether a given class is active for `element`.
			 *
			 * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
			 * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
			 * given class is just the given class with a `no-` prefix.
			 *
			 * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
			 * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
			 * ancestors have the given class or the negated version of it, then the default activation will be returned.
			 *
			 * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
			 * version of it, the class is considered active.
			 *
			 * @param {Element} element
			 * @param {string} className
			 * @param {boolean} [defaultActivation=false]
			 * @returns {boolean}
			 */
                            isActive: function(e, t, n) {
                                var r = "no-" + t;
                                while (e) {
                                    var a = e.classList;
                                    if (a.contains(t)) {
                                        return true;
                                    }
                                    if (a.contains(r)) {
                                        return false;
                                    }
                                    e = e.parentElement;
                                }
                                return !!n;
                            }
                        },
                        /**
		 * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
		 *
		 * @namespace
		 * @memberof Prism
		 * @public
		 */
                        languages: {
                            /**
			 * The grammar for plain, unformatted text.
			 */
                            plain: a,
                            plaintext: a,
                            text: a,
                            txt: a,
                            /**
			 * Creates a deep copy of the language with the given id and appends the given tokens.
			 *
			 * If a token in `redef` also appears in the copied language, then the existing token in the copied language
			 * will be overwritten at its original position.
			 *
			 * ## Best practices
			 *
			 * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
			 * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
			 * understand the language definition because, normally, the order of tokens matters in Prism grammars.
			 *
			 * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
			 * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
			 *
			 * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
			 * @param {Grammar} redef The new tokens to append.
			 * @returns {Grammar} The new language created.
			 * @public
			 * @example
			 * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
			 *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
			 *     // at its original position
			 *     'comment': { ... },
			 *     // CSS doesn't have a 'color' token, so this token will be appended
			 *     'color': /\b(?:red|green|blue)\b/
			 * });
			 */
                            extend: function(e, t) {
                                var n = s.util.clone(s.languages[e]);
                                for (var r in t) {
                                    n[r] = t[r];
                                }
                                return n;
                            },
                            /**
			 * Inserts tokens _before_ another token in a language definition or any other grammar.
			 *
			 * ## Usage
			 *
			 * This helper method makes it easy to modify existing languages. For example, the CSS language definition
			 * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
			 * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
			 * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
			 * this:
			 *
			 * ```js
			 * Prism.languages.markup.style = {
			 *     // token
			 * };
			 * ```
			 *
			 * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
			 * before existing tokens. For the CSS example above, you would use it like this:
			 *
			 * ```js
			 * Prism.languages.insertBefore('markup', 'cdata', {
			 *     'style': {
			 *         // token
			 *     }
			 * });
			 * ```
			 *
			 * ## Special cases
			 *
			 * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
			 * will be ignored.
			 *
			 * This behavior can be used to insert tokens after `before`:
			 *
			 * ```js
			 * Prism.languages.insertBefore('markup', 'comment', {
			 *     'comment': Prism.languages.markup.comment,
			 *     // tokens after 'comment'
			 * });
			 * ```
			 *
			 * ## Limitations
			 *
			 * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
			 * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
			 * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
			 * deleting properties which is necessary to insert at arbitrary positions.
			 *
			 * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
			 * Instead, it will create a new object and replace all references to the target object with the new one. This
			 * can be done without temporarily deleting properties, so the iteration order is well-defined.
			 *
			 * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
			 * you hold the target object in a variable, then the value of the variable will not change.
			 *
			 * ```js
			 * var oldMarkup = Prism.languages.markup;
			 * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
			 *
			 * assert(oldMarkup !== Prism.languages.markup);
			 * assert(newMarkup === Prism.languages.markup);
			 * ```
			 *
			 * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
			 * object to be modified.
			 * @param {string} before The key to insert before.
			 * @param {Grammar} insert An object containing the key-value pairs to be inserted.
			 * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
			 * object to be modified.
			 *
			 * Defaults to `Prism.languages`.
			 * @returns {Grammar} The new grammar object.
			 * @public
			 */
                            insertBefore: function(e, t, n, r) {
                                r = r || /** @type {any} */ s.languages;
                                var a = r[e];
                                /** @type {Grammar} */                                var i = {};
                                for (var o in a) {
                                    if (a.hasOwnProperty(o)) {
                                        if (o == t) {
                                            for (var l in n) {
                                                if (n.hasOwnProperty(l)) {
                                                    i[l] = n[l];
                                                }
                                            }
                                        }
                                        // Do not insert token which also occur in insert. See #1525
                                                                                if (!n.hasOwnProperty(o)) {
                                            i[o] = a[o];
                                        }
                                    }
                                }
                                var u = r[e];
                                r[e] = i;
                                // Update references in other language definitions
                                                                s.languages.DFS(s.languages, (function(t, n) {
                                    if (n === u && t != e) {
                                        this[t] = i;
                                    }
                                }));
                                return i;
                            },
                            // Traverse a language definition with Depth First Search
                            DFS: function e(t, n, r, a) {
                                a = a || {};
                                var i = s.util.objId;
                                for (var o in t) {
                                    if (t.hasOwnProperty(o)) {
                                        n.call(t, o, t[o], r || o);
                                        var l = t[o];
                                        var u = s.util.type(l);
                                        if (u === "Object" && !a[i(l)]) {
                                            a[i(l)] = true;
                                            e(l, n, null, a);
                                        } else if (u === "Array" && !a[i(l)]) {
                                            a[i(l)] = true;
                                            e(l, n, o, a);
                                        }
                                    }
                                }
                            }
                        },
                        plugins: {},
                        /**
		 * This is the most high-level function in Prism’s API.
		 * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
		 * each one of them.
		 *
		 * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
		 *
		 * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
		 * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
		 * @memberof Prism
		 * @public
		 */
                        highlightAll: function(e, t) {
                            s.highlightAllUnder(document, e, t);
                        },
                        /**
		 * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
		 * {@link Prism.highlightElement} on each one of them.
		 *
		 * The following hooks will be run:
		 * 1. `before-highlightall`
		 * 2. `before-all-elements-highlight`
		 * 3. All hooks of {@link Prism.highlightElement} for each element.
		 *
		 * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
		 * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
		 * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
		 * @memberof Prism
		 * @public
		 */
                        highlightAllUnder: function(e, t, n) {
                            var r = {
                                callback: n,
                                container: e,
                                selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
                            };
                            s.hooks.run("before-highlightall", r);
                            r.elements = Array.prototype.slice.apply(r.container.querySelectorAll(r.selector));
                            s.hooks.run("before-all-elements-highlight", r);
                            for (var a = 0, i; i = r.elements[a++]; ) {
                                s.highlightElement(i, t === true, r.callback);
                            }
                        },
                        /**
		 * Highlights the code inside a single element.
		 *
		 * The following hooks will be run:
		 * 1. `before-sanity-check`
		 * 2. `before-highlight`
		 * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
		 * 4. `before-insert`
		 * 5. `after-highlight`
		 * 6. `complete`
		 *
		 * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
		 * the element's language.
		 *
		 * @param {Element} element The element containing the code.
		 * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
		 * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
		 * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
		 * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
		 *
		 * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
		 * asynchronous highlighting to work. You can build your own bundle on the
		 * [Download page](https://prismjs.com/download.html).
		 * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
		 * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
		 * @memberof Prism
		 * @public
		 */
                        highlightElement: function(t, n, r) {
                            // Find language
                            var a = s.util.getLanguage(t);
                            var i = s.languages[a];
                            // Set language on the element, if not present
                                                        s.util.setLanguage(t, a);
                            // Set language on the parent, for styling
                                                        var o = t.parentElement;
                            if (o && o.nodeName.toLowerCase() === "pre") {
                                s.util.setLanguage(o, a);
                            }
                            var l = t.textContent;
                            var u = {
                                element: t,
                                language: a,
                                grammar: i,
                                code: l
                            };
                            function c(e) {
                                u.highlightedCode = e;
                                s.hooks.run("before-insert", u);
                                u.element.innerHTML = u.highlightedCode;
                                s.hooks.run("after-highlight", u);
                                s.hooks.run("complete", u);
                                r && r.call(u.element);
                            }
                            s.hooks.run("before-sanity-check", u);
                            // plugins may change/add the parent/element
                                                        o = u.element.parentElement;
                            if (o && o.nodeName.toLowerCase() === "pre" && !o.hasAttribute("tabindex")) {
                                o.setAttribute("tabindex", "0");
                            }
                            if (!u.code) {
                                s.hooks.run("complete", u);
                                r && r.call(u.element);
                                return;
                            }
                            s.hooks.run("before-highlight", u);
                            if (!u.grammar) {
                                c(s.util.encode(u.code));
                                return;
                            }
                            if (n && e.Worker) {
                                var p = new Worker(s.filename);
                                p.onmessage = function(e) {
                                    c(e.data);
                                };
                                p.postMessage(JSON.stringify({
                                    language: u.language,
                                    code: u.code,
                                    immediateClose: true
                                }));
                            } else {
                                c(s.highlight(u.code, u.grammar, u.language));
                            }
                        },
                        /**
		 * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
		 * and the language definitions to use, and returns a string with the HTML produced.
		 *
		 * The following hooks will be run:
		 * 1. `before-tokenize`
		 * 2. `after-tokenize`
		 * 3. `wrap`: On each {@link Token}.
		 *
		 * @param {string} text A string with the code to be highlighted.
		 * @param {Grammar} grammar An object containing the tokens to use.
		 *
		 * Usually a language definition like `Prism.languages.markup`.
		 * @param {string} language The name of the language definition passed to `grammar`.
		 * @returns {string} The highlighted HTML.
		 * @memberof Prism
		 * @public
		 * @example
		 * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
		 */
                        highlight: function(e, t, n) {
                            var r = {
                                code: e,
                                grammar: t,
                                language: n
                            };
                            s.hooks.run("before-tokenize", r);
                            if (!r.grammar) {
                                throw new Error('The language "' + r.language + '" has no grammar.');
                            }
                            r.tokens = s.tokenize(r.code, r.grammar);
                            s.hooks.run("after-tokenize", r);
                            return i.stringify(s.util.encode(r.tokens), r.language);
                        },
                        /**
		 * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
		 * and the language definitions to use, and returns an array with the tokenized code.
		 *
		 * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
		 *
		 * This method could be useful in other contexts as well, as a very crude parser.
		 *
		 * @param {string} text A string with the code to be highlighted.
		 * @param {Grammar} grammar An object containing the tokens to use.
		 *
		 * Usually a language definition like `Prism.languages.markup`.
		 * @returns {TokenStream} An array of strings and tokens, a token stream.
		 * @memberof Prism
		 * @public
		 * @example
		 * let code = `var foo = 0;`;
		 * let tokens = Prism.tokenize(code, Prism.languages.javascript);
		 * tokens.forEach(token => {
		 *     if (token instanceof Prism.Token && token.type === 'number') {
		 *         console.log(`Found numeric literal: ${token.content}`);
		 *     }
		 * });
		 */
                        tokenize: function(e, t) {
                            var n = t.rest;
                            if (n) {
                                for (var r in n) {
                                    t[r] = n[r];
                                }
                                delete t.rest;
                            }
                            var a = new u;
                            c(a, a.head, e);
                            l(e, a, t, a.head, 0);
                            return d(a);
                        },
                        /**
		 * @namespace
		 * @memberof Prism
		 * @public
		 */
                        hooks: {
                            all: {},
                            /**
			 * Adds the given callback to the list of callbacks for the given hook.
			 *
			 * The callback will be invoked when the hook it is registered for is run.
			 * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
			 *
			 * One callback function can be registered to multiple hooks and the same hook multiple times.
			 *
			 * @param {string} name The name of the hook.
			 * @param {HookCallback} callback The callback function which is given environment variables.
			 * @public
			 */
                            add: function(e, t) {
                                var n = s.hooks.all;
                                n[e] = n[e] || [];
                                n[e].push(t);
                            },
                            /**
			 * Runs a hook invoking all registered callbacks with the given environment variables.
			 *
			 * Callbacks will be invoked synchronously and in the order in which they were registered.
			 *
			 * @param {string} name The name of the hook.
			 * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
			 * @public
			 */
                            run: function(e, t) {
                                var n = s.hooks.all[e];
                                if (!n || !n.length) {
                                    return;
                                }
                                for (var r = 0, a; a = n[r++]; ) {
                                    a(t);
                                }
                            }
                        },
                        Token: i
                    };
                    e.Prism = s;
                    // Typescript note:
                    // The following can be used to import the Token type in JSDoc:
                    
                    //   @typedef {InstanceType<import("./prism-core")["Token"]>} Token
                    /**
	 * Creates a new token.
	 *
	 * @param {string} type See {@link Token#type type}
	 * @param {string | TokenStream} content See {@link Token#content content}
	 * @param {string|string[]} [alias] The alias(es) of the token.
	 * @param {string} [matchedStr=""] A copy of the full string this token was created from.
	 * @class
	 * @global
	 * @public
	 */                    function i(e, t, n, r) {
                        /**
		 * The type of the token.
		 *
		 * This is usually the key of a pattern in a {@link Grammar}.
		 *
		 * @type {string}
		 * @see GrammarToken
		 * @public
		 */
                        this.type = e;
                        /**
		 * The strings or tokens contained by this token.
		 *
		 * This will be a token stream if the pattern matched also defined an `inside` grammar.
		 *
		 * @type {string | TokenStream}
		 * @public
		 */                        this.content = t;
                        /**
		 * The alias(es) of the token.
		 *
		 * @type {string|string[]}
		 * @see GrammarToken
		 * @public
		 */                        this.alias = n;
                        // Copy of the full string this token was created from
                                                this.length = (r || "").length | 0;
                    }
                    /**
	 * A token stream is an array of strings and {@link Token Token} objects.
	 *
	 * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
	 * them.
	 *
	 * 1. No adjacent strings.
	 * 2. No empty strings.
	 *
	 *    The only exception here is the token stream that only contains the empty string and nothing else.
	 *
	 * @typedef {Array<string | Token>} TokenStream
	 * @global
	 * @public
	 */
                    /**
	 * Converts the given token or token stream to an HTML representation.
	 *
	 * The following hooks will be run:
	 * 1. `wrap`: On each {@link Token}.
	 *
	 * @param {string | Token | TokenStream} o The token or token stream to be converted.
	 * @param {string} language The name of current language.
	 * @returns {string} The HTML representation of the token or token stream.
	 * @memberof Token
	 * @static
	 */                    i.stringify = function e(t, n) {
                        if (typeof t == "string") {
                            return t;
                        }
                        if (Array.isArray(t)) {
                            var r = "";
                            t.forEach((function(t) {
                                r += e(t, n);
                            }));
                            return r;
                        }
                        var a = {
                            type: t.type,
                            content: e(t.content, n),
                            tag: "span",
                            classes: [ "token", t.type ],
                            attributes: {},
                            language: n
                        };
                        var i = t.alias;
                        if (i) {
                            if (Array.isArray(i)) {
                                Array.prototype.push.apply(a.classes, i);
                            } else {
                                a.classes.push(i);
                            }
                        }
                        s.hooks.run("wrap", a);
                        var o = "";
                        for (var l in a.attributes) {
                            o += " " + l + '="' + (a.attributes[l] || "").replace(/"/g, "&quot;") + '"';
                        }
                        return "<" + a.tag + ' class="' + a.classes.join(" ") + '"' + o + ">" + a.content + "</" + a.tag + ">";
                    };
                    /**
	 * @param {RegExp} pattern
	 * @param {number} pos
	 * @param {string} text
	 * @param {boolean} lookbehind
	 * @returns {RegExpExecArray | null}
	 */                    function o(e, t, n, r) {
                        e.lastIndex = t;
                        var a = e.exec(n);
                        if (a && r && a[1]) {
                            // change the match to remove the text matched by the Prism lookbehind group
                            var s = a[1].length;
                            a.index += s;
                            a[0] = a[0].slice(s);
                        }
                        return a;
                    }
                    /**
	 * @param {string} text
	 * @param {LinkedList<string | Token>} tokenList
	 * @param {any} grammar
	 * @param {LinkedListNode<string | Token>} startNode
	 * @param {number} startPos
	 * @param {RematchOptions} [rematch]
	 * @returns {void}
	 * @private
	 *
	 * @typedef RematchOptions
	 * @property {string} cause
	 * @property {number} reach
	 */                    function l(e, t, n, r, a, u) {
                        for (var d in n) {
                            if (!n.hasOwnProperty(d) || !n[d]) {
                                continue;
                            }
                            var g = n[d];
                            g = Array.isArray(g) ? g : [ g ];
                            for (var f = 0; f < g.length; ++f) {
                                if (u && u.cause == d + "," + f) {
                                    return;
                                }
                                var E = g[f];
                                var m = E.inside;
                                var h = !!E.lookbehind;
                                var v = !!E.greedy;
                                var b = E.alias;
                                if (v && !E.pattern.global) {
                                    // Without the global flag, lastIndex won't work
                                    var S = E.pattern.toString().match(/[imsuy]*$/)[0];
                                    E.pattern = RegExp(E.pattern.source, S + "g");
                                }
                                /** @type {RegExp} */                                var y = E.pattern || E;
                                for (// iterate the token list and keep track of the current token/string position
                                var A = r.next, T = a; A !== t.tail; T += A.value.length, A = A.next) {
                                    if (u && T >= u.reach) {
                                        break;
                                    }
                                    var I = A.value;
                                    if (t.length > e.length) {
                                        // Something went terribly wrong, ABORT, ABORT!
                                        return;
                                    }
                                    if (I instanceof i) {
                                        continue;
                                    }
                                    var O = 1;
 // this is the to parameter of removeBetween
                                                                        var R;
                                    if (v) {
                                        R = o(y, T, e, h);
                                        if (!R || R.index >= e.length) {
                                            break;
                                        }
                                        var N = R.index;
                                        var k = R.index + R[0].length;
                                        var x = T;
                                        // find the node that contains the match
                                                                                x += A.value.length;
                                        while (N >= x) {
                                            A = A.next;
                                            x += A.value.length;
                                        }
                                        // adjust pos (and p)
                                                                                x -= A.value.length;
                                        T = x;
                                        // the current node is a Token, then the match starts inside another Token, which is invalid
                                                                                if (A.value instanceof i) {
                                            continue;
                                        }
                                        // find the last node which is affected by this match
                                                                                for (var L = A; L !== t.tail && (x < k || typeof L.value === "string"); L = L.next) {
                                            O++;
                                            x += L.value.length;
                                        }
                                        O--;
                                        // replace with the new match
                                                                                I = e.slice(T, x);
                                        R.index -= T;
                                    } else {
                                        R = o(y, 0, I, h);
                                        if (!R) {
                                            continue;
                                        }
                                    }
                                    // eslint-disable-next-line no-redeclare
                                                                        var N = R.index;
                                    var F = R[0];
                                    var C = I.slice(0, N);
                                    var w = I.slice(N + F.length);
                                    var D = T + I.length;
                                    if (u && D > u.reach) {
                                        u.reach = D;
                                    }
                                    var P = A.prev;
                                    if (C) {
                                        P = c(t, P, C);
                                        T += C.length;
                                    }
                                    p(t, P, O);
                                    var _ = new i(d, m ? s.tokenize(F, m) : F, b, F);
                                    A = c(t, P, _);
                                    if (w) {
                                        c(t, A, w);
                                    }
                                    if (O > 1) {
                                        // at least one Token object was removed, so we have to do some rematching
                                        // this can only happen if the current pattern is greedy
                                        /** @type {RematchOptions} */
                                        var U = {
                                            cause: d + "," + f,
                                            reach: D
                                        };
                                        l(e, t, n, A.prev, T, U);
                                        // the reach might have been extended because of the rematching
                                                                                if (u && U.reach > u.reach) {
                                            u.reach = U.reach;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    /**
	 * @typedef LinkedListNode
	 * @property {T} value
	 * @property {LinkedListNode<T> | null} prev The previous node.
	 * @property {LinkedListNode<T> | null} next The next node.
	 * @template T
	 * @private
	 */
                    /**
	 * @template T
	 * @private
	 */                    function u() {
                        /** @type {LinkedListNode<T>} */
                        var e = {
                            value: null,
                            prev: null,
                            next: null
                        };
                        /** @type {LinkedListNode<T>} */                        var t = {
                            value: null,
                            prev: e,
                            next: null
                        };
                        e.next = t;
                        /** @type {LinkedListNode<T>} */                        this.head = e;
                        /** @type {LinkedListNode<T>} */                        this.tail = t;
                        this.length = 0;
                    }
                    /**
	 * Adds a new node with the given value to the list.
	 *
	 * @param {LinkedList<T>} list
	 * @param {LinkedListNode<T>} node
	 * @param {T} value
	 * @returns {LinkedListNode<T>} The added node.
	 * @template T
	 */                    function c(e, t, n) {
                        // assumes that node != list.tail && values.length >= 0
                        var r = t.next;
                        var a = {
                            value: n,
                            prev: t,
                            next: r
                        };
                        t.next = a;
                        r.prev = a;
                        e.length++;
                        return a;
                    }
                    /**
	 * Removes `count` nodes after the given node. The given node will not be removed.
	 *
	 * @param {LinkedList<T>} list
	 * @param {LinkedListNode<T>} node
	 * @param {number} count
	 * @template T
	 */                    function p(e, t, n) {
                        var r = t.next;
                        for (var a = 0; a < n && r !== e.tail; a++) {
                            r = r.next;
                        }
                        t.next = r;
                        r.prev = t;
                        e.length -= a;
                    }
                    /**
	 * @param {LinkedList<T>} list
	 * @returns {T[]}
	 * @template T
	 */                    function d(e) {
                        var t = [];
                        var n = e.head.next;
                        while (n !== e.tail) {
                            t.push(n.value);
                            n = n.next;
                        }
                        return t;
                    }
                    if (!e.document) {
                        if (!e.addEventListener) {
                            // in Node.js
                            return s;
                        }
                        if (!s.disableWorkerMessageHandler) {
                            // In worker
                            e.addEventListener("message", (function(t) {
                                var n = JSON.parse(t.data);
                                var r = n.language;
                                var a = n.code;
                                var i = n.immediateClose;
                                e.postMessage(s.highlight(a, s.languages[r], r));
                                if (i) {
                                    e.close();
                                }
                            }), false);
                        }
                        return s;
                    }
                    // Get current script and highlight
                                        var g = s.util.currentScript();
                    if (g) {
                        s.filename = g.src;
                        if (g.hasAttribute("data-manual")) {
                            s.manual = true;
                        }
                    }
                    function f() {
                        if (!s.manual) {
                            s.highlightAll();
                        }
                    }
                    if (!s.manual) {
                        // If the document state is "loading", then we'll use DOMContentLoaded.
                        // If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
                        // DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
                        // might take longer one animation frame to execute which can create a race condition where only some plugins have
                        // been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
                        // See https://github.com/PrismJS/prism/issues/2102
                        var E = document.readyState;
                        if (E === "loading" || E === "interactive" && g && g.defer) {
                            document.addEventListener("DOMContentLoaded", f);
                        } else {
                            if (t.requestAnimationFrame) {
                                t.requestAnimationFrame(f);
                            } else {
                                t.setTimeout(f, 16);
                            }
                        }
                    }
                    return s;
                }(r);
                if (true && e.exports) {
                    e.exports = a;
                }
                // hack for components to work correctly in node.js
                                if (typeof n !== "undefined") {
                    n.Prism = a;
                }
                // some additional documentation/types
                /**
 * The expansion of a simple `RegExp` literal to support additional properties.
 *
 * @typedef GrammarToken
 * @property {RegExp} pattern The regular expression of the token.
 * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
 * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
 * @property {boolean} [greedy=false] Whether the token is greedy.
 * @property {string|string[]} [alias] An optional alias or list of aliases.
 * @property {Grammar} [inside] The nested grammar of this token.
 *
 * The `inside` grammar will be used to tokenize the text value of each token of this kind.
 *
 * This can be used to make nested and even recursive language definitions.
 *
 * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
 * each another.
 * @global
 * @public
 */
                /**
 * @typedef Grammar
 * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
 * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
 * @global
 * @public
 */
                /**
 * A function which will invoked after an element was successfully highlighted.
 *
 * @callback HighlightCallback
 * @param {Element} element The element successfully highlighted.
 * @returns {void}
 * @global
 * @public
 */
                /**
 * @callback HookCallback
 * @param {Object<string, any>} env The environment variables of the hook.
 * @returns {void}
 * @global
 * @public
 */
                // https://www.json.org/json-en.html
                                a.languages.json = {
                    property: {
                        pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
                        lookbehind: true,
                        greedy: true
                    },
                    string: {
                        pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
                        lookbehind: true,
                        greedy: true
                    },
                    comment: {
                        pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
                        greedy: true
                    },
                    number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
                    punctuation: /[{}[\],]/,
                    operator: /:/,
                    boolean: /\b(?:false|true)\b/,
                    null: {
                        pattern: /\bnull\b/,
                        alias: "keyword"
                    }
                };
                a.languages.webmanifest = a.languages.json;
                a.languages.markup = {
                    comment: {
                        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
                        greedy: true
                    },
                    prolog: {
                        pattern: /<\?[\s\S]+?\?>/,
                        greedy: true
                    },
                    doctype: {
                        // https://www.w3.org/TR/xml/#NT-doctypedecl
                        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
                        greedy: true,
                        inside: {
                            "internal-subset": {
                                pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
                                lookbehind: true,
                                greedy: true,
                                inside: null
                            },
                            string: {
                                pattern: /"[^"]*"|'[^']*'/,
                                greedy: true
                            },
                            punctuation: /^<!|>$|[[\]]/,
                            "doctype-tag": /^DOCTYPE/i,
                            name: /[^\s<>'"]+/
                        }
                    },
                    cdata: {
                        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
                        greedy: true
                    },
                    tag: {
                        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
                        greedy: true,
                        inside: {
                            tag: {
                                pattern: /^<\/?[^\s>\/]+/,
                                inside: {
                                    punctuation: /^<\/?/,
                                    namespace: /^[^\s>\/:]+:/
                                }
                            },
                            "special-attr": [],
                            "attr-value": {
                                pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
                                inside: {
                                    punctuation: [ {
                                        pattern: /^=/,
                                        alias: "attr-equals"
                                    }, {
                                        pattern: /^(\s*)["']|["']$/,
                                        lookbehind: true
                                    } ]
                                }
                            },
                            punctuation: /\/?>/,
                            "attr-name": {
                                pattern: /[^\s>\/]+/,
                                inside: {
                                    namespace: /^[^\s>\/:]+:/
                                }
                            }
                        }
                    },
                    entity: [ {
                        pattern: /&[\da-z]{1,8};/i,
                        alias: "named-entity"
                    }, /&#x?[\da-f]{1,8};/i ]
                };
                a.languages.markup["tag"].inside["attr-value"].inside["entity"] = a.languages.markup["entity"];
                a.languages.markup["doctype"].inside["internal-subset"].inside = a.languages.markup;
                // Plugin to make entity title show the real entity, idea by Roman Komarov
                                a.hooks.add("wrap", (function(e) {
                    if (e.type === "entity") {
                        e.attributes["title"] = e.content.replace(/&amp;/, "&");
                    }
                }));
                Object.defineProperty(a.languages.markup.tag, "addInlined", {
                    /**
	 * Adds an inlined language to markup.
	 *
	 * An example of an inlined language is CSS with `<style>` tags.
	 *
	 * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
	 * case insensitive.
	 * @param {string} lang The language key.
	 * @example
	 * addInlined('style', 'css');
	 */
                    value: function e(t, n) {
                        var r = {};
                        r["language-" + n] = {
                            pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
                            lookbehind: true,
                            inside: a.languages[n]
                        };
                        r["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
                        var s = {
                            "included-cdata": {
                                pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
                                inside: r
                            }
                        };
                        s["language-" + n] = {
                            pattern: /[\s\S]+/,
                            inside: a.languages[n]
                        };
                        var i = {};
                        i[t] = {
                            pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, (function() {
                                return t;
                            })), "i"),
                            lookbehind: true,
                            greedy: true,
                            inside: s
                        };
                        a.languages.insertBefore("markup", "cdata", i);
                    }
                });
                Object.defineProperty(a.languages.markup.tag, "addAttribute", {
                    /**
	 * Adds an pattern to highlight languages embedded in HTML attributes.
	 *
	 * An example of an inlined language is CSS with `style` attributes.
	 *
	 * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
	 * case insensitive.
	 * @param {string} lang The language key.
	 * @example
	 * addAttribute('style', 'css');
	 */
                    value: function(e, t) {
                        a.languages.markup.tag.inside["special-attr"].push({
                            pattern: RegExp(/(^|["'\s])/.source + "(?:" + e + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
                            lookbehind: true,
                            inside: {
                                "attr-name": /^[^\s=]+/,
                                "attr-value": {
                                    pattern: /=[\s\S]+/,
                                    inside: {
                                        value: {
                                            pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                                            lookbehind: true,
                                            alias: [ t, "language-" + t ],
                                            inside: a.languages[t]
                                        },
                                        punctuation: [ {
                                            pattern: /^=/,
                                            alias: "attr-equals"
                                        }, /"|'/ ]
                                    }
                                }
                            }
                        });
                    }
                });
                a.languages.html = a.languages.markup;
                a.languages.mathml = a.languages.markup;
                a.languages.svg = a.languages.markup;
                a.languages.xml = a.languages.extend("markup", {});
                a.languages.ssml = a.languages.xml;
                a.languages.atom = a.languages.xml;
                a.languages.rss = a.languages.xml;
                a.languages.clike = {
                    comment: [ {
                        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
                        lookbehind: true,
                        greedy: true
                    }, {
                        pattern: /(^|[^\\:])\/\/.*/,
                        lookbehind: true,
                        greedy: true
                    } ],
                    string: {
                        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
                        greedy: true
                    },
                    "class-name": {
                        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
                        lookbehind: true,
                        inside: {
                            punctuation: /[.\\]/
                        }
                    },
                    keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
                    boolean: /\b(?:false|true)\b/,
                    function: /\b\w+(?=\()/,
                    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
                    operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
                    punctuation: /[{}[\];(),.:]/
                };
                a.languages.javascript = a.languages.extend("clike", {
                    "class-name": [ a.languages.clike["class-name"], {
                        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
                        lookbehind: true
                    } ],
                    keyword: [ {
                        pattern: /((?:^|\})\s*)catch\b/,
                        lookbehind: true
                    }, {
                        pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
                        lookbehind: true
                    } ],
                    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
                    function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
                    number: {
                        pattern: RegExp(/(^|[^\w$])/.source + "(?:" + (
                        // constant
                        /NaN|Infinity/.source + "|" + 
                        // binary integer
                        /0[bB][01]+(?:_[01]+)*n?/.source + "|" + 
                        // octal integer
                        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + 
                        // hexadecimal integer
                        /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + 
                        // decimal bigint
                        /\d+(?:_\d+)*n/.source + "|" + 
                        // decimal number (integer or float) but no bigint
                        /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source),
                        lookbehind: true
                    },
                    operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
                });
                a.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
                a.languages.insertBefore("javascript", "keyword", {
                    regex: {
                        pattern: RegExp(
                        // lookbehind
                        // eslint-disable-next-line regexp/no-dupe-characters-character-class
                        /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + 
                        // Regex pattern:
                        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
                        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
                        // with the only syntax, so we have to define 2 different regex patterns.
                        /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + 
                        // `v` flag syntax. This supports 3 levels of nested character classes.
                        /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + 
                        // lookahead
                        /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source),
                        lookbehind: true,
                        greedy: true,
                        inside: {
                            "regex-source": {
                                pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
                                lookbehind: true,
                                alias: "language-regex",
                                inside: a.languages.regex
                            },
                            "regex-delimiter": /^\/|\/$/,
                            "regex-flags": /^[a-z]+$/
                        }
                    },
                    // This must be declared before keyword because we use "function" inside the look-forward
                    "function-variable": {
                        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
                        alias: "function"
                    },
                    parameter: [ {
                        pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
                        lookbehind: true,
                        inside: a.languages.javascript
                    }, {
                        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
                        lookbehind: true,
                        inside: a.languages.javascript
                    }, {
                        pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
                        lookbehind: true,
                        inside: a.languages.javascript
                    }, {
                        pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
                        lookbehind: true,
                        inside: a.languages.javascript
                    } ],
                    constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
                });
                a.languages.insertBefore("javascript", "string", {
                    hashbang: {
                        pattern: /^#!.*/,
                        greedy: true,
                        alias: "comment"
                    },
                    "template-string": {
                        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
                        greedy: true,
                        inside: {
                            "template-punctuation": {
                                pattern: /^`|`$/,
                                alias: "string"
                            },
                            interpolation: {
                                pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
                                lookbehind: true,
                                inside: {
                                    "interpolation-punctuation": {
                                        pattern: /^\$\{|\}$/,
                                        alias: "punctuation"
                                    },
                                    rest: a.languages.javascript
                                }
                            },
                            string: /[\s\S]+/
                        }
                    },
                    "string-property": {
                        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
                        lookbehind: true,
                        greedy: true,
                        alias: "property"
                    }
                });
                a.languages.insertBefore("javascript", "operator", {
                    "literal-property": {
                        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
                        lookbehind: true,
                        alias: "property"
                    }
                });
                if (a.languages.markup) {
                    a.languages.markup.tag.addInlined("script", "javascript");
                    // add attribute support for all DOM events.
                    // https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events
                                        a.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript");
                }
                a.languages.js = a.languages.javascript;
                (function(e) {
                    var t = e.util.clone(e.languages.javascript);
                    var n = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source;
                    var r = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source;
                    var a = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
                    /**
	 * @param {string} source
	 * @param {string} [flags]
	 */                    function s(e, t) {
                        e = e.replace(/<S>/g, (function() {
                            return n;
                        })).replace(/<BRACES>/g, (function() {
                            return r;
                        })).replace(/<SPREAD>/g, (function() {
                            return a;
                        }));
                        return RegExp(e, t);
                    }
                    a = s(a).source;
                    e.languages.jsx = e.languages.extend("markup", t);
                    e.languages.jsx.tag.pattern = s(/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source);
                    e.languages.jsx.tag.inside["tag"].pattern = /^<\/?[^\s>\/]*/;
                    e.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/;
                    e.languages.jsx.tag.inside["tag"].inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/;
                    e.languages.jsx.tag.inside["comment"] = t["comment"];
                    e.languages.insertBefore("inside", "attr-name", {
                        spread: {
                            pattern: s(/<SPREAD>/.source),
                            inside: e.languages.jsx
                        }
                    }, e.languages.jsx.tag);
                    e.languages.insertBefore("inside", "special-attr", {
                        script: {
                            // Allow for two levels of nesting
                            pattern: s(/=<BRACES>/.source),
                            alias: "language-javascript",
                            inside: {
                                "script-punctuation": {
                                    pattern: /^=(?=\{)/,
                                    alias: "punctuation"
                                },
                                rest: e.languages.jsx
                            }
                        }
                    }, e.languages.jsx.tag);
                    // The following will handle plain text inside tags
                                        var i = function(e) {
                        if (!e) {
                            return "";
                        }
                        if (typeof e === "string") {
                            return e;
                        }
                        if (typeof e.content === "string") {
                            return e.content;
                        }
                        return e.content.map(i).join("");
                    };
                    var o = function(t) {
                        var n = [];
                        for (var r = 0; r < t.length; r++) {
                            var a = t[r];
                            var s = false;
                            if (typeof a !== "string") {
                                if (a.type === "tag" && a.content[0] && a.content[0].type === "tag") {
                                    // We found a tag, now find its kind
                                    if (a.content[0].content[0].content === "</") {
                                        // Closing tag
                                        if (n.length > 0 && n[n.length - 1].tagName === i(a.content[0].content[1])) {
                                            // Pop matching opening tag
                                            n.pop();
                                        }
                                    } else {
                                        if (a.content[a.content.length - 1].content === "/>") {
                                            // Autoclosed tag, ignore
                                        } else {
                                            // Opening tag
                                            n.push({
                                                tagName: i(a.content[0].content[1]),
                                                openedBraces: 0
                                            });
                                        }
                                    }
                                } else if (n.length > 0 && a.type === "punctuation" && a.content === "{") {
                                    // Here we might have entered a JSX context inside a tag
                                    n[n.length - 1].openedBraces++;
                                } else if (n.length > 0 && n[n.length - 1].openedBraces > 0 && a.type === "punctuation" && a.content === "}") {
                                    // Here we might have left a JSX context inside a tag
                                    n[n.length - 1].openedBraces--;
                                } else {
                                    s = true;
                                }
                            }
                            if (s || typeof a === "string") {
                                if (n.length > 0 && n[n.length - 1].openedBraces === 0) {
                                    // Here we are inside a tag, and not inside a JSX context.
                                    // That's plain text: drop any tokens matched.
                                    var l = i(a);
                                    // And merge text with adjacent text
                                                                        if (r < t.length - 1 && (typeof t[r + 1] === "string" || t[r + 1].type === "plain-text")) {
                                        l += i(t[r + 1]);
                                        t.splice(r + 1, 1);
                                    }
                                    if (r > 0 && (typeof t[r - 1] === "string" || t[r - 1].type === "plain-text")) {
                                        l = i(t[r - 1]) + l;
                                        t.splice(r - 1, 1);
                                        r--;
                                    }
                                    t[r] = new e.Token("plain-text", l, null, l);
                                }
                            }
                            if (a.content && typeof a.content !== "string") {
                                o(a.content);
                            }
                        }
                    };
                    e.hooks.add("after-tokenize", (function(e) {
                        if (e.language !== "jsx" && e.language !== "tsx") {
                            return;
                        }
                        o(e.tokens);
                    }));
                })(a);
                (function(e) {
                    e.languages.typescript = e.languages.extend("javascript", {
                        "class-name": {
                            pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
                            lookbehind: true,
                            greedy: true,
                            inside: null
                        },
                        builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
                    });
                    // The keywords TypeScript adds to JavaScript
                                        e.languages.typescript.keyword.push(/\b(?:abstract|declare|is|keyof|readonly|require)\b/, 
                    // keywords that have to be followed by an identifier
                    /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/, 
                    // This is for `import type *, {}`
                    /\btype\b(?=\s*(?:[\{*]|$))/);
                    // doesn't work with TS because TS is too complex
                                        delete e.languages.typescript["parameter"];
                    delete e.languages.typescript["literal-property"];
                    // a version of typescript specifically for highlighting types
                                        var t = e.languages.extend("typescript", {});
                    delete t["class-name"];
                    e.languages.typescript["class-name"].inside = t;
                    e.languages.insertBefore("typescript", "function", {
                        decorator: {
                            pattern: /@[$\w\xA0-\uFFFF]+/,
                            inside: {
                                at: {
                                    pattern: /^@/,
                                    alias: "operator"
                                },
                                function: /^[\s\S]+/
                            }
                        },
                        "generic-function": {
                            // e.g. foo<T extends "bar" | "baz">( ...
                            pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
                            greedy: true,
                            inside: {
                                function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
                                generic: {
                                    pattern: /<[\s\S]+/,
                                    // everything after the first <
                                    alias: "class-name",
                                    inside: t
                                }
                            }
                        }
                    });
                    e.languages.ts = e.languages.typescript;
                })(a);
                (function(e) {
                    var t = e.util.clone(e.languages.typescript);
                    e.languages.tsx = e.languages.extend("jsx", t);
                    // doesn't work with TS because TS is too complex
                                        delete e.languages.tsx["parameter"];
                    delete e.languages.tsx["literal-property"];
                    // This will prevent collisions between TSX tags and TS generic types.
                    // Idea by https://github.com/karlhorky
                    // Discussion: https://github.com/PrismJS/prism/issues/2594#issuecomment-710666928
                                        var n = e.languages.tsx.tag;
                    n.pattern = RegExp(/(^|[^\w$]|(?=<\/))/.source + "(?:" + n.pattern.source + ")", n.pattern.flags);
                    n.lookbehind = true;
                })(a);
                (function(e) {
                    var t = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
                    e.languages.css = {
                        comment: /\/\*[\s\S]*?\*\//,
                        atrule: {
                            pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + t.source + ")*?" + /(?:;|(?=\s*\{))/.source),
                            inside: {
                                rule: /^@[\w-]+/,
                                "selector-function-argument": {
                                    pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
                                    lookbehind: true,
                                    alias: "selector"
                                },
                                keyword: {
                                    pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
                                    lookbehind: true
                                }
                            }
                        },
                        url: {
                            // https://drafts.csswg.org/css-values-3/#urls
                            pattern: RegExp("\\burl\\((?:" + t.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
                            greedy: true,
                            inside: {
                                function: /^url/i,
                                punctuation: /^\(|\)$/,
                                string: {
                                    pattern: RegExp("^" + t.source + "$"),
                                    alias: "url"
                                }
                            }
                        },
                        selector: {
                            pattern: RegExp("(^|[{}\\s])[^{}\\s](?:[^{};\"'\\s]|\\s+(?![\\s{])|" + t.source + ")*(?=\\s*\\{)"),
                            lookbehind: true
                        },
                        string: {
                            pattern: t,
                            greedy: true
                        },
                        property: {
                            pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
                            lookbehind: true
                        },
                        important: /!important\b/i,
                        function: {
                            pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
                            lookbehind: true
                        },
                        punctuation: /[(){};:,]/
                    };
                    e.languages.css["atrule"].inside.rest = e.languages.css;
                    var n = e.languages.markup;
                    if (n) {
                        n.tag.addInlined("style", "css");
                        n.tag.addAttribute("style", "css");
                    }
                })(a);
                (function(e) {
                    // $ set | grep '^[A-Z][^[:space:]]*=' | cut -d= -f1 | tr '\n' '|'
                    // + LC_ALL, RANDOM, REPLY, SECONDS.
                    // + make sure PS1..4 are here as they are not always set,
                    // - some useless things.
                    var t = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
                    var n = {
                        pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
                        lookbehind: true,
                        alias: "punctuation",
                        // this looks reasonably well in all themes
                        inside: null
                    };
                    var r = {
                        bash: n,
                        environment: {
                            pattern: RegExp("\\$" + t),
                            alias: "constant"
                        },
                        variable: [ 
                        // [0]: Arithmetic Environment
                        {
                            pattern: /\$?\(\([\s\S]+?\)\)/,
                            greedy: true,
                            inside: {
                                // If there is a $ sign at the beginning highlight $(( and )) as variable
                                variable: [ {
                                    pattern: /(^\$\(\([\s\S]+)\)\)/,
                                    lookbehind: true
                                }, /^\$\(\(/ ],
                                number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
                                // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
                                operator: /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
                                // If there is no $ sign at the beginning highlight (( and )) as punctuation
                                punctuation: /\(\(?|\)\)?|,|;/
                            }
                        }, 
                        // [1]: Command Substitution
                        {
                            pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
                            greedy: true,
                            inside: {
                                variable: /^\$\(|^`|\)$|`$/
                            }
                        }, 
                        // [2]: Brace expansion
                        {
                            pattern: /\$\{[^}]+\}/,
                            greedy: true,
                            inside: {
                                operator: /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
                                punctuation: /[\[\]]/,
                                environment: {
                                    pattern: RegExp("(\\{)" + t),
                                    lookbehind: true,
                                    alias: "constant"
                                }
                            }
                        }, /\$(?:\w+|[#?*!@$])/ ],
                        // Escape sequences from echo and printf's manuals, and escaped quotes.
                        entity: /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
                    };
                    e.languages.bash = {
                        shebang: {
                            pattern: /^#!\s*\/.*/,
                            alias: "important"
                        },
                        comment: {
                            pattern: /(^|[^"{\\$])#.*/,
                            lookbehind: true
                        },
                        "function-name": [ 
                        // a) function foo {
                        // b) foo() {
                        // c) function foo() {
                        // but not “foo {”
                        {
                            // a) and c)
                            pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
                            lookbehind: true,
                            alias: "function"
                        }, {
                            // b)
                            pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
                            alias: "function"
                        } ],
                        // Highlight variable names as variables in for and select beginnings.
                        "for-or-select": {
                            pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
                            alias: "variable",
                            lookbehind: true
                        },
                        // Highlight variable names as variables in the left-hand part
                        // of assignments (“=” and “+=”).
                        "assign-left": {
                            pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
                            inside: {
                                environment: {
                                    pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + t),
                                    lookbehind: true,
                                    alias: "constant"
                                }
                            },
                            alias: "variable",
                            lookbehind: true
                        },
                        // Highlight parameter names as variables
                        parameter: {
                            pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,
                            alias: "variable",
                            lookbehind: true
                        },
                        string: [ 
                        // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
                        {
                            pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
                            lookbehind: true,
                            greedy: true,
                            inside: r
                        }, 
                        // Here-document with quotes around the tag
                        // → No expansion (so no “inside”).
                        {
                            pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
                            lookbehind: true,
                            greedy: true,
                            inside: {
                                bash: n
                            }
                        }, 
                        // “Normal” string
                        {
                            // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
                            pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
                            lookbehind: true,
                            greedy: true,
                            inside: r
                        }, {
                            // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
                            pattern: /(^|[^$\\])'[^']*'/,
                            lookbehind: true,
                            greedy: true
                        }, {
                            // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
                            pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
                            greedy: true,
                            inside: {
                                entity: r.entity
                            }
                        } ],
                        environment: {
                            pattern: RegExp("\\$?" + t),
                            alias: "constant"
                        },
                        variable: r.variable,
                        function: {
                            pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
                            lookbehind: true
                        },
                        keyword: {
                            pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
                            lookbehind: true
                        },
                        // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
                        builtin: {
                            pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
                            lookbehind: true,
                            // Alias added to make those easier to distinguish from strings.
                            alias: "class-name"
                        },
                        boolean: {
                            pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
                            lookbehind: true
                        },
                        "file-descriptor": {
                            pattern: /\B&\d\b/,
                            alias: "important"
                        },
                        operator: {
                            // Lots of redirections here, but not just that.
                            pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
                            inside: {
                                "file-descriptor": {
                                    pattern: /^\d/,
                                    alias: "important"
                                }
                            }
                        },
                        punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
                        number: {
                            pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
                            lookbehind: true
                        }
                    };
                    n.inside = e.languages.bash;
                    /* Patterns in command substitution. */                    var a = [ "comment", "function-name", "for-or-select", "assign-left", "parameter", "string", "environment", "function", "keyword", "builtin", "boolean", "file-descriptor", "operator", "punctuation", "number" ];
                    var s = r.variable[1].inside;
                    for (var i = 0; i < a.length; i++) {
                        s[a[i]] = e.languages.bash[a[i]];
                    }
                    e.languages.sh = e.languages.bash;
                    e.languages.shell = e.languages.bash;
                })(a);
                (function(e) {
                    // https://yaml.org/spec/1.2/spec.html#c-ns-anchor-property
                    // https://yaml.org/spec/1.2/spec.html#c-ns-alias-node
                    var t = /[*&][^\s[\]{},]+/;
                    // https://yaml.org/spec/1.2/spec.html#c-ns-tag-property
                                        var n = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/;
                    // https://yaml.org/spec/1.2/spec.html#c-ns-properties(n,c)
                                        var r = "(?:" + n.source + "(?:[ \t]+" + t.source + ")?|" + t.source + "(?:[ \t]+" + n.source + ")?)";
                    // https://yaml.org/spec/1.2/spec.html#ns-plain(n,c)
                    // This is a simplified version that doesn't support "#" and multiline keys
                    // All these long scarry character classes are simplified versions of YAML's characters
                                        var a = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, (function() {
                        return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
                    }));
                    var s = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
                    /**
	 *
	 * @param {string} value
	 * @param {string} [flags]
	 * @returns {RegExp}
	 */                    function i(e, t) {
                        t = (t || "").replace(/m/g, "") + "m";
 // add m flag
                                                var n = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, (function() {
                            return r;
                        })).replace(/<<value>>/g, (function() {
                            return e;
                        }));
                        return RegExp(n, t);
                    }
                    e.languages.yaml = {
                        scalar: {
                            pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, (function() {
                                return r;
                            }))),
                            lookbehind: true,
                            alias: "string"
                        },
                        comment: /#.*/,
                        key: {
                            pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, (function() {
                                return r;
                            })).replace(/<<key>>/g, (function() {
                                return "(?:" + a + "|" + s + ")";
                            }))),
                            lookbehind: true,
                            greedy: true,
                            alias: "atrule"
                        },
                        directive: {
                            pattern: /(^[ \t]*)%.+/m,
                            lookbehind: true,
                            alias: "important"
                        },
                        datetime: {
                            pattern: i(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source),
                            lookbehind: true,
                            alias: "number"
                        },
                        boolean: {
                            pattern: i(/false|true/.source, "i"),
                            lookbehind: true,
                            alias: "important"
                        },
                        null: {
                            pattern: i(/null|~/.source, "i"),
                            lookbehind: true,
                            alias: "important"
                        },
                        string: {
                            pattern: i(s),
                            lookbehind: true,
                            greedy: true
                        },
                        number: {
                            pattern: i(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"),
                            lookbehind: true
                        },
                        tag: n,
                        important: t,
                        punctuation: /---|[:[\]{}\-,|>?]|\.\.\./
                    };
                    e.languages.yml = e.languages.yaml;
                })(a);
                a.languages["splunk-spl"] = {
                    comment: /`comment\("(?:\\.|[^\\"])*"\)`/,
                    string: {
                        pattern: /"(?:\\.|[^\\"])*"/,
                        greedy: true
                    },
                    // https://docs.splunk.com/Documentation/Splunk/7.3.0/SearchReference/ListOfSearchCommands
                    keyword: /\b(?:abstract|accum|addcoltotals|addinfo|addtotals|analyzefields|anomalies|anomalousvalue|anomalydetection|append|appendcols|appendcsv|appendlookup|appendpipe|arules|associate|audit|autoregress|bin|bucket|bucketdir|chart|cluster|cofilter|collect|concurrency|contingency|convert|correlate|datamodel|dbinspect|dedup|delete|delta|diff|erex|eval|eventcount|eventstats|extract|fieldformat|fields|fieldsummary|filldown|fillnull|findtypes|folderize|foreach|format|from|gauge|gentimes|geom|geomfilter|geostats|head|highlight|history|iconify|input|inputcsv|inputlookup|iplocation|join|kmeans|kv|kvform|loadjob|localize|localop|lookup|makecontinuous|makemv|makeresults|map|mcollect|metadata|metasearch|meventcollect|mstats|multikv|multisearch|mvcombine|mvexpand|nomv|outlier|outputcsv|outputlookup|outputtext|overlap|pivot|predict|rangemap|rare|regex|relevancy|reltime|rename|replace|rest|return|reverse|rex|rtorder|run|savedsearch|script|scrub|search|searchtxn|selfjoin|sendemail|set|setfields|sichart|sirare|sistats|sitimechart|sitop|sort|spath|stats|strcat|streamstats|table|tags|tail|timechart|timewrap|top|transaction|transpose|trendline|tscollect|tstats|typeahead|typelearner|typer|union|uniq|untable|where|x11|xmlkv|xmlunescape|xpath|xyseries)\b/i,
                    "operator-word": {
                        pattern: /\b(?:and|as|by|not|or|xor)\b/i,
                        alias: "operator"
                    },
                    function: /\b\w+(?=\s*\()/,
                    property: /\b\w+(?=\s*=(?!=))/,
                    date: {
                        // MM/DD/YYYY(:HH:MM:SS)?
                        pattern: /\b\d{1,2}\/\d{1,2}\/\d{1,4}(?:(?::\d{1,2}){3})?\b/,
                        alias: "number"
                    },
                    number: /\b\d+(?:\.\d+)?\b/,
                    boolean: /\b(?:f|false|t|true)\b/i,
                    operator: /[<>=]=?|[-+*/%|]/,
                    punctuation: /[()[\],]/
                };
                a.languages.sql = {
                    comment: {
                        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
                        lookbehind: true
                    },
                    variable: [ {
                        pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
                        greedy: true
                    }, /@[\w.$]+/ ],
                    string: {
                        pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
                        greedy: true,
                        lookbehind: true
                    },
                    identifier: {
                        pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
                        greedy: true,
                        lookbehind: true,
                        inside: {
                            punctuation: /^`|`$/
                        }
                    },
                    function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
                    // Should we highlight user defined functions too?
                    keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
                    boolean: /\b(?:FALSE|NULL|TRUE)\b/i,
                    number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
                    operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
                    punctuation: /[;[\]()`,.]/
                };
            })();
            /***/        },
        /***/ 9497: 
        /***/ e => {
            "use strict";
            e.exports = require("react");
            /***/
            /******/        }
    };
    /************************************************************************/
    /******/ // The module cache
    /******/    var t = {};
    /******/
    /******/ // The require function
    /******/    function n(r) {
        /******/ // Check if module is in cache
        /******/ var a = t[r];
        /******/        if (a !== undefined) {
            /******/ return a.exports;
            /******/        }
        /******/ // Create a new module (and put it into the cache)
        /******/        var s = t[r] = {
            /******/ // no module.id needed
            /******/ // no module.loaded needed
            /******/ exports: {}
            /******/        };
        /******/
        /******/ // Execute the module function
        /******/        e[r](s, s.exports, n);
        /******/
        /******/ // Return the exports of the module
        /******/        return s.exports;
        /******/    }
    /******/
    /************************************************************************/
    /******/ /* webpack/runtime/compat get default export */
    /******/    (() => {
        /******/ // getDefaultExport function for compatibility with non-harmony modules
        /******/ n.n = e => {
            /******/ var t = e && e.__esModule ? 
            /******/ () => e["default"]
            /******/ : () => e
            /******/;
            n.d(t, {
                a: t
            });
            /******/            return t;
            /******/        };
        /******/    })();
    /******/
    /******/ /* webpack/runtime/define property getters */
    /******/    (() => {
        /******/ // define getter functions for harmony exports
        /******/ n.d = (e, t) => {
            /******/ for (var r in t) {
                /******/ if (n.o(t, r) && !n.o(e, r)) {
                    /******/ Object.defineProperty(e, r, {
                        enumerable: true,
                        get: t[r]
                    });
                    /******/                }
                /******/            }
            /******/        };
        /******/    })();
    /******/
    /******/ /* webpack/runtime/hasOwnProperty shorthand */
    /******/    (() => {
        /******/ n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t)
        /******/;
    })();
    /******/
    /******/ /* webpack/runtime/make namespace object */
    /******/    (() => {
        /******/ // define __esModule on exports
        /******/ n.r = e => {
            /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                /******/ Object.defineProperty(e, Symbol.toStringTag, {
                    value: "Module"
                });
                /******/            }
            /******/            Object.defineProperty(e, "__esModule", {
                value: true
            });
            /******/        };
        /******/    })();
    /******/
    /************************************************************************/    var r = {};
    // This entry need to be wrapped in an IIFE because it need to be in strict mode.
        (() => {
        "use strict";
        // ESM COMPAT FLAG
                n.r(r);
        // EXPORTS
                n.d(r, {
            default: () => /* reexport */ X
        });
        // EXTERNAL MODULE: external "react"
                var e = n(9497);
        var t =  n.n(e);
        // CONCATENATED MODULE: external "prop-types"
        const a = require("prop-types");
        var s =  n.n(a);
        // CONCATENATED MODULE: external "lodash/castArray"
        const i = require("lodash/castArray");
        var o =  n.n(i);
        // CONCATENATED MODULE: external "lodash/flatten"
        const l = require("lodash/flatten");
        var u =  n.n(l);
        // CONCATENATED MODULE: external "lodash/indexOf"
        const c = require("lodash/indexOf");
        var p =  n.n(c);
        // CONCATENATED MODULE: external "lodash/repeat"
        const d = require("lodash/repeat");
        var g =  n.n(d);
        // CONCATENATED MODULE: external "lodash/times"
        const f = require("lodash/times");
        var E =  n.n(f);
        // EXTERNAL MODULE: ./src/Code/prism/prism.empty
                var m = n(74);
        var h =  n.n(m);
        // CONCATENATED MODULE: external "styled-components"
        const v = require("styled-components");
        var b =  n.n(v);
        // CONCATENATED MODULE: external "@splunk/themes"
        const S = require("@splunk/themes");
        // CONCATENATED MODULE: ./src/Code/CodeStyles.ts
        var y = b().pre.withConfig({
            displayName: "CodeStyles__Styled",
            componentId: "sc-1eq4k68-0"
        })([ "", ";", " line-height:", ";text-align:left;tab-size:4;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;hyphens:none;overflow-x:auto;margin-bottom:1.3em;&:focus-visible{outline:solid ", ";}" ], S.mixins.reset("block"), (0, 
        S.pick)({
            enterprise: {
                dark: (0, v.css)([ "color:", ";" ], S.variables.gray92)
            }
        }), (0, S.pick)({
            enterprise: "17px",
            prisma: S.variables.lineHeight
        }), S.variables.focusColor);
        var A = b().code.withConfig({
            displayName: "CodeStyles__StyledCode",
            componentId: "sc-1eq4k68-1"
        })([ "font-family:", ";" ], S.variables.monoFontFamily);
        var T = b().span.withConfig({
            displayName: "CodeStyles__StyledIndent",
            componentId: "sc-1eq4k68-2"
        })([ "&:not(:last-child){background-image:linear-gradient( to left,rgba(0,0,0,0.15) 1px,transparent 1px,transparent );}" ]);
        var I = (0, S.pick)({
            prisma: S.variables.syntaxGray,
            enterprise: {
                dark: S.variables.gray60,
                light: S.variables.syntaxGray
            }
        });
        var O = (0, S.pick)({
            prisma: S.variables.syntaxPurple,
            enterprise: {
                dark: S.variables.syntaxPurpleLight,
                light: S.variables.syntaxPurple
            }
        });
        var R = (0, S.pick)({
            prisma: S.variables.syntaxGreen,
            enterprise: {
                dark: S.variables.syntaxGreenLight,
                light: S.variables.syntaxGreen
            }
        });
        var N = S.variables.syntaxBlue;
        var k = S.variables.syntaxRed;
        var x = {
            comment: I,
            prolog: I,
            doctype: I,
            cdata: I,
            punctuation: I,
            property: O,
            tag: O,
            boolean: O,
            number: O,
            constant: O,
            symbol: O,
            deleted: O,
            key: O,
            selector: R,
            "attr-name": R,
            string: R,
            char: R,
            builtin: R,
            inserted: R,
            operator: S.variables.syntaxBrown,
            entity: S.variables.syntaxBrown,
            url: S.variables.syntaxBrown,
            atrule: N,
            "attr-value": N,
            keyword: N,
            function: k,
            regex: S.variables.syntaxOrange,
            important: S.variables.syntaxOrange,
            variable: S.variables.syntaxOrange
        };
        var L = b().span.withConfig({
            displayName: "CodeStyles__StyledToken",
            componentId: "sc-1eq4k68-3"
        })([ "color:", ";cursor:", ";opacity:", ";font-style:", ";font-weight:", ";" ], (function(e) {
            var t = e.partType;
            return x[t];
        }), (function(e) {
            var t = e.partType;
            return t === "entity" ? "help" : null;
        }), (function(e) {
            var t = e.partType;
            return t === "namespace" ? .7 : null;
        }), (function(e) {
            var t = e.partType;
            return t === "italic" ? "italic" : null;
        }), (function(e) {
            var t = e.partType;
            return t === "important" || t === "bold" ? "bold" : null;
        }));
        // CONCATENATED MODULE: ./src/utils/updateReactRef.ts
        /**
 * Updates a React ref. Callback refs and object refs (from `createRef` and `useRef`) are supported.
 *
 * @param ref - The React callback or object ref. Can be `null` or `undefined`.
 * @param current - The new value of the ref.
 */
        function F(e, t) {
            if (e) {
                if (typeof e === "function") {
                    e(t);
                } else {
                    // the public signature of this util uses React.Ref<T> to mirror the way React types refs.
                    // the intention here is to signal "we will take care of setting 'current', not you".
                    e.current = t;
 // eslint-disable-line no-param-reassign
                                }
            }
        }
        // EXTERNAL MODULE: ./src/useResizeObserver/index.ts + 1 modules
                var C = n(6283);
        // CONCATENATED MODULE: ./src/Code/Code.tsx
        function w() {
            return w = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = arguments[t];
                    for (var r in n) {
                        ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
                    }
                }
                return e;
            }, w.apply(null, arguments);
        }
        function D(e, t) {
            return $(e) || M(e, t) || _(e, t) || P();
        }
        function P() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _(e, t) {
            if (e) {
                if ("string" == typeof e) return U(e, t);
                var n = {}.toString.call(e).slice(8, -1);
                return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? U(e, t) : void 0;
            }
        }
        function U(e, t) {
            (null == t || t > e.length) && (t = e.length);
            for (var n = 0, r = Array(t); n < t; n++) {
                r[n] = e[n];
            }
            return r;
        }
        function M(e, t) {
            var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
            if (null != n) {
                var r, a, s, i, o = [], l = !0, u = !1;
                try {
                    if (s = (n = n.call(e)).next, 0 === t) {
                        if (Object(n) !== n) return;
                        l = !1;
                    } else for (;!(l = (r = s.call(n)).done) && (o.push(r.value), o.length !== t); l = !0) {
                    }
                } catch (e) {
                    u = !0, a = e;
                } finally {
                    try {
                        if (!l && null != n["return"] && (i = n["return"](), Object(i) !== i)) return;
                    } finally {
                        if (u) throw a;
                    }
                }
                return o;
            }
        }
        function $(e) {
            if (Array.isArray(e)) return e;
        }
        function B(e, t) {
            if (null == e) return {};
            var n, r, a = G(e, t);
            if (Object.getOwnPropertySymbols) {
                var s = Object.getOwnPropertySymbols(e);
                for (r = 0; r < s.length; r++) {
                    n = s[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (a[n] = e[n]);
                }
            }
            return a;
        }
        function G(e, t) {
            if (null == e) return {};
            var n = {};
            for (var r in e) {
                if ({}.hasOwnProperty.call(e, r)) {
                    if (t.includes(r)) continue;
                    n[r] = e[r];
                }
            }
            return n;
        }
        // Prism requires special handling to work around issues related to global scope and
        // auto formatting. The import below points to an empty file which is replaced at build
        // time, see ./prism/build-isolated-prism.js for details.
        // typed as 'prismjs'
                var j = [ "bash", "clike", "css", "html", "json", "javascript", "js", "jsx", "typescript", "ts", "tsx", "markup", "mathml", "plain", "plaintext", "splunk-spl", "sql", "svg", "text", "txt", "xml", "yaml", "yml" ];
        function H(e, t) {
            if ([ "plain", "plaintext", "text", "txt" ].indexOf(t) >= 0) {
                return h().tokenize(e, {});
            }
            return h().tokenize(e, h().languages[t]);
        }
        var Y = {
            elementRef: s().oneOfType([ s().func, s().object ]),
            indentChars: s().number,
            language: s().oneOf(j),
            languageFallback: s().oneOf(j),
            showIndentGuide: s().bool,
            value: s().string
        };
        function z(n) {
            var r = n.elementRef, a = n.indentChars, s = a === void 0 ? 4 : a, i = n.language, l = n.languageFallback, c = l === void 0 ? "javascript" : l, d = n.showIndentGuide, f = d === void 0 ? true : d, m = n.value, h = m === void 0 ? "" : m, v = B(n, [ "elementRef", "indentChars", "language", "languageFallback", "showIndentGuide", "value" ]);
            // @docs-props-type CodePropsBase
                        var b = (0, e.useRef)(null);
            var S = (0, e.useState)(undefined), I = D(S, 2), O = I[0], R = I[1];
            var N = (0, C["default"])(b), k = N.width, x = N.height;
            var P = (0, e.useCallback)((function(e) {
                F(b, e);
                F(r, e);
            }), [ r ]);
            (0, e.useEffect)((function() {
                var e = b.current;
                if (e) {
                    var t = e.scrollHeight > Math.round(x);
                    var n = e.scrollWidth > Math.round(k);
                    var r = t || n;
                    R(r ? 0 : undefined);
                }
            }), [ b, k, x ]);
            var _ = g()(" ", s);
            var U = function e(n) {
                var r = Math.floor(n / s);
                var a = n % s;
                var i = E()(r, (function(e) {
                    
                    return t().createElement(T, {
                        key: e.toString()
                    }, _);
                }));
                if (a) {
                    i.push(g()(" ", a));
                }
                return i;
            };
            var M = p()(j, i) > -1;
            (0, e.useEffect)((function() {
                // a fix for SUI-5425, where the Markdown component doesn't pass a valid language in some circumstances
                if (false) {}
            }), [ M, i, c ]);
            var $ = M && i ? i : c;
            var G = H(h, $);
            var Y = function e(n) {
                return o()(n).map((function(n, r) {
                    if (typeof n === "string") {
                        if (!f) {
                            return n;
                        }
                        var a = n.split("\n");
                        if (a.length === 1) {
                            return n;
                        }
                        return u()(a.map((function(e, n) {
                            var a = n === 0 ? [] : [ "\n" ];
                            var s = e.match(/^(\s+)(.*)/);
                            if (!s) {
                                a.push(e);
                            } else {
                                a.push( t().createElement("span", {
                                    key: "".concat(r.toString(), ":").concat(n.toString())
                                }, U(s[1].length)), s[2]);
                            }
                            return a;
                        })));
                    }
                    var s = typeof n.content === "string" ? n.content : e(n.content);
                    
                    // eslint-disable-next-line react/no-array-index-key
                    return t().createElement(L, {
                        "data-part-type": n.type,
                        partType: n.type,
                        key: r.toString()
                    }, s);
                }));
            };
            var z = Y(G);
            
            return t().createElement(y, w({
                "data-test": "code",
                ref: P,
                tabIndex: O
            }, v),  t().createElement(A, {
                className: "language-".concat($)
            }, z));
        }
        z.propTypes = Y;
        /* harmony default export */        const X = z;
    }) // CONCATENATED MODULE: ./src/Code/index.ts
    ();
    module.exports = r;
    /******/})();