/******/ (() => {
    // webpackBootstrap
    /******/ "use strict";
    /******/    var e = {
        /***/ 6165: 
        /***/ (e, t, r) => {
            // EXPORTS
            r.d(t, {
                default: () => /* reexport */ y
            });
            // EXTERNAL MODULE: external "react"
                        var n = r(9497);
            var o =  r.n(n);
            // EXTERNAL MODULE: external "prop-types"
                        var i = r(23);
            var l =  r.n(i);
            // EXTERNAL MODULE: external "styled-components"
                        var a = r(232);
            var u =  r.n(a);
            // EXTERNAL MODULE: external "@splunk/themes"
                        var c = r(3563);
            // CONCATENATED MODULE: ./src/ScreenReaderContent/ScreenReaderContentStyles.ts
            var s = u().span.withConfig({
                displayName: "ScreenReaderContentStyles__Styled",
                componentId: "sc-1lnohwp-0"
            })([ "", ";" ], c.mixins.screenReaderContent());
            // CONCATENATED MODULE: ./src/ScreenReaderContent/ScreenReaderContent.tsx
            function f() {
                return f = Object.assign ? Object.assign.bind() : function(e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var r = arguments[t];
                        for (var n in r) {
                            ({}).hasOwnProperty.call(r, n) && (e[n] = r[n]);
                        }
                    }
                    return e;
                }, f.apply(null, arguments);
            }
            function d(e, t) {
                if (null == e) return {};
                var r, n, o = v(e, t);
                if (Object.getOwnPropertySymbols) {
                    var i = Object.getOwnPropertySymbols(e);
                    for (n = 0; n < i.length; n++) {
                        r = i[n], t.includes(r) || {}.propertyIsEnumerable.call(e, r) && (o[r] = e[r]);
                    }
                }
                return o;
            }
            function v(e, t) {
                if (null == e) return {};
                var r = {};
                for (var n in e) {
                    if ({}.hasOwnProperty.call(e, n)) {
                        if (t.includes(n)) continue;
                        r[n] = e[n];
                    }
                }
                return r;
            }
            var p = {
                children: l().node.isRequired,
                elementRef: l().oneOfType([ l().func, l().object ])
            };
            /**
 * The screen reader text is used to wrap content that
 * is only accessible through screen readers.
 */            function m(e) {
                var t = e.children, r = e.elementRef, n = d(e, [ "children", "elementRef" ]);
                // @docs-props-type ScreenReaderContentPropsBase
                                
                return o().createElement(s, f({
                    "data-test": "screen-reader-content",
                    ref: r
                }, n), t);
            }
            m.propTypes = p;
            /* harmony default export */            const y = m;
        } // CONCATENATED MODULE: ./src/ScreenReaderContent/index.ts
        /***/ ,
        /***/ 3563: 
        /***/ e => {
            e.exports = require("@splunk/themes");
            /***/        },
        /***/ 23: 
        /***/ e => {
            e.exports = require("prop-types");
            /***/        },
        /***/ 9497: 
        /***/ e => {
            e.exports = require("react");
            /***/        },
        /***/ 232: 
        /***/ e => {
            e.exports = require("styled-components");
            /***/
            /******/        }
    };
    /************************************************************************/
    /******/ // The module cache
    /******/    var t = {};
    /******/
    /******/ // The require function
    /******/    function r(n) {
        /******/ // Check if module is in cache
        /******/ var o = t[n];
        /******/        if (o !== undefined) {
            /******/ return o.exports;
            /******/        }
        /******/ // Create a new module (and put it into the cache)
        /******/        var i = t[n] = {
            /******/ // no module.id needed
            /******/ // no module.loaded needed
            /******/ exports: {}
            /******/        };
        /******/
        /******/ // Execute the module function
        /******/        e[n](i, i.exports, r);
        /******/
        /******/ // Return the exports of the module
        /******/        return i.exports;
        /******/    }
    /******/
    /************************************************************************/
    /******/ /* webpack/runtime/compat get default export */
    /******/    (() => {
        /******/ // getDefaultExport function for compatibility with non-harmony modules
        /******/ r.n = e => {
            /******/ var t = e && e.__esModule ? 
            /******/ () => e["default"]
            /******/ : () => e
            /******/;
            r.d(t, {
                a: t
            });
            /******/            return t;
            /******/        };
        /******/    })();
    /******/
    /******/ /* webpack/runtime/define property getters */
    /******/    (() => {
        /******/ // define getter functions for harmony exports
        /******/ r.d = (e, t) => {
            /******/ for (var n in t) {
                /******/ if (r.o(t, n) && !r.o(e, n)) {
                    /******/ Object.defineProperty(e, n, {
                        enumerable: true,
                        get: t[n]
                    });
                    /******/                }
                /******/            }
            /******/        };
        /******/    })();
    /******/
    /******/ /* webpack/runtime/hasOwnProperty shorthand */
    /******/    (() => {
        /******/ r.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t)
        /******/;
    })();
    /******/
    /******/ /* webpack/runtime/make namespace object */
    /******/    (() => {
        /******/ // define __esModule on exports
        /******/ r.r = e => {
            /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                /******/ Object.defineProperty(e, Symbol.toStringTag, {
                    value: "Module"
                });
                /******/            }
            /******/            Object.defineProperty(e, "__esModule", {
                value: true
            });
            /******/        };
        /******/    })();
    /******/
    /************************************************************************/    var n = {};
    // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
        (() => {
        // ESM COMPAT FLAG
        r.r(n);
        // EXPORTS
                r.d(n, {
            VirtualizedResultsMenu: () => /* reexport */ ze,
            default: () => /* reexport */ X
        });
        // EXTERNAL MODULE: external "react"
                var e = r(9497);
        var t =  r.n(e);
        // EXTERNAL MODULE: external "prop-types"
                var o = r(23);
        var i =  r.n(o);
        // CONCATENATED MODULE: external "lodash/keys"
        const l = require("lodash/keys");
        var a =  r.n(l);
        // CONCATENATED MODULE: external "lodash/memoize"
        const u = require("lodash/memoize");
        var c =  r.n(u);
        // CONCATENATED MODULE: external "lodash/omit"
        const s = require("lodash/omit");
        var f =  r.n(s);
        // CONCATENATED MODULE: external "@splunk/ui-utils/i18n"
        const d = require("@splunk/ui-utils/i18n");
        // CONCATENATED MODULE: external "@splunk/ui-utils/userAgent"
        const v = require("@splunk/ui-utils/userAgent");
        // CONCATENATED MODULE: external "@splunk/react-ui/Menu"
        const p = require("@splunk/react-ui/Menu");
        var m =  r.n(p);
        // EXTERNAL MODULE: external "styled-components"
                var y = r(232);
        var b =  r.n(y);
        // CONCATENATED MODULE: external "@splunk/react-ui/WaitSpinner"
        const h = require("@splunk/react-ui/WaitSpinner");
        var g =  r.n(h);
        // EXTERNAL MODULE: external "@splunk/themes"
                var S = r(3563);
        // CONCATENATED MODULE: ./src/ResultsMenu/ResultsMenuStyles.ts
        var E = b().div.withConfig({
            displayName: "ResultsMenuStyles__Styled",
            componentId: "avbhl8-0"
        })([ "", ";flex-direction:column;max-height:calc(100vh - 20px);", "" ], S.mixins.reset("flex"), (0, 
        S.pick)({
            prisma: (0, y.css)([ "border-radius:", ";background-color:", ";" ], S.variables.borderRadius, S.variables.backgroundColorPopup)
        }));
        var O = b().div.withConfig({
            displayName: "ResultsMenuStyles__StyledFooter",
            componentId: "avbhl8-1"
        })([ "padding:", ";color:", ";", "" ], (0, S.pick)({
            prisma: {
                comfortable: "10px 16px",
                compact: "6px 16px"
            },
            enterprise: "6px 10px"
        }), (0, S.pick)({
            prisma: S.variables.contentColorMuted,
            enterprise: S.variables.textGray
        }), (function(e) {
            var t = e.$placement;
            return t === "above" ? (0, S.pick)({
                prisma: (0, y.css)([ "border-bottom:1px solid ", ";" ], S.variables.neutral200),
                enterprise: (0, y.css)([ "border-bottom:", ";" ], S.variables.border)
            }) : (0, S.pick)({
                prisma: (0, y.css)([ "border-top:1px solid ", ";" ], S.variables.neutral200),
                enterprise: (0, y.css)([ "border-top:", ";" ], S.variables.border)
            });
        }));
        var w = b().li.withConfig({
            displayName: "ResultsMenuStyles__StyledLoading",
            componentId: "avbhl8-2"
        })([ "", ";padding:", ";gap:", ";" ], S.mixins.reset("flex"), (0, S.pick)({
            prisma: {
                comfortable: "10px 16px",
                compact: "6px 16px"
            },
            enterprise: "6px 10px"
        }), S.variables.spacingXSmall);
        var M = b()(m()).withConfig({
            displayName: "ResultsMenuStyles__StyledMenu",
            componentId: "avbhl8-3"
        })([ "overflow:auto;flex-direction:column;", "" ], (function(e) {
            var t = e.$removeBottomRadius;
            return t && (0, y.css)([ "border-bottom-left-radius:0;border-bottom-right-radius:0;" ]);
        }));
        var x = b()(m().Item).withConfig({
            displayName: "ResultsMenuStyles__StyledNoOptions",
            componentId: "avbhl8-4"
        })([ "&[disabled],&[aria-disabled='true']{color:", ";}" ], S.variables.contentColorDefault);
        var j = b()(g()).withConfig({
            displayName: "ResultsMenuStyles__StyledWait",
            componentId: "avbhl8-5"
        })([ "flex:0 0 auto;" ]);
        var k = b().div.withConfig({
            displayName: "ResultsMenuStyles__StyledLoadingMessage",
            componentId: "avbhl8-6"
        })([ "flex:1 0 0;color:", ";" ], (0, S.pick)({
            prisma: S.variables.contentColorMuted,
            enterprise: S.variables.textGray
        }));
        // CONCATENATED MODULE: ./src/utils/updateReactRef.ts
        /**
 * Updates a React ref. Callback refs and object refs (from `createRef` and `useRef`) are supported.
 *
 * @param ref - The React callback or object ref. Can be `null` or `undefined`.
 * @param current - The new value of the ref.
 */
        function P(e, t) {
            if (e) {
                if (typeof e === "function") {
                    e(t);
                } else {
                    // the public signature of this util uses React.Ref<T> to mirror the way React types refs.
                    // the intention here is to signal "we will take care of setting 'current', not you".
                    e.current = t;
 // eslint-disable-line no-param-reassign
                                }
            }
        }
        // EXTERNAL MODULE: ./src/ScreenReaderContent/index.ts + 2 modules
                var T = r(6165);
        // CONCATENATED MODULE: ./src/ResultsMenu/ResultsMenu.tsx
        function R(e) {
            "@babel/helpers - typeof";
            return R = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e;
            } : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
            }, R(e);
        }
        function I() {
            return I = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = arguments[t];
                    for (var n in r) {
                        ({}).hasOwnProperty.call(r, n) && (e[n] = r[n]);
                    }
                }
                return e;
            }, I.apply(null, arguments);
        }
        function C(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
        }
        function A(e, t) {
            for (var r = 0; r < t.length; r++) {
                var n = t[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(e, z(n.key), n);
            }
        }
        function _(e, t, r) {
            return t && A(e.prototype, t), r && A(e, r), Object.defineProperty(e, "prototype", {
                writable: !1
            }), e;
        }
        function L(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    writable: !0,
                    configurable: !0
                }
            }), Object.defineProperty(e, "prototype", {
                writable: !1
            }), t && B(e, t);
        }
        function B(e, t) {
            return B = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                return e.__proto__ = t, e;
            }, B(e, t);
        }
        function q(e) {
            var t = H();
            return function() {
                var r, n = D(e);
                if (t) {
                    var o = D(this).constructor;
                    r = Reflect.construct(n, arguments, o);
                } else r = n.apply(this, arguments);
                return N(this, r);
            };
        }
        function N(e, t) {
            if (t && ("object" == R(t) || "function" == typeof t)) return t;
            if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
            return F(e);
        }
        function F(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e;
        }
        function H() {
            try {
                var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
            } catch (e) {}
            return (H = function t() {
                return !!e;
            })();
        }
        function D(e) {
            return D = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
                return e.__proto__ || Object.getPrototypeOf(e);
            }, D(e);
        }
        function U(e, t, r) {
            return (t = z(t)) in e ? Object.defineProperty(e, t, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = r, e;
        }
        function z(e) {
            var t = V(e, "string");
            return "symbol" == R(t) ? t : t + "";
        }
        function V(e, t) {
            if ("object" != R(e) || !e) return e;
            var r = e[Symbol.toPrimitive];
            if (void 0 !== r) {
                var n = r.call(e, t || "default");
                if ("object" != R(n)) return n;
                throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t ? String : Number)(e);
        }
        var $ = {
            animateLoading: i().bool,
            children: i().node,
            childrenStart: i().node,
            elementRef: i().oneOfType([ i().func, i().object ]),
            focusMode: i().oneOf([ "roving", "normal", "never" ]),
            footerMessage: i().node,
            isLoading: i().bool,
            loadingMessage: i().node,
            noOptionsMessage: i().node,
            onScroll: i().func,
            onScrollBottom: i().func,
            placement: i().string,
            menuId: i().string
        };
        var W = {
            animateLoading: false,
            isLoading: false,
            loadingMessage: (0, d._)("Loading..."),
            noOptionsMessage: (0, d._)("No matches")
        };
        var K = c()((function(e) {
            return {
                height: e
            };
        }));
        // @docs-props-type ResultsMenuPropsBase
                var G =  function(r) {
            L(o, r);
            var n = q(o);
            function o(t) {
                var r;
                C(this, o);
                r = n.call(this, t);
                U(F(r), "scrollBottomOffset", void 0);
                U(F(r), "itemMinHeight", void 0);
                U(F(r), "handleMenuMount", (function(e) {
                    r.setState({
                        menuEl: e
                    });
                }));
                U(F(r), "handleMount", (function(e) {
                    r.setState({
                        containerEl: e
                    });
                    P(r.props.elementRef, e);
                }));
                U(F(r), "handleMouseEnter", (function() {
                    r.setState({
                        windowTop: document.documentElement.scrollTop
                    });
                }));
                U(F(r), "handleMouseLeave", (function() {
                    r.setState({
                        windowTop: document.documentElement.scrollTop
                    });
                }));
                U(F(r), "handleScroll", (function(e) {
                    var t, n;
                    if (r.props.onScrollBottom != null) {
                        if (e.target && r.state.menuEl) {
                            var o = r.state.menuEl.scrollHeight - r.state.menuEl.offsetHeight - r.scrollBottomOffset;
                            // Adding 1 due to border of menu item.
                                                        if (r.state.menuEl.scrollTop + 1 >= o) {
                                r.handleScrollBottom(e);
                            }
                        }
                    }
                    (t = (n = r.props).onScroll) === null || t === void 0 ? void 0 : t.call(n, e);
                }));
                U(F(r), "handleWheelMenu", (function(e) {
                    // Safety net to ensure window doesn't scroll if menu is scrolled pass the numberOfItemsLoaded at high velocity.
                    e.stopPropagation();
                    document.documentElement.scrollTop = r.state.windowTop;
                }));
                U(F(r), "handleScrollBottomOnFullMenu", (function() {
                    var t = e.Children.count(r.props.children);
                    var n = r.state.childrenCount;
 // If menu is full length, load more items.
                                        if (r.checkFullHeight()) {
                        r.handleScrollBottom(null);
                    }
                    // avoid triggering this logic if this.state.childrenCount is null
                    // because that's not a real change in the number of children
                    // and thus we want to avoid resetting the value of scrollBottomTriggered
                                        if (n != null && t !== n) {
                        r.setState({
                            numberOfItemsLoaded: t - (n !== null && n !== void 0 ? n : 0),
                            scrollBottomTriggered: false
                        });
                    }
                    if (t !== n) {
                        r.setState({
                            childrenCount: t
                        });
                    }
                }));
                U(F(r), "createMenuContextValue", (function() {
                    return {
                        role: "listbox",
                        preventFocus: r.props.focusMode === "never"
                    };
                }));
                r.state = {
                    containerEl: null,
                    menuEl: null,
                    numberOfItemsLoaded: 0,
                    scrollBottomTriggered: false,
                    windowTop: 0
                };
                // The remaining amount of pixels when scrolled from bottom of menu to trigger onScrollBottom().
                                r.scrollBottomOffset = 400;
                r.itemMinHeight = 28;
                return r;
            }
            _(o, [ {
                key: "componentDidUpdate",
                value: function e() {
                    var t, r;
                    var n = this.state, o = n.containerEl, i = n.menuEl;
                    if (!v.isIE11 || !o || !i) {
                        return;
                    }
                    // If onScrollBottom is defined, determine if it should be triggered.
                                        if (((t = this.props) === null || t === void 0 ? void 0 : t.onScrollBottom) && ((r = this.props) === null || r === void 0 ? void 0 : r.children)) {
                        this.handleScrollBottomOnFullMenu();
                    }
                }
            }, {
                key: "handleScrollBottom",
                value: function e(t) {
                    // Prevent multiple calls to onScrollBottom.
                    if (!this.state.scrollBottomTriggered) {
                        var r, n;
                        this.setState({
                            scrollBottomTriggered: true
                        });
                        (r = (n = this.props).onScrollBottom) === null || r === void 0 ? void 0 : r.call(n, t);
                    }
                }
            }, {
                key: "checkFullHeight",
                value: function e() {
                    var t = this.state.menuEl;
                    return t && t.scrollHeight === t.offsetHeight;
                }
            }, {
                key: "renderFooterMessage",
                value: function r() {
                    return this.props.footerMessage && !!e.Children.toArray(this.props.children).length &&  t().createElement(O, {
                        $placement: this.props.placement,
                        "data-test": "footer-message",
                        key: "footer"
                    }, this.props.footerMessage);
                }
            }, {
                key: "render",
                value: function r() {
                    var n = this.props, i = n.animateLoading, l = n.children, u = n.childrenStart, c = n.focusMode, s = n.isLoading, d = n.loadingMessage, v = n.noOptionsMessage, m = n.onScrollBottom, y = n.placement, b = n.style, h = n.tabIndex, g = n.menuId, S = n["aria-multiselectable"];
                    var O = f()(this.props, a()(o.propTypes));
                    // Assumption: that you cannot be filtered if you are a result
                                        var P = e.Children.toArray(l).filter(e.isValidElement).some((function(e) {
                        var t = e.type;
                        return !(t.as === "Divider" && t.filterFirst || (t.as === "Divider" || t.as === "Heading") && (t.filterLast || t.filterConsecutive));
                    }));
                    var R = this.checkFullHeight();
                    var C = K(this.state.scrollBottomTriggered ? this.state.numberOfItemsLoaded * this.itemMinHeight || 0 : 0);
                    var A = !P && !!v && !s;
                    /* eslint-disable jsx-a11y/aria-role */                    
                    return t().createElement(E, I({
                        "data-test": "results-menu",
                        key: "wrapper",
                        ref: this.handleMount,
                        onWheel: m ? this.handleWheelMenu : undefined,
                        onMouseEnter: m ? this.handleMouseEnter : undefined,
                        onMouseLeave: m ? this.handleMouseLeave : undefined
                    }, f()(O, "tabIndex", "aria-multiselectable", "menuId"), {
                        style: b
                    }), y !== "above" && u, y === "above" && this.renderFooterMessage(),  t().createElement(p.MenuContext.Provider, {
                        value: this.createMenuContextValue()
                    },  t().createElement(M, {
                        key: "menu",
                        elementRef: this.handleMenuMount,
                        onScroll: this.handleScroll,
                        stopScrollPropagation: true,
                        tabIndex: h,
                        "aria-multiselectable": S,
                        id: g,
                        focusMode: c,
                        $removeBottomRadius: !!this.props.footerMessage && y !== "above"
                    }, A &&  t().createElement(x, {
                        "data-test": "no-results-message",
                        disabled: true
                    }, v), l, m && !R && 
                    
                    // Bottom spacer fills in the space of new items being loaded by using the minimum possible height x menuItems.
                    t().createElement("div", {
                        "data-test": "results-menu-bottom-spacer",
                        style: C
                    }), s &&  t().createElement(w, null, i &&  t().createElement(j, null),  t().createElement(k, null, d)))),  t().createElement(T["default"], {
                        "aria-live": "polite"
                    }, A && v), y !== "above" && this.renderFooterMessage(), y === "above" && u);
                }
            } ]);
            return o;
        }(e.Component);
        U(G, "propTypes", $);
        U(G, "defaultProps", W);
        /* harmony default export */        const X = G;
        // CONCATENATED MODULE: external "@splunk/ui-utils/keyboard"
        const J = require("@splunk/ui-utils/keyboard");
        // CONCATENATED MODULE: external "@splunk/ui-utils/focus"
        const Q = require("@splunk/ui-utils/focus");
        // CONCATENATED MODULE: ./src/ResultsMenu/VirtualizedResultsMenu/groupChildren.ts
        // Cheap(er than processing potentially thousands of array elements) memoization
        var Y = {
            result: []
        };
        /**
 * Given component children, restructure them into an array of arrays, each of length `groupSize`.
 *
 * The last array is not guaranteed to be full, it will have a length in the range `[1, groupSize]`
 *
 * @example
 * ```js
 * groupChildren([1, 2, 3, 4, 5, 6, 7], 2);
 * // > [[1, 2], [3, 4], [5, 6], [7]]
 * ```
 * @param {Array} children One node, or an array of nodes, to be divided into groups
 * @param {number} groupSize The size of each group to be created
 * @returns A 2d array where each inner-array is a group of size `groupSize` of children
 * and the order of the `children` received equals the order of the flattened result
 */        var Z = function t(r, n) {
            if (Y.children === r && Y.groupSize === n) {
                return Y.result;
            }
            Y.children = r;
            Y.groupSize = n;
            if (n <= 1) {
                if (false) {}
                // don't break in non-__DEV__ and return one big group
                                Y.result = [ e.Children.toArray(r) ];
            } else {
                Y.result = e.Children.toArray(r).reduce((function(e, t, r) {
                    var o = Math.floor(r / n);
                    if (!Array.isArray(e[o])) {
                        // eslint-disable-next-line no-param-reassign
                        e[o] = [];
                    }
                    e[o].push(t);
                    return e;
                }), []);
            }
            return Y.result;
        };
        // CONCATENATED MODULE: external "@splunk/ui-utils/id"
        const ee = require("@splunk/ui-utils/id");
        // CONCATENATED MODULE: ./src/utils/getMenuChildNode.tsx
        // TODO(SUI-5919): fix the ref handling in the other components so this isn't needed
        /**
 * @private Get the HTML <anchor> or <button> node for a received derivative of Menu.Item
 */
        var te = function e(t) {
            var r, n, o, i;
            if (t.el) {
                return t.el;
 // Menu.Item
                        }
            if ((r = t.c) === null || r === void 0 ? void 0 : r.el) {
                return t.c.el;
 // Multiselect.Option
                        }
            if ((n = t.c) === null || n === void 0 ? void 0 : (o = n.c) === null || o === void 0 ? void 0 : o.el) {
                return t.c.c.el;
 // Select.Option
                        }
            if ((i = t.item) === null || i === void 0 ? void 0 : i.el) {
                return t.item.el;
 // ComboBox.Option
                        }
            return null;
        };
        // CONCATENATED MODULE: ./src/ResultsMenu/VirtualizedResultsMenu/VirtualizedItem.ts
        function re(e, t) {
            return ae(e) || le(e, t) || oe(e, t) || ne();
        }
        function ne() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function oe(e, t) {
            if (e) {
                if ("string" == typeof e) return ie(e, t);
                var r = {}.toString.call(e).slice(8, -1);
                return "Object" === r && e.constructor && (r = e.constructor.name), "Map" === r || "Set" === r ? Array.from(e) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? ie(e, t) : void 0;
            }
        }
        function ie(e, t) {
            (null == t || t > e.length) && (t = e.length);
            for (var r = 0, n = Array(t); r < t; r++) {
                n[r] = e[r];
            }
            return n;
        }
        function le(e, t) {
            var r = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
            if (null != r) {
                var n, o, i, l, a = [], u = !0, c = !1;
                try {
                    if (i = (r = r.call(e)).next, 0 === t) {
                        if (Object(r) !== r) return;
                        u = !1;
                    } else for (;!(u = (n = i.call(r)).done) && (a.push(n.value), a.length !== t); u = !0) {
                    }
                } catch (e) {
                    c = !0, o = e;
                } finally {
                    try {
                        if (!u && null != r["return"] && (l = r["return"](), Object(l) !== l)) return;
                    } finally {
                        if (c) throw o;
                    }
                }
                return a;
            }
        }
        function ae(e) {
            if (Array.isArray(e)) return e;
        }
        // This wrapper should only be used with Menu.Item/derivatives thereof, so omitting Heading/Divider is fine
                var ue = {
            children: i().node,
            onMount: i().func.isRequired,
            onUnmount: i().func.isRequired
        };
        /** @private Used by `VirtualizedResultsMenu` */        var ce =  t().forwardRef((function(t, r) {
            var n = t.children, o = t.onMount, i = t.onUnmount;
            var l = (0, e.useState)(), a = re(l, 2), u = a[0], c = a[1];
            (0, e.useEffect)((function() {
                if (u) {
                    o(u);
                }
                return function() {
                    if (u) {
                        i(u);
                    }
                };
            }), [ u, o, i ]);
            var s = e.Children.only(n);
            if (!s) {
                if (false) {}
                return null;
            }
            
            return (0, e.cloneElement)(s, {
                ref: function e(t) {
                    var n = t;
                    if (!n) {
                        return;
                    }
                    P(r, t);
                    P(c, te(n));
                }
            });
        }));
        ce.propTypes = ue;
        ce.as = "Item";
        // CONCATENATED MODULE: ./src/ResultsMenu/VirtualizedResultsMenu/injectVirtualizedItem.tsx
        /**
 * Find the index of an array element which is nearest to targetIndex and is a Menu.Item component
 * @param {Array} elements An array to search
 * @param {Number} targetIndex The target index. This is the ideal value to return.
 * @returns The index in the array of the nearest `Menu.Item` component to `targetIndex`, or -1 if no element is a `Menu.Item` component
 */
        var se = function e(t, r) {
            var n = -1;
            var o = -1;
            t.forEach((function(e, t) {
                var i = Math.abs(r - t);
                if (n >= 0 && n < i) {
                    return;
                }
                if (e.type !== p.Divider && e.type !== p.Heading) {
                    n = i;
                    o = t;
                }
            }));
            return o;
        };
        /**
 * @private Keep the injection of `VirtualizedItem` DRY. Will always replace the middle-most non-divider/heading
 * with a VirtualizedItem instance.
 * - If `trackFirstElement` the **FIRST** non-divider/heading item will also be replaced.
 * - If `trackLastElement` the **LAST** non-divider/heading item will also be replaced.
 */        var fe = function e(r, n, o) {
            var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {}, l = i.trackFirstElement, a = i.trackLastElement;
            if (!Array.isArray(r)) {
                return [];
            }
            var u = se(r, Math.floor(r.length / 2));
            var c = l && se(r, 0);
            var s = a && se(r, r.length - 1);
            return r.map((function(e, r) {
                if (r === u || r === c || r === s) {
                    
                    return t().createElement(ce, {
                        key: (0, ee.createGUID)(),
                        onMount: n,
                        onUnmount: o
                    }, e);
                }
                return e;
            }));
        };
        // CONCATENATED MODULE: ./src/ResultsMenu/VirtualizedResultsMenu/VirtualizedResultsMenu.tsx
        function de(e) {
            "@babel/helpers - typeof";
            return de = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e;
            } : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
            }, de(e);
        }
        function ve() {
            return ve = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = arguments[t];
                    for (var n in r) {
                        ({}).hasOwnProperty.call(r, n) && (e[n] = r[n]);
                    }
                }
                return e;
            }, ve.apply(null, arguments);
        }
        function pe(e) {
            return be(e) || ye(e) || Se(e) || me();
        }
        function me() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function ye(e) {
            if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e);
        }
        function be(e) {
            if (Array.isArray(e)) return Ee(e);
        }
        function he(e, t) {
            return we(e) || Oe(e, t) || Se(e, t) || ge();
        }
        function ge() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function Se(e, t) {
            if (e) {
                if ("string" == typeof e) return Ee(e, t);
                var r = {}.toString.call(e).slice(8, -1);
                return "Object" === r && e.constructor && (r = e.constructor.name), "Map" === r || "Set" === r ? Array.from(e) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? Ee(e, t) : void 0;
            }
        }
        function Ee(e, t) {
            (null == t || t > e.length) && (t = e.length);
            for (var r = 0, n = Array(t); r < t; r++) {
                n[r] = e[r];
            }
            return n;
        }
        function Oe(e, t) {
            var r = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
            if (null != r) {
                var n, o, i, l, a = [], u = !0, c = !1;
                try {
                    if (i = (r = r.call(e)).next, 0 === t) {
                        if (Object(r) !== r) return;
                        u = !1;
                    } else for (;!(u = (n = i.call(r)).done) && (a.push(n.value), a.length !== t); u = !0) {
                    }
                } catch (e) {
                    c = !0, o = e;
                } finally {
                    try {
                        if (!u && null != r["return"] && (l = r["return"](), Object(l) !== l)) return;
                    } finally {
                        if (c) throw o;
                    }
                }
                return a;
            }
        }
        function we(e) {
            if (Array.isArray(e)) return e;
        }
        function Me(e, t) {
            if (null == e) return {};
            var r, n, o = xe(e, t);
            if (Object.getOwnPropertySymbols) {
                var i = Object.getOwnPropertySymbols(e);
                for (n = 0; n < i.length; n++) {
                    r = i[n], t.includes(r) || {}.propertyIsEnumerable.call(e, r) && (o[r] = e[r]);
                }
            }
            return o;
        }
        function xe(e, t) {
            if (null == e) return {};
            var r = {};
            for (var n in e) {
                if ({}.hasOwnProperty.call(e, n)) {
                    if (t.includes(n)) continue;
                    r[n] = e[n];
                }
            }
            return r;
        }
        function je(e, t) {
            var r = Object.keys(e);
            if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(e);
                t && (n = n.filter((function(t) {
                    return Object.getOwnPropertyDescriptor(e, t).enumerable;
                }))), r.push.apply(r, n);
            }
            return r;
        }
        function ke(e) {
            for (var t = 1; t < arguments.length; t++) {
                var r = null != arguments[t] ? arguments[t] : {};
                t % 2 ? je(Object(r), !0).forEach((function(t) {
                    Pe(e, t, r[t]);
                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : je(Object(r)).forEach((function(t) {
                    Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
                }));
            }
            return e;
        }
        function Pe(e, t, r) {
            return (t = Te(t)) in e ? Object.defineProperty(e, t, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = r, e;
        }
        function Te(e) {
            var t = Re(e, "string");
            return "symbol" == de(t) ? t : t + "";
        }
        function Re(e, t) {
            if ("object" != de(e) || !e) return e;
            var r = e[Symbol.toPrimitive];
            if (void 0 !== r) {
                var n = r.call(e, t || "default");
                if ("object" != de(n)) return n;
                throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t ? String : Number)(e);
        }
        // TODO(SUI-5920): add transitions to this component in React 18
                var Ie = ke(ke({}, f()($, "onDownKeyPress", "onEndKeyPress", "onHomeKeyPress", "onUpKeyPress")), {}, {
            virtualization: i().number
        });
        var Ce = [];
        /**
 * A wrapper for `ResultsMenu` which virtualizes the `children`. The received `children` array will be split into **"panes"** each with `virtualization` entries
 * and, at any given time, 3 or fewer of these panes will be rendered in the DOM.
 *
 * Given the children `[1, 2, 3, 4, 5, 6, 7, 8, 9]` and `virtualization=4`, then at first only elements `[1, 2, 3, 4, 5, 6, 7, 8]` will be added to the DOM.
 * Once either child `6` or `8` intersect the `Menu` rendered by `ResultsMenu` the next pane of children will also be included and, if needed, the oldest pane
 * will be removed.
 *
 * In effect this means the menu will show the "central" content at pane index _`n`_, a previous-content-buffer comprised of pane index _`n - 1`_,
 * and an upcoming-content-buffer comprised of pane index _`n + 1`_.
 *
 * An `IntersectionObserver` will observe the first node in the _`n - 1`_ pane, the last node in the _`n + 1`_ pane, and the central node in both _`n ± 1`_ panes
 * for intersections with the rendered `Menu` and trigger a *pane change* upon that intersection. As such, in SSR or other environments which don't support `IntersectionObserver`
 * this component should not be used and will be replaced by the barrel file with a vanilla `ResultsMenu`.
 *
 * @throws in `__DEV__` when `virtualization` is too small as compared to the menu height (`virtualization` must be greater than the number of visible items in the rendered menu)
 * @throws in `__DEV__` when `virtualization` is less than or equal to 1 (`virtualization` must be ≥ 2)
 * @throws in `__DEV__` when `virtualization` is changed during the lifecycle of the `VirtualizedResultsMenu` component
 */        function Ae(r) {
            var n = r.virtualization, o = n === void 0 ? 2 : n, i = r.elementRef, l = r.children, a = r.focusMode, u = a === void 0 ? "normal" : a, c = Me(r, [ "virtualization", "elementRef", "children", "focusMode" ]);
            // @docs-props-type VirtualizedResultsMenuPropsBase
                        var s = (0, e.useRef)(o);
            // If a user tries to set virtualization to a value smaller than the number of options
            // visible at a given moment then the menu will flicker endlessly. This state is set in
            // the IntersectionObserver to fix the issue, but in `__DEV__` an error is thrown.
                        var f = (0, e.useState)(o), d = he(f, 2), v = d[0], p = d[1];
 // these refs keep track of whether we need to focus the first/last
            // element after the next render
                        var m = (0, e.useRef)(false);
            var y = (0, e.useRef)(false);
            var b = (0, e.useRef)(l);
            // this code makes the "home" and "end" keys work by injecting
            // an elementRef callback function into the first and last item
            // that will attempt to focus the first/last item if appropriate
            // we need to do this because if we call focus() right after changePane()
            // the new pane won't be in the DOM yet, so the wrong element will end up focused
                        (0, e.useMemo)((function() {
                var t = e.Children.toArray(l);
                var r = se(t, 0);
                var n = se(t, t.length - 1);
                b.current = t.map((function(t, o) {
                    var i = t;
                    if (o === r) {
                        i =  (0, e.isValidElement)(t) ?  (0, e.cloneElement)(t, {
                            elementRef: function e(t) {
                                if (m === null || m === void 0 ? void 0 : m.current) {
                                    m.current = false;
                                    t === null || t === void 0 ? void 0 : t.focus();
                                }
                            }
                        }) : t;
                    } else if (o === n) {
                        i =  (0, e.isValidElement)(t) ?  (0, e.cloneElement)(t, {
                            elementRef: function e(t) {
                                if (y === null || y === void 0 ? void 0 : y.current) {
                                    y.current = false;
                                    t === null || t === void 0 ? void 0 : t.focus();
                                }
                            }
                        }) : t;
                    }
                    return i;
                }));
            }), [ l ]);
            var h = b.current;
            (0, e.useEffect)((function() {
                if (false) {}
            }), [ o ]);
            // `useRef` will recompute its initial value every render cycle.
            // To avoid the array processing we can provide an initialization function to useState and init the ref with the result
                        var g = (0, e.useState)((function() {
                return Z(h, v);
            })), S = he(g, 1), E = S[0];
 // NOSONAR
            // `windowPanes` is an array of arrays, each of length `virtualization`. Each "pane" is just a subset of
            // `children` which will be rendered in a chunk, and at most 3 of these panes will render at any given time.
                        var O = (0, e.useRef)(E);
            var w = (0, e.useRef)(0);
            var M = (0, e.useRef)(null);
            // An IntersectionObserver is used to detect when pane changes are needed.
            // When loadPrevPaneRef or loadNextPaneRef entries intersect the menu, the currentPaneId will be updated.
                        var x = (0, e.useRef)();
            var j = (0, e.useRef)(Ce);
            var k = (0, e.useRef)(Ce);
            var T = (0, e.useCallback)((function() {
                var e;
                var t = O.current, r = t === void 0 ? [] : t;
                var n = w.current;
                /**
     * create onMount for an child of the menu which will be used to trigger pane
     * changes upon intersection with the menu's visible bounds
     */                var o = function e(t) {
                    return function(e) {
                        var r;
                        if (!e) {
                            return;
                        }
                        t.current.push(e);
                        (r = x.current) === null || r === void 0 ? void 0 : r.observe(e);
                    };
                };
                /**
     * onUnmount to cleanup the operations of `onVirtualizeMount`
     */                var i = function e(t) {
                    var r;
                    if (!t) {
                        return;
                    }
                    var n = k.current.indexOf(t);
                    if (n >= 0) {
                        k.current.splice(n, 1);
                    }
                    var o = j.current.indexOf(t);
                    if (o) {
                        j.current.splice(o, 1);
                    }
                    (r = x.current) === null || r === void 0 ? void 0 : r.unobserve(t);
                };
                return [].concat(pe(fe(r[n - 1], o(k), i, {
                    trackFirstElement: true
                })), pe((e = r[n]) !== null && e !== void 0 ? e : []), pe(fe(r[n + 1], o(j), i, {
                    trackLastElement: true
                })));
            }), []);
            var R = (0, e.useState)(T), I = he(R, 2), C = I[0], A = I[1];
            var _ = (0, e.useCallback)((function(e) {
                var t = w.current;
                w.current = Math.max(0, Math.min(e, O.current.length - 1));
                if (t === w.current) {
                    // no change in current pane
                    return;
                }
                A(T);
            }), [ T ]);
            // Link an IntersectionObserver instance with the menu children to be observed
                        var L = (0, e.useCallback)((function(e) {
                var t;
                P(i, e);
                M.current = e;
                // This is overly defensive and could probably be removed
                                (t = x.current) === null || t === void 0 ? void 0 : t.disconnect();
                if (!e) {
                    return;
                }
                k.current = [];
                j.current = [];
                // Run the observation flow
                                x.current = new IntersectionObserver((function(t) {
                    var r;
                    var n = w.current;
                    var o = e.firstElementChild;
                    if (!!o && o.scrollHeight < e.clientHeight) {
                        var i;
                        // If the first element doesn't require a scrollbar then it's likely a filter input
                                                o = (i = o) === null || i === void 0 ? void 0 : i.nextElementSibling;
                    }
                    if (((r = o) === null || r === void 0 ? void 0 : r.scrollTop) === 0 && n === 0 && O.current.length > 1 && t.some((function(e) {
                        return e.isIntersecting;
                    }))) {
                        // The menu hasn't scrolled, is on pane 0, and already has an intersection, the `virtualization` prop is too small
                        p((function(e) {
                            return e + 10;
                        }));
                        if (false) {}
                        return;
                    }
                    var l = false;
                    t.forEach((function(e) {
                        if (l || !e.isIntersecting) {
                            // don't process if the pane changed or the entry isn't intersecting
                            return;
                        }
                        if (k.current.includes(e.target)) {
                            l = true;
                            _(n - 1);
                        } else if (j.current.includes(e.target)) {
                            l = true;
                            _(n + 1);
                        }
                    }));
                }), {
                    root: e
                });
            }), [ i, _ ]);
            var B = (0, e.useCallback)((function(e) {
                var t = M.current;
                if (!t) {
                    return;
                }
                e.preventDefault();
                var r = (0, J.keycode)(e);
                if (r === "home") {
                    var n = w.current === 0;
                    if (n) {
                        var o;
                        // if the first pane is already rendered, find the first element and focus it
                                                var i = (0, Q.getSortedTabbableElements)(t, {
                            ignoreTabIndex: true
                        });
                        var l = i[0];
                        l === null || l === void 0 ? void 0 : (o = l.focus) === null || o === void 0 ? void 0 : o.call(l);
                    } else {
                        // if it's not rendered, set up focusing it after the next render
                        m.current = true;
                        // then call changePane() to trigger the render
                                                _(0);
                    }
                    return;
                }
                var a = O.current.length - 1;
                if (r === "end") {
                    var u = w.current === a;
                    if (u) {
                        var c;
                        // if the last pane is already rendered, find the first element and focus it
                                                var s = (0, Q.getSortedTabbableElements)(t, {
                            ignoreTabIndex: true
                        });
                        var f = s[s.length - 1];
                        f === null || f === void 0 ? void 0 : (c = f.focus) === null || c === void 0 ? void 0 : c.call(f);
                    } else {
                        // if it's not rendered, set up focusing it after the next render
                        y.current = true;
                        // then call changePane() to trigger the render
                                                _(a);
                    }
                    return;
                }
                var d = (0, Q.getSortedTabbableElements)(t, {
                    ignoreTabIndex: true
                });
                var v = (e === null || e === void 0 ? void 0 : e.target) instanceof Element ? e.target : null;
                var p = t === null || t === void 0 ? void 0 : t.querySelector(":focus");
                var b = v || p;
                var h = b ? d.indexOf(b) : -1;
                (0, Q.handleFocus)(r, d, h, {
                    enableLoop: false,
                    // VirtualizedResultsMenu does not support looping focus
                    orientation: "vertical",
                    enableTab: false,
                    enableHomeEnd: false
                });
            }), [ _ ]);
            (0, e.useEffect)((function() {
                p((function(e) {
                    if (false) {}
                    return o;
                }));
            }), [ o ]);
            (0, e.useEffect)((function() {
                O.current = Z(h, v);
                A(T);
            }), [ h, v, T ]);
            (0, e.useEffect)((function() {
                return function() {
                    var e;
                    return (e = x.current) === null || e === void 0 ? void 0 : e.disconnect();
                };
            }), []);
            (0, e.useEffect)((function() {
                if (u === "never") {
                    return undefined;
                }
                var e = M.current;
                if (e) {
                    e.addEventListener("keydown", B);
                }
                return function() {
                    e === null || e === void 0 ? void 0 : e.removeEventListener("keydown", B);
                };
            }), [ B, u ]);
            
            return t().createElement(X, ve({
                elementRef: L,
                focusMode: u
            }, c), C);
        }
        Ae.propTypes = Ie;
        // CONCATENATED MODULE: ./src/utils/ssrDocument.ts
        /* eslint-disable @typescript-eslint/no-empty-function */
        var _e = {
            body: {
                appendChild: function e() {
                    return [];
                }
            },
            addEventListener: function e() {},
            removeEventListener: function e() {},
            activeElement: {
                blur: function e() {},
                nodeName: ""
            },
            querySelector: function e() {
                return null;
            },
            querySelectorAll: function e() {
                return [];
            },
            getElementById: function e() {
                return null;
            },
            createEvent: function e() {
                return {
                    initEvent: function e() {}
                };
            },
            createElement: function e() {
                return {
                    children: [],
                    childNodes: [],
                    style: {},
                    setAttribute: function e() {},
                    getElementsByTagName: function e() {
                        return [];
                    }
                };
            },
            createElementNS: function e() {
                return {};
            },
            importNode: function e() {
                return null;
            },
            location: {
                hash: "",
                host: "",
                hostname: "",
                href: "",
                origin: "",
                pathname: "",
                protocol: "",
                search: ""
            }
        };
        function Le() {
            var e = typeof document !== "undefined" ? document : _e;
            return e;
        }
        var Be = Le();
        /* harmony default export */        const qe = /* unused pure expression or super */ null && Be;
        // CONCATENATED MODULE: ./src/utils/ssrWindow.ts
        /* eslint-disable @typescript-eslint/no-empty-function */
        var Ne = {
            document: _e,
            navigator: {
                userAgent: ""
            },
            location: {
                hash: "",
                host: "",
                hostname: "",
                href: "",
                origin: "",
                pathname: "",
                protocol: "",
                search: ""
            },
            history: {
                replaceState: function e() {},
                pushState: function e() {},
                go: function e() {},
                back: function e() {}
            },
            CustomEvent: function e() {
                return this;
            },
            addEventListener: function e() {},
            removeEventListener: function e() {},
            getComputedStyle: function e() {
                return {
                    getPropertyValue: function e() {
                        return "";
                    }
                };
            },
            Image: function e() {},
            Date: function e() {},
            screen: {},
            setTimeout: function e() {},
            clearTimeout: function e() {},
            matchMedia: function e() {
                return {};
            },
            requestAnimationFrame: function e(t) {
                if (typeof setTimeout === "undefined") {
                    t();
                    return null;
                }
                return setTimeout(t, 0);
            },
            cancelAnimationFrame: function e(t) {
                if (typeof setTimeout === "undefined") {
                    return;
                }
                clearTimeout(t);
            }
        };
        function Fe() {
            var e = typeof window !== "undefined" ? window : Ne;
            return e;
        }
        var He = Fe();
        /* harmony default export */        const De = /* unused pure expression or super */ null && He;
        // CONCATENATED MODULE: ./src/ResultsMenu/VirtualizedResultsMenu/index.ts
        // In environments without IntersectionObserver support this should just export ResultsMenu
        var Ue = "IntersectionObserver" in Fe() ? Ae : X;
        /* harmony default export */        const ze = Ue;
    }) // CONCATENATED MODULE: ./src/ResultsMenu/index.ts
    ();
    module.exports = n;
    /******/})();