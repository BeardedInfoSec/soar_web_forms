/******/ (() => {
    // webpackBootstrap
    /******/ "use strict";
    /******/ // The require scope
    /******/    var e = {};
    /******/
    /************************************************************************/
    /******/ /* webpack/runtime/compat get default export */
    /******/    (() => {
        /******/ // getDefaultExport function for compatibility with non-harmony modules
        /******/ e.n = t => {
            /******/ var r = t && t.__esModule ? 
            /******/ () => t["default"]
            /******/ : () => t
            /******/;
            e.d(r, {
                a: r
            });
            /******/            return r;
            /******/        };
        /******/    })();
    /******/
    /******/ /* webpack/runtime/define property getters */
    /******/    (() => {
        /******/ // define getter functions for harmony exports
        /******/ e.d = (t, r) => {
            /******/ for (var n in r) {
                /******/ if (e.o(r, n) && !e.o(t, n)) {
                    /******/ Object.defineProperty(t, n, {
                        enumerable: true,
                        get: r[n]
                    });
                    /******/                }
                /******/            }
            /******/        };
        /******/    })();
    /******/
    /******/ /* webpack/runtime/hasOwnProperty shorthand */
    /******/    (() => {
        /******/ e.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t)
        /******/;
    })();
    /******/
    /******/ /* webpack/runtime/make namespace object */
    /******/    (() => {
        /******/ // define __esModule on exports
        /******/ e.r = e => {
            /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                /******/ Object.defineProperty(e, Symbol.toStringTag, {
                    value: "Module"
                });
                /******/            }
            /******/            Object.defineProperty(e, "__esModule", {
                value: true
            });
            /******/        };
        /******/    })();
    /******/
    /************************************************************************/    var t = {};
    // ESM COMPAT FLAG
        e.r(t);
    // EXPORTS
        e.d(t, {
        VirtualizedResultsMenu: () => /* reexport */ Re,
        default: () => /* reexport */ V
    });
    // CONCATENATED MODULE: external "react"
    const r = require("react");
    var n =  e.n(r);
    // CONCATENATED MODULE: external "prop-types"
    const o = require("prop-types");
    var i =  e.n(o);
    // CONCATENATED MODULE: external "lodash/keys"
    const u = require("lodash/keys");
    var a =  e.n(u);
    // CONCATENATED MODULE: external "lodash/memoize"
    const l = require("lodash/memoize");
    var c =  e.n(l);
    // CONCATENATED MODULE: external "lodash/omit"
    const s = require("lodash/omit");
    var f =  e.n(s);
    // CONCATENATED MODULE: external "@splunk/ui-utils/i18n"
    const d = require("@splunk/ui-utils/i18n");
    // CONCATENATED MODULE: external "@splunk/ui-utils/userAgent"
    const v = require("@splunk/ui-utils/userAgent");
    // CONCATENATED MODULE: external "@splunk/react-ui/Menu"
    const p = require("@splunk/react-ui/Menu");
    var m =  e.n(p);
    // CONCATENATED MODULE: external "styled-components"
    const h = require("styled-components");
    var y =  e.n(h);
    // CONCATENATED MODULE: external "@splunk/react-ui/WaitSpinner"
    const b = require("@splunk/react-ui/WaitSpinner");
    var g =  e.n(b);
    // CONCATENATED MODULE: external "@splunk/themes"
    const S = require("@splunk/themes");
    // CONCATENATED MODULE: ./src/ResultsMenu/ResultsMenuStyles.ts
    var E = y().div.withConfig({
        displayName: "ResultsMenuStyles__Styled",
        componentId: "avbhl8-0"
    })([ "", ";flex-direction:column;max-height:calc(100vh - 20px);", "" ], S.mixins.reset("flex"), (0, 
    S.pick)({
        prisma: (0, h.css)([ "border-radius:", ";background-color:", ";" ], S.variables.borderRadius, S.variables.backgroundColorPopup)
    }));
    var O = y().div.withConfig({
        displayName: "ResultsMenuStyles__StyledFooter",
        componentId: "avbhl8-1"
    })([ "padding:", ";color:", ";", "" ], (0, S.pick)({
        prisma: {
            comfortable: "10px 16px",
            compact: "6px 16px"
        },
        enterprise: "6px 10px"
    }), (0, S.pick)({
        prisma: S.variables.contentColorMuted,
        enterprise: S.variables.textGray
    }), (function(e) {
        var t = e.$placement;
        return t === "above" ? (0, S.pick)({
            prisma: (0, h.css)([ "border-bottom:1px solid ", ";" ], S.variables.neutral200),
            enterprise: (0, h.css)([ "border-bottom:", ";" ], S.variables.border)
        }) : (0, S.pick)({
            prisma: (0, h.css)([ "border-top:1px solid ", ";" ], S.variables.neutral200),
            enterprise: (0, h.css)([ "border-top:", ";" ], S.variables.border)
        });
    }));
    var M = y().li.withConfig({
        displayName: "ResultsMenuStyles__StyledLoading",
        componentId: "avbhl8-2"
    })([ "", ";padding:", ";gap:", ";" ], S.mixins.reset("flex"), (0, S.pick)({
        prisma: {
            comfortable: "10px 16px",
            compact: "6px 16px"
        },
        enterprise: "6px 10px"
    }), S.variables.spacingXSmall);
    var w = y()(m()).withConfig({
        displayName: "ResultsMenuStyles__StyledMenu",
        componentId: "avbhl8-3"
    })([ "overflow:auto;flex-direction:column;", "" ], (function(e) {
        var t = e.$removeBottomRadius;
        return t && (0, h.css)([ "border-bottom-left-radius:0;border-bottom-right-radius:0;" ]);
    }));
    var k = y()(g()).withConfig({
        displayName: "ResultsMenuStyles__StyledWait",
        componentId: "avbhl8-4"
    })([ "flex:0 0 auto;" ]);
    var x = y().div.withConfig({
        displayName: "ResultsMenuStyles__StyledLoadingMessage",
        componentId: "avbhl8-5"
    })([ "flex:1 0 0;color:", ";" ], (0, S.pick)({
        prisma: S.variables.contentColorMuted,
        enterprise: S.variables.textGray
    }));
    // CONCATENATED MODULE: ./src/utils/updateReactRef.ts
    /**
 * Updates a React ref. Callback refs and object refs (from `createRef` and `useRef`) are supported.
 *
 * @param ref - The React callback or object ref. Can be `null` or `undefined`.
 * @param current - The new value of the ref.
 */
    function j(e, t) {
        if (e) {
            if (typeof e === "function") {
                e(t);
            } else {
                // the public signature of this util uses React.Ref<T> to mirror the way React types refs.
                // the intention here is to signal "we will take care of setting 'current', not you".
                e.current = t;
 // eslint-disable-line no-param-reassign
                        }
        }
    }
    // CONCATENATED MODULE: ./src/ResultsMenu/ResultsMenu.tsx
    function T(e) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            T = function e(t) {
                return typeof t;
            };
        } else {
            T = function e(t) {
                return t && typeof Symbol === "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            };
        }
        return T(e);
    }
    function I() {
        I = Object.assign || function(e) {
            for (var t = 1; t < arguments.length; t++) {
                var r = arguments[t];
                for (var n in r) {
                    if (Object.prototype.hasOwnProperty.call(r, n)) {
                        e[n] = r[n];
                    }
                }
            }
            return e;
        };
        return I.apply(this, arguments);
    }
    function P(e, t) {
        if (!(e instanceof t)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    function C(e, t) {
        for (var r = 0; r < t.length; r++) {
            var n = t[r];
            n.enumerable = n.enumerable || false;
            n.configurable = true;
            if ("value" in n) n.writable = true;
            Object.defineProperty(e, n.key, n);
        }
    }
    function R(e, t, r) {
        if (t) C(e.prototype, t);
        if (r) C(e, r);
        return e;
    }
    function A(e, t) {
        if (typeof t !== "function" && t !== null) {
            throw new TypeError("Super expression must either be null or a function");
        }
        e.prototype = Object.create(t && t.prototype, {
            constructor: {
                value: e,
                writable: true,
                configurable: true
            }
        });
        if (t) _(e, t);
    }
    function _(e, t) {
        _ = Object.setPrototypeOf || function e(t, r) {
            t.__proto__ = r;
            return t;
        };
        return _(e, t);
    }
    function L(e) {
        var t = F();
        return function r() {
            var n = H(e), o;
            if (t) {
                var i = H(this).constructor;
                o = Reflect.construct(n, arguments, i);
            } else {
                o = n.apply(this, arguments);
            }
            return B(this, o);
        };
    }
    function B(e, t) {
        if (t && (T(t) === "object" || typeof t === "function")) {
            return t;
        }
        return q(e);
    }
    function q(e) {
        if (e === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return e;
    }
    function F() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;
        try {
            Date.prototype.toString.call(Reflect.construct(Date, [], (function() {})));
            return true;
        } catch (e) {
            return false;
        }
    }
    function H(e) {
        H = Object.setPrototypeOf ? Object.getPrototypeOf : function e(t) {
            return t.__proto__ || Object.getPrototypeOf(t);
        };
        return H(e);
    }
    function D(e, t, r) {
        if (t in e) {
            Object.defineProperty(e, t, {
                value: r,
                enumerable: true,
                configurable: true,
                writable: true
            });
        } else {
            e[t] = r;
        }
        return e;
    }
    var N = {
        animateLoading: i().bool,
        children: i().node,
        childrenStart: i().node,
        elementRef: i().oneOfType([ i().func, i().object ]),
        focusMode: i().oneOf([ "roving", "normal", "never" ]),
        footerMessage: i().node,
        isLoading: i().bool,
        loadingMessage: i().node,
        noOptionsMessage: i().node,
        onScroll: i().func,
        onScrollBottom: i().func,
        placement: i().string,
        menuId: i().string
    };
    var U = {
        animateLoading: false,
        isLoading: false,
        loadingMessage: (0, d._)("Loading..."),
        noOptionsMessage: (0, d._)("No matches")
    };
    var z = c()((function(e) {
        return {
            height: e
        };
    }));
    // @docs-props-type ResultsMenuPropsBase
        var $ =  function(e) {
        A(o, e);
        var t = L(o);
        function o(e) {
            var n;
            P(this, o);
            n = t.call(this, e);
            D(q(n), "scrollBottomOffset", void 0);
            D(q(n), "itemMinHeight", void 0);
            D(q(n), "handleMenuMount", (function(e) {
                n.setState({
                    menuEl: e
                });
            }));
            D(q(n), "handleMount", (function(e) {
                n.setState({
                    containerEl: e
                });
                j(n.props.elementRef, e);
            }));
            D(q(n), "handleMouseEnter", (function() {
                n.setState({
                    windowTop: document.documentElement.scrollTop
                });
            }));
            D(q(n), "handleMouseLeave", (function() {
                n.setState({
                    windowTop: document.documentElement.scrollTop
                });
            }));
            D(q(n), "handleScroll", (function(e) {
                var t, r;
                if (n.props.onScrollBottom != null) {
                    if (e.target && n.state.menuEl) {
                        var o = n.state.menuEl.scrollHeight - n.state.menuEl.offsetHeight - n.scrollBottomOffset;
 // Adding 1 due to border of menu item.
                                                if (n.state.menuEl.scrollTop + 1 >= o) {
                            n.handleScrollBottom(e);
                        }
                    }
                }
                (t = (r = n.props).onScroll) === null || t === void 0 ? void 0 : t.call(r, e);
            }));
            D(q(n), "handleWheelMenu", (function(e) {
                // Safety net to ensure window doesn't scroll if menu is scrolled pass the numberOfItemsLoaded at high velocity.
                e.stopPropagation();
                document.documentElement.scrollTop = n.state.windowTop;
            }));
            D(q(n), "handleScrollBottomOnFullMenu", (function() {
                var e = r.Children.count(n.props.children);
                var t = n.state.childrenCount;
 // If menu is full length, load more items.
                                if (n.checkFullHeight()) {
                    n.handleScrollBottom(null);
                }
 // avoid triggering this logic if this.state.childrenCount is null
                // because that's not a real change in the number of children
                // and thus we want to avoid resetting the value of scrollBottomTriggered
                                if (t != null && e !== t) {
                    n.setState({
                        numberOfItemsLoaded: e - (t !== null && t !== void 0 ? t : 0),
                        scrollBottomTriggered: false
                    });
                }
                if (e !== t) {
                    n.setState({
                        childrenCount: e
                    });
                }
            }));
            D(q(n), "createMenuContextValue", (function() {
                return {
                    role: "listbox",
                    preventFocus: n.props.focusMode === "never"
                };
            }));
            n.state = {
                containerEl: null,
                menuEl: null,
                numberOfItemsLoaded: 0,
                scrollBottomTriggered: false,
                windowTop: 0
            };
 // The remaining amount of pixels when scrolled from bottom of menu to trigger onScrollBottom().
                        n.scrollBottomOffset = 400;
            n.itemMinHeight = 28;
            return n;
        }
        R(o, [ {
            key: "componentDidUpdate",
            value: function e() {
                var t, r;
                var n = this.state, o = n.containerEl, i = n.menuEl;
                if (!v.isIE11 || !o || !i) {
                    return;
                }
 // If onScrollBottom is defined, determine if it should be triggered.
                                if (((t = this.props) === null || t === void 0 ? void 0 : t.onScrollBottom) && ((r = this.props) === null || r === void 0 ? void 0 : r.children)) {
                    this.handleScrollBottomOnFullMenu();
                }
            }
        }, {
            key: "handleScrollBottom",
            value: function e(t) {
                // Prevent multiple calls to onScrollBottom.
                if (!this.state.scrollBottomTriggered) {
                    var r, n;
                    this.setState({
                        scrollBottomTriggered: true
                    });
                    (r = (n = this.props).onScrollBottom) === null || r === void 0 ? void 0 : r.call(n, t);
                }
            }
        }, {
            key: "checkFullHeight",
            value: function e() {
                var t = this.state.menuEl;
                return t && t.scrollHeight === t.offsetHeight;
            }
        }, {
            key: "renderFooterMessage",
            value: function e() {
                return this.props.footerMessage && !!r.Children.toArray(this.props.children).length &&  n().createElement(O, {
                    $placement: this.props.placement,
                    "data-test": "footer-message",
                    key: "footer"
                }, this.props.footerMessage);
            }
        }, {
            key: "render",
            value: function e() {
                var t = this.props, i = t.animateLoading, u = t.children, l = t.childrenStart, c = t.focusMode, s = t.isLoading, d = t.loadingMessage, v = t.noOptionsMessage, h = t.onScrollBottom, y = t.placement, b = t.style, g = t.tabIndex, S = t.menuId, O = t["aria-multiselectable"];
                var j = f()(this.props, a()(o.propTypes));
                // Assumption: that you cannot be filtered if you are a result
                                var T = r.Children.toArray(u).filter(r.isValidElement).some((function(e) {
                    var t = e.type;
                    return !(t === p.Divider && t.filterFirst || (t === p.Divider || t === p.Heading) && (t.filterLast || t.filterConsecutive));
                }));
                var P = this.checkFullHeight();
                var C = z(this.state.scrollBottomTriggered ? this.state.numberOfItemsLoaded * this.itemMinHeight || 0 : 0);
                /* eslint-disable jsx-a11y/aria-role */                
                return n().createElement(E, I({
                    "data-test": "results-menu",
                    key: "wrapper",
                    ref: this.handleMount,
                    onWheel: h ? this.handleWheelMenu : undefined,
                    onMouseEnter: h ? this.handleMouseEnter : undefined,
                    onMouseLeave: h ? this.handleMouseLeave : undefined
                }, f()(j, "tabIndex", "aria-multiselectable", "menuId"), {
                    style: b
                }), y !== "above" && l, y === "above" && this.renderFooterMessage(),  n().createElement(p.MenuContext.Provider, {
                    value: this.createMenuContextValue()
                },  n().createElement(w, {
                    key: "menu",
                    elementRef: this.handleMenuMount,
                    onScroll: this.handleScroll,
                    stopScrollPropagation: true,
                    tabIndex: g,
                    "aria-multiselectable": O,
                    id: S,
                    focusMode: c,
                    $removeBottomRadius: !!this.props.footerMessage && y !== "above"
                }, !T && v && !s &&  n().createElement(m().Item, {
                    "data-test": "no-results-message",
                    disabled: true
                }, v), u, h && !P && 
                
                // Bottom spacer fills in the space of new items being loaded by using the minimum possible height x menuItems.
                n().createElement("div", {
                    "data-test": "results-menu-bottom-spacer",
                    style: C
                }), s &&  n().createElement(M, null, i &&  n().createElement(k, null),  n().createElement(x, null, d)))), y !== "above" && this.renderFooterMessage(), y === "above" && l);
            }
        } ]);
        return o;
    }(r.Component);
    D($, "propTypes", N);
    D($, "defaultProps", U);
    /* harmony default export */    const V = $;
    // CONCATENATED MODULE: external "@splunk/ui-utils/keyboard"
    const W = require("@splunk/ui-utils/keyboard");
    // CONCATENATED MODULE: external "@splunk/ui-utils/focus"
    const K = require("@splunk/ui-utils/focus");
    // CONCATENATED MODULE: ./src/ResultsMenu/VirtualizedResultsMenu/groupChildren.ts
    // Cheap(er than processing potentially thousands of array elements) memoization
    var G = {
        result: []
    };
    /**
 * Given component children, restructure them into an array of arrays, each of length `groupSize`.
 *
 * The last array is not guaranteed to be full, it will have a length in the range `[1, groupSize]`
 *
 * @example
 * ```js
 * groupChildren([1, 2, 3, 4, 5, 6, 7], 2);
 * // > [[1, 2], [3, 4], [5, 6], [7]]
 * ```
 * @param {Array} children One node, or an array of nodes, to be divided into groups
 * @param {number} groupSize The size of each group to be created
 * @returns A 2d array where each inner-array is a group of size `groupSize` of children
 * and the order of the `children` received equals the order of the flattened result
 */    var X = function e(t, n) {
        if (G.children === t && G.groupSize === n) {
            return G.result;
        }
        G.children = t;
        G.groupSize = n;
        if (n <= 1) {
            if (false) {}
 // don't break in non-__DEV__ and return one big group
                        G.result = [ r.Children.toArray(t) ];
        } else {
            G.result = r.Children.toArray(t).reduce((function(e, t, r) {
                var o = Math.floor(r / n);
                if (!Array.isArray(e[o])) {
                    // eslint-disable-next-line no-param-reassign
                    e[o] = [];
                }
                e[o].push(t);
                return e;
            }), []);
        }
        return G.result;
    };
    // CONCATENATED MODULE: external "@splunk/ui-utils/id"
    const J = require("@splunk/ui-utils/id");
    // CONCATENATED MODULE: ./src/utils/getMenuChildNode.tsx
    // TODO(SUI-5919): fix the ref handling in the other components so this isn't needed
    /**
 * @private Get the HTML <anchor> or <button> node for a received derivative of Menu.Item
 */
    var Q = function e(t) {
        var r, n, o, i;
        if (t.el) {
            return t.el;
 // Menu.Item
                }
        if ((r = t.c) === null || r === void 0 ? void 0 : r.el) {
            return t.c.el;
 // Multiselect.Option
                }
        if ((n = t.c) === null || n === void 0 ? void 0 : (o = n.c) === null || o === void 0 ? void 0 : o.el) {
            return t.c.c.el;
 // Select.Option
                }
        if ((i = t.item) === null || i === void 0 ? void 0 : i.el) {
            return t.item.el;
 // ComboBox.Option
                }
        return null;
    };
    // CONCATENATED MODULE: ./src/ResultsMenu/VirtualizedResultsMenu/VirtualizedItem.ts
    function Y(e, t) {
        return ne(e) || re(e, t) || ee(e, t) || Z();
    }
    function Z() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function ee(e, t) {
        if (!e) return;
        if (typeof e === "string") return te(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        if (r === "Object" && e.constructor) r = e.constructor.name;
        if (r === "Map" || r === "Set") return Array.from(e);
        if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return te(e, t);
    }
    function te(e, t) {
        if (t == null || t > e.length) t = e.length;
        for (var r = 0, n = new Array(t); r < t; r++) {
            n[r] = e[r];
        }
        return n;
    }
    function re(e, t) {
        if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(e))) return;
        var r = [];
        var n = true;
        var o = false;
        var i = undefined;
        try {
            for (var u = e[Symbol.iterator](), a; !(n = (a = u.next()).done); n = true) {
                r.push(a.value);
                if (t && r.length === t) break;
            }
        } catch (e) {
            o = true;
            i = e;
        } finally {
            try {
                if (!n && u["return"] != null) u["return"]();
            } finally {
                if (o) throw i;
            }
        }
        return r;
    }
    function ne(e) {
        if (Array.isArray(e)) return e;
    }
    var oe = {
        children: i().node,
        onMount: i().func.isRequired,
        onUnmount: i().func.isRequired
    };
    /** @private Used by `VirtualizedResultsMenu` */    var ie =  n().forwardRef((function(e, t) {
        var n = e.children, o = e.onMount, i = e.onUnmount;
        var u = (0, r.useState)(), a = Y(u, 2), l = a[0], c = a[1];
        (0, r.useEffect)((function() {
            if (l) {
                o(l);
            }
            return function() {
                if (l) {
                    i(l);
                }
            };
        }), [ l, o, i ]);
        var s = r.Children.only(n);
        if (!s) {
            if (false) {}
            return null;
        }
        
        return (0, r.cloneElement)(s, {
            ref: function e(r) {
                var n = r;
                if (!n) {
                    return;
                }
                j(t, r);
                j(c, Q(n));
            }
        });
    }));
    ie.propTypes = oe;
    ie.as = "Item";
    // CONCATENATED MODULE: ./src/ResultsMenu/VirtualizedResultsMenu/injectVirtualizedItem.tsx
    /**
 * Find the index of an array element which is nearest to targetIndex and is a Menu.Item component
 * @param {Array} elements An array to search
 * @param {Number} targetIndex The target index. This is the ideal value to return.
 * @returns The index in the array of the nearest `Menu.Item` component to `targetIndex`, or -1 if no element is a `Menu.Item` component
 */
    var ue = function e(t, r) {
        var n = -1;
        var o = -1;
        t.forEach((function(e, t) {
            var i = Math.abs(r - t);
            if (n >= 0 && n < i) {
                return;
            }
            if (e.type !== p.Divider && e.type !== p.Heading) {
                n = i;
                o = t;
            }
        }));
        return o;
    };
    /**
 * @private Keep the injection of `VirtualizedItem` DRY. Will always replace the middle-most non-divider/heading
 * with a VirtualizedItem instance.
 * - If `trackFirstElement` the **FIRST** non-divider/heading item will also be replaced.
 * - If `trackLastElement` the **LAST** non-divider/heading item will also be replaced.
 */    var ae = function e(t, r, o) {
        var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {}, u = i.trackFirstElement, a = i.trackLastElement;
        if (!Array.isArray(t)) {
            return [];
        }
        var l = ue(t, Math.floor(t.length / 2));
        var c = u && ue(t, 0);
        var s = a && ue(t, t.length - 1);
        return t.map((function(e, t) {
            if (t === l || t === c || t === s) {
                
                return n().createElement(ie, {
                    key: (0, J.createGUID)(),
                    onMount: r,
                    onUnmount: o
                }, e);
            }
            return e;
        }));
    };
    // CONCATENATED MODULE: ./src/ResultsMenu/VirtualizedResultsMenu/VirtualizedResultsMenu.tsx
    function le() {
        le = Object.assign || function(e) {
            for (var t = 1; t < arguments.length; t++) {
                var r = arguments[t];
                for (var n in r) {
                    if (Object.prototype.hasOwnProperty.call(r, n)) {
                        e[n] = r[n];
                    }
                }
            }
            return e;
        };
        return le.apply(this, arguments);
    }
    function ce(e) {
        return de(e) || fe(e) || me(e) || se();
    }
    function se() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function fe(e) {
        if (typeof Symbol !== "undefined" && Symbol.iterator in Object(e)) return Array.from(e);
    }
    function de(e) {
        if (Array.isArray(e)) return he(e);
    }
    function ve(e, t) {
        return be(e) || ye(e, t) || me(e, t) || pe();
    }
    function pe() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function me(e, t) {
        if (!e) return;
        if (typeof e === "string") return he(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        if (r === "Object" && e.constructor) r = e.constructor.name;
        if (r === "Map" || r === "Set") return Array.from(e);
        if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return he(e, t);
    }
    function he(e, t) {
        if (t == null || t > e.length) t = e.length;
        for (var r = 0, n = new Array(t); r < t; r++) {
            n[r] = e[r];
        }
        return n;
    }
    function ye(e, t) {
        if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(e))) return;
        var r = [];
        var n = true;
        var o = false;
        var i = undefined;
        try {
            for (var u = e[Symbol.iterator](), a; !(n = (a = u.next()).done); n = true) {
                r.push(a.value);
                if (t && r.length === t) break;
            }
        } catch (e) {
            o = true;
            i = e;
        } finally {
            try {
                if (!n && u["return"] != null) u["return"]();
            } finally {
                if (o) throw i;
            }
        }
        return r;
    }
    function be(e) {
        if (Array.isArray(e)) return e;
    }
    function ge(e, t) {
        if (e == null) return {};
        var r = Se(e, t);
        var n, o;
        if (Object.getOwnPropertySymbols) {
            var i = Object.getOwnPropertySymbols(e);
            for (o = 0; o < i.length; o++) {
                n = i[o];
                if (t.indexOf(n) >= 0) continue;
                if (!Object.prototype.propertyIsEnumerable.call(e, n)) continue;
                r[n] = e[n];
            }
        }
        return r;
    }
    function Se(e, t) {
        if (e == null) return {};
        var r = {};
        var n = Object.keys(e);
        var o, i;
        for (i = 0; i < n.length; i++) {
            o = n[i];
            if (t.indexOf(o) >= 0) continue;
            r[o] = e[o];
        }
        return r;
    }
    function Ee(e, t) {
        var r = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var n = Object.getOwnPropertySymbols(e);
            if (t) n = n.filter((function(t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable;
            }));
            r.push.apply(r, n);
        }
        return r;
    }
    function Oe(e) {
        for (var t = 1; t < arguments.length; t++) {
            var r = arguments[t] != null ? arguments[t] : {};
            if (t % 2) {
                Ee(Object(r), true).forEach((function(t) {
                    Me(e, t, r[t]);
                }));
            } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(e, Object.getOwnPropertyDescriptors(r));
            } else {
                Ee(Object(r)).forEach((function(t) {
                    Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
                }));
            }
        }
        return e;
    }
    function Me(e, t, r) {
        if (t in e) {
            Object.defineProperty(e, t, {
                value: r,
                enumerable: true,
                configurable: true,
                writable: true
            });
        } else {
            e[t] = r;
        }
        return e;
    }
    var we = Oe(Oe({}, f()(N, "onDownKeyPress", "onEndKeyPress", "onHomeKeyPress", "onUpKeyPress")), {}, {
        virtualization: i().number
    });
    var ke = [];
    /**
 * A wrapper for `ResultsMenu` which virtualizes the `children`. The received `children` array will be split into **"panes"** each with `virtualization` entries
 * and, at any given time, 3 or fewer of these panes will be rendered in the DOM.
 *
 * Given the children `[1, 2, 3, 4, 5, 6, 7, 8, 9]` and `virtualization=4`, then at first only elements `[1, 2, 3, 4, 5, 6, 7, 8]` will be added to the DOM.
 * Once either child `6` or `8` intersect the `Menu` rendered by `ResultsMenu` the next pane of children will also be included and, if needed, the oldest pane
 * will be removed.
 *
 * In effect this means the menu will show the "central" content at pane index _`n`_, a previous-content-buffer comprised of pane index _`n - 1`_,
 * and an upcoming-content-buffer comprised of pane index _`n + 1`_.
 *
 * An `IntersectionObserver` will observe the first node in the _`n - 1`_ pane, the last node in the _`n + 1`_ pane, and the central node in both _`n ± 1`_ panes
 * for intersections with the rendered `Menu` and trigger a *pane change* upon that intersection. As such, in SSR or other environments which don't support `IntersectionObserver`
 * this component should not be used and will be replaced by the barrel file with a vanilla `ResultsMenu`.
 *
 * @throws in `__DEV__` when `virtualization` is too small as compared to the menu height (`virtualization` must be greater than the number of visible items in the rendered menu)
 * @throws in `__DEV__` when `virtualization` is less than or equal to 1 (`virtualization` must be ≥ 2)
 * @throws in `__DEV__` when `virtualization` is changed during the lifecycle of the `VirtualizedResultsMenu` component
 */    function xe(e) {
        var t = e.virtualization, o = t === void 0 ? 2 : t, i = e.elementRef, u = e.children, a = ge(e, [ "virtualization", "elementRef", "children" ]);
        // @docs-props-type VirtualizedResultsMenuPropsBase
                var l = (0, r.useRef)(o);
 // If a user tries to set virtualization to a value smaller than the number of options
        // visible at a given moment then the menu will flicker endlessly. This state is set in
        // the IntersectionObserver to fix the issue, but in `__DEV__` an error is thrown.
                var c = (0, r.useState)(o), s = ve(c, 2), f = s[0], d = s[1];
        (0, r.useEffect)((function() {
            if (false) {}
        }), [ o ]);
 // `useRef` will recompute its initial value every render cycle.
        // To avoid the array processing we can provide an initialization function to useState and init the ref with the result
                var v = (0, r.useState)((function() {
            return X(u, f);
        })), p = ve(v, 1), m = p[0];
 // NOSONAR
        // `windowPanes` is an array of arrays, each of length `virtualization`. Each "pane" is just a subset of
        // `children` which will be rendered in a chunk, and at most 3 of these panes will render at any given time.
                var h = (0, r.useRef)(m);
        var y = (0, r.useRef)(0);
        var b = (0, r.useRef)(null);
 // An IntersectionObserver is used to detect when pane changes are needed.
        // When loadPrevPaneRef or loadNextPaneRef entries intersect the menu, the currentPaneId will be updated.
                var g = (0, r.useRef)();
        var S = (0, r.useRef)(ke);
        var E = (0, r.useRef)(ke);
        var O = (0, r.useCallback)((function() {
            var e;
            var t = h.current, r = t === void 0 ? [] : t;
            var n = y.current;
            /**
     * create onMount for an child of the menu which will be used to trigger pane
     * changes upon intersection with the menu's visible bounds
     */            var o = function e(t) {
                return function(e) {
                    var r;
                    if (!e) {
                        return;
                    }
                    t.current.push(e);
                    (r = g.current) === null || r === void 0 ? void 0 : r.observe(e);
                };
            };
            /**
     * onUnmount to cleanup the operations of `onVirtualizeMount`
     */            var i = function e(t) {
                var r;
                if (!t) {
                    return;
                }
                var n = E.current.indexOf(t);
                if (n >= 0) {
                    E.current.splice(n, 1);
                }
                var o = S.current.indexOf(t);
                if (o) {
                    S.current.splice(o, 1);
                }
                (r = g.current) === null || r === void 0 ? void 0 : r.unobserve(t);
            };
            return [].concat(ce(ae(r[n - 1], o(E), i, {
                trackFirstElement: true
            })), ce((e = r[n]) !== null && e !== void 0 ? e : []), ce(ae(r[n + 1], o(S), i, {
                trackLastElement: true
            })));
        }), []);
        var M = (0, r.useState)(O), w = ve(M, 2), k = w[0], x = w[1];
        var T = (0, r.useCallback)((function(e) {
            var t = y.current;
            y.current = Math.max(0, Math.min(e, h.current.length - 1));
            if (t === y.current) {
                // no change in current pane
                return;
            }
            x(O);
        }), [ O ]);
 // Link an IntersectionObserver instance with the menu children to be observed
                var I = (0, r.useCallback)((function(e) {
            var t;
            j(i, e);
            b.current = e;
 // This is overly defensive and could probably be removed
                        (t = g.current) === null || t === void 0 ? void 0 : t.disconnect();
            if (!e) {
                return;
            }
            E.current = [];
            S.current = [];
 // Run the observation flow
                        g.current = new IntersectionObserver((function(t) {
                var r;
                var n = y.current;
                var o = e.firstElementChild;
                if (!!o && o.scrollHeight < e.clientHeight) {
                    var i;
                    // If the first element doesn't require a scrollbar then it's likely a filter input
                                        o = (i = o) === null || i === void 0 ? void 0 : i.nextElementSibling;
                }
                if (((r = o) === null || r === void 0 ? void 0 : r.scrollTop) === 0 && n === 0 && h.current.length > 1 && t.some((function(e) {
                    return e.isIntersecting;
                }))) {
                    // The menu hasn't scrolled, is on pane 0, and already has an intersection, the `virtualization` prop is too small
                    d((function(e) {
                        return e + 10;
                    }));
                    if (false) {}
                    return;
                }
                var u = false;
                t.forEach((function(e) {
                    if (u || !e.isIntersecting) {
                        // don't process if the pane changed or the entry isn't intersecting
                        return;
                    }
                    if (E.current.includes(e.target)) {
                        u = true;
                        T(n - 1);
                    } else if (S.current.includes(e.target)) {
                        u = true;
                        T(n + 1);
                    }
                }));
            }), {
                root: e
            });
        }), [ i, T ]);
        var P = (0, r.useCallback)((function(e) {
            var t = b.current;
            if (!t) {
                return;
            }
            e.preventDefault();
            var r = (0, W.keycode)(e);
            if (r === "home") {
                var n;
                if (y.current !== 0) {
                    T(0);
                }
                var o = (0, K.getSortedTabbableElements)(t, {
                    ignoreTabIndex: true
                });
                var i = o[0];
                i === null || i === void 0 ? void 0 : (n = i.focus) === null || n === void 0 ? void 0 : n.call(i);
                return;
            }
            var u = h.current.length - 1;
            if (r === "end") {
                var a;
                if (y.current !== u) {
                    T(u);
                }
                var l = (0, K.getSortedTabbableElements)(t, {
                    ignoreTabIndex: true
                });
                var c = l[l.length - 1];
                c === null || c === void 0 ? void 0 : (a = c.focus) === null || a === void 0 ? void 0 : a.call(c);
                return;
            }
            var s = (0, K.getSortedTabbableElements)(t, {
                ignoreTabIndex: true
            });
            var f = (e === null || e === void 0 ? void 0 : e.target) instanceof Element ? e.target : null;
            var d = t === null || t === void 0 ? void 0 : t.querySelector(":focus");
            var v = f || d;
            var p = v ? s.indexOf(v) : -1;
            (0, K.handleFocus)(r, s, p, {
                enableLoop: false,
                // VirtualizedResultsMenu does not support looping focus
                orientation: "vertical",
                enableTab: false,
                enableHomeEnd: false
            });
        }), [ T ]);
        (0, r.useEffect)((function() {
            d((function(e) {
                if (false) {}
                return o;
            }));
        }), [ o ]);
        (0, r.useEffect)((function() {
            h.current = X(u, f);
            x(O);
        }), [ u, f, O ]);
        (0, r.useEffect)((function() {
            return function() {
                var e;
                return (e = g.current) === null || e === void 0 ? void 0 : e.disconnect();
            };
        }), []);
        (0, r.useEffect)((function() {
            var e = b.current;
            if (e) {
                e.addEventListener("keydown", P);
            }
            return function() {
                e === null || e === void 0 ? void 0 : e.removeEventListener("keydown", P);
            };
        }), [ P ]);
        
        return n().createElement(V, le({
            elementRef: I,
            focusMode: "normal"
        }, a), k);
    }
    xe.propTypes = we;
    // CONCATENATED MODULE: ./src/utils/ssrDocument.ts
    /* eslint-disable @typescript-eslint/no-empty-function */
    var je = {
        body: {
            appendChild: function e() {
                return [];
            }
        },
        addEventListener: function e() {},
        removeEventListener: function e() {},
        activeElement: {
            blur: function e() {},
            nodeName: ""
        },
        querySelector: function e() {
            return null;
        },
        querySelectorAll: function e() {
            return [];
        },
        getElementById: function e() {
            return null;
        },
        createEvent: function e() {
            return {
                initEvent: function e() {}
            };
        },
        createElement: function e() {
            return {
                children: [],
                childNodes: [],
                style: {},
                setAttribute: function e() {},
                getElementsByTagName: function e() {
                    return [];
                }
            };
        },
        createElementNS: function e() {
            return {};
        },
        importNode: function e() {
            return null;
        },
        location: {
            hash: "",
            host: "",
            hostname: "",
            href: "",
            origin: "",
            pathname: "",
            protocol: "",
            search: ""
        }
    };
    function Te() {
        var e = typeof document !== "undefined" ? document : je;
        return e;
    }
    // CONCATENATED MODULE: ./src/utils/ssrWindow.ts
    /* eslint-disable @typescript-eslint/no-empty-function */
    var Ie = {
        document: je,
        navigator: {
            userAgent: ""
        },
        location: {
            hash: "",
            host: "",
            hostname: "",
            href: "",
            origin: "",
            pathname: "",
            protocol: "",
            search: ""
        },
        history: {
            replaceState: function e() {},
            pushState: function e() {},
            go: function e() {},
            back: function e() {}
        },
        CustomEvent: function e() {
            return this;
        },
        addEventListener: function e() {},
        removeEventListener: function e() {},
        getComputedStyle: function e() {
            return {
                getPropertyValue: function e() {
                    return "";
                }
            };
        },
        Image: function e() {},
        Date: function e() {},
        screen: {},
        setTimeout: function e() {},
        clearTimeout: function e() {},
        matchMedia: function e() {
            return {};
        },
        requestAnimationFrame: function e(t) {
            if (typeof setTimeout === "undefined") {
                t();
                return null;
            }
            return setTimeout(t, 0);
        },
        cancelAnimationFrame: function e(t) {
            if (typeof setTimeout === "undefined") {
                return;
            }
            clearTimeout(t);
        }
    };
    function Pe() {
        var e = typeof window !== "undefined" ? window : Ie;
        return e;
    }
    // CONCATENATED MODULE: ./src/ResultsMenu/VirtualizedResultsMenu/index.ts
    // In environments without IntersectionObserver support this should just export ResultsMenu
    var Ce = "IntersectionObserver" in Pe() ? xe : V;
    /* harmony default export */    const Re = Ce;
    // CONCATENATED MODULE: ./src/ResultsMenu/index.ts
    module.exports = t;
    /******/})();