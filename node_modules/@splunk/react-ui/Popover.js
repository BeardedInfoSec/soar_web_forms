/******/ (() => {
    // webpackBootstrap
    /******/ "use strict";
    /******/ // The require scope
    /******/    var e = {};
    /******/
    /************************************************************************/
    /******/ /* webpack/runtime/compat get default export */
    /******/    (() => {
        /******/ // getDefaultExport function for compatibility with non-harmony modules
        /******/ e.n = t => {
            /******/ var r = t && t.__esModule ? 
            /******/ () => t["default"]
            /******/ : () => t
            /******/;
            e.d(r, {
                a: r
            });
            /******/            return r;
            /******/        };
        /******/    })();
    /******/
    /******/ /* webpack/runtime/define property getters */
    /******/    (() => {
        /******/ // define getter functions for harmony exports
        /******/ e.d = (t, r) => {
            /******/ for (var n in r) {
                /******/ if (e.o(r, n) && !e.o(t, n)) {
                    /******/ Object.defineProperty(t, n, {
                        enumerable: true,
                        get: r[n]
                    });
                    /******/                }
                /******/            }
            /******/        };
        /******/    })();
    /******/
    /******/ /* webpack/runtime/hasOwnProperty shorthand */
    /******/    (() => {
        /******/ e.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t)
        /******/;
    })();
    /******/
    /******/ /* webpack/runtime/make namespace object */
    /******/    (() => {
        /******/ // define __esModule on exports
        /******/ e.r = e => {
            /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                /******/ Object.defineProperty(e, Symbol.toStringTag, {
                    value: "Module"
                });
                /******/            }
            /******/            Object.defineProperty(e, "__esModule", {
                value: true
            });
            /******/        };
        /******/    })();
    /******/
    /************************************************************************/    var t = {};
    // ESM COMPAT FLAG
        e.r(t);
    // EXPORTS
        e.d(t, {
        PopoverContext: () => /* reexport */ z,
        PopoverMenuContext: () => /* reexport */ Y,
        PopoverProvider: () => /* reexport */ X,
        default: () => /* reexport */ yt
    });
    // CONCATENATED MODULE: external "react"
    const r = require("react");
    var n =  e.n(r);
    // CONCATENATED MODULE: external "prop-types"
    const o = require("prop-types");
    var a =  e.n(o);
    // CONCATENATED MODULE: external "react-dom"
    const i = require("react-dom");
    // CONCATENATED MODULE: external "lodash/clamp"
    const l = require("lodash/clamp");
    var c =  e.n(l);
    // CONCATENATED MODULE: external "lodash/defer"
    const u = require("lodash/defer");
    var f =  e.n(u);
    // CONCATENATED MODULE: external "lodash/every"
    const s = require("lodash/every");
    var p =  e.n(s);
    // CONCATENATED MODULE: external "lodash/has"
    const h = require("lodash/has");
    var d =  e.n(h);
    // CONCATENATED MODULE: external "lodash/includes"
    const v = require("lodash/includes");
    var m =  e.n(v);
    // CONCATENATED MODULE: external "lodash/intersection"
    const b = require("lodash/intersection");
    var y =  e.n(b);
    // CONCATENATED MODULE: external "lodash/isFinite"
    const g = require("lodash/isFinite");
    var w =  e.n(g);
    // CONCATENATED MODULE: external "lodash/isFunction"
    const S = require("lodash/isFunction");
    var O =  e.n(S);
    // CONCATENATED MODULE: external "lodash/keys"
    const P = require("lodash/keys");
    var E =  e.n(P);
    // CONCATENATED MODULE: external "lodash/omit"
    const C = require("lodash/omit");
    var j =  e.n(C);
    // CONCATENATED MODULE: external "lodash/throttle"
    const x = require("lodash/throttle");
    var k =  e.n(x);
    // CONCATENATED MODULE: external "@splunk/themes"
    const A = require("@splunk/themes");
    // CONCATENATED MODULE: external "@splunk/react-ui/Animation"
    const T = require("@splunk/react-ui/Animation");
    // CONCATENATED MODULE: external "@splunk/react-ui/EventListener"
    const W = require("@splunk/react-ui/EventListener");
    var M =  e.n(W);
    // CONCATENATED MODULE: external "@splunk/react-ui/Layer"
    const q = require("@splunk/react-ui/Layer");
    var R =  e.n(q);
    // CONCATENATED MODULE: external "@splunk/react-ui/ScrollContainerContext"
    const H = require("@splunk/react-ui/ScrollContainerContext");
    var _ =  e.n(H);
    // CONCATENATED MODULE: external "@splunk/ui-utils/focus"
    const D = require("@splunk/ui-utils/focus");
    // CONCATENATED MODULE: ./src/Popover/getPlacement.ts
    function I(e) {
        "@babel/helpers - typeof";
        return I = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e;
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        }, I(e);
    }
    function L(e, t) {
        var r = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var n = Object.getOwnPropertySymbols(e);
            t && (n = n.filter((function(t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable;
            }))), r.push.apply(r, n);
        }
        return r;
    }
    function F(e) {
        for (var t = 1; t < arguments.length; t++) {
            var r = null != arguments[t] ? arguments[t] : {};
            t % 2 ? L(Object(r), !0).forEach((function(t) {
                N(e, t, r[t]);
            })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : L(Object(r)).forEach((function(t) {
                Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
            }));
        }
        return e;
    }
    function N(e, t, r) {
        return (t = $(t)) in e ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = r, e;
    }
    function $(e) {
        var t = V(e, "string");
        return "symbol" == I(t) ? t : t + "";
    }
    function V(e, t) {
        if ("object" != I(e) || !e) return e;
        var r = e[Symbol.toPrimitive];
        if (void 0 !== r) {
            var n = r.call(e, t || "default");
            if ("object" != I(n)) return n;
            throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === t ? String : Number)(e);
    }
    function B(e) {
        var t = e.align, r = e.anchorPos, n = e.outerContainerEl, o = e.padding, a = e.placement;
        switch (a) {
          case "above":
            return {
                top: r.top - n.offsetHeight,
                left: t === "edge" ? r.left - o : r.middle - n.offsetWidth / 2
            };

          case "below":
            // Align 'end' is only supported by below
            // TODO: SUI-5101 Enable users to align Popover and Dropdown
            if (t === "end") {
                return {
                    top: r.bottom,
                    left: r.right - n.offsetWidth + o
                };
            }
            return {
                top: r.bottom,
                left: t === "edge" ? r.left - o : r.middle - n.offsetWidth / 2
            };

          case "left":
            return {
                top: t === "edge" ? r.top - o : r.center - n.offsetHeight / 2,
                left: r.left - n.offsetWidth
            };

          case "right":
            return {
                top: t === "edge" ? r.top - o : r.center - n.offsetHeight / 2,
                left: r.right
            };

          default:
            throw new Error("".concat(a, " is not a valid placement value. Valid options are: 'above', 'below', 'left', or 'right'"));
        }
    }
    function U(e) {
        var t = e.align, r = e.anchorPos, n = e.scrollContainerPos, o = e.canCoverAnchor, a = e.defaultPlacement, i = e.outerContainerEl, l = e.padding, c = e.repositionMode, u = e.windowHeight, f = e.windowWidth;
        var s = c === "flip";
        var p = c === "any";
        var h = s || p;
        var d = e.placement || a;
        // Translate vertical/horizontal to above/below/left/right
                if (a === "vertical") {
            d = r.top > u - r.bottom ? "above" : "below";
        } else if (a === "horizontal") {
            d = r.left > f - r.right ? "left" : "right";
        }
        var v = d;
        // Initialize the result variables. These will be mutated as needed and returned.
                var m = B({
            align: t,
            anchorPos: r,
            outerContainerEl: i,
            padding: l,
            placement: v
        }), b = m.top, y = m.left;
        var g = "auto";
        var w = f;
        var S = u;
        var O = v;
        // Boolean convenience variables to simplify positioning logic.
                var P = r.top - i.offsetHeight > 0;
        var E = r.bottom + i.offsetHeight < u;
        var C = r.left - i.offsetWidth > 0;
        var j = r.right + i.offsetWidth < f;
        var x = r.top * .7 > u - r.bottom;
        var k = (t === "edge" ? r.left + i.offsetWidth - l : r.middle + i.offsetWidth / 2) > f;
        var A = (t === "edge" ? r.left - l : r.middle - i.offsetWidth / 2) < 0;
        var T = (t === "edge" ? r.top - l : r.top - i.offsetHeight / 2) < 0;
        var W = (t === "edge" ? r.top + i.offsetHeight - l : r.bottom + i.offsetHeight / 2) > u;
        // Handle each of the four placement options individually.
                if (O === "above") {
            if (!P && h) {
                if (E) {
                    return U(F(F({}, e), {}, {
                        placement: "below"
                    }));
                }
                if (p && j) {
                    return U(F(F({}, e), {}, {
                        placement: "right"
                    }));
                }
                if (p && C) {
                    return U(F(F({}, e), {}, {
                        placement: "left"
                    }));
                }
                if (o) {
                    O = "misaligned";
                    b = 0;
                }
            }
            if (O !== "misaligned") {
                g = u - b - i.offsetHeight;
                if (n) {
                    g = Math.min(g, u - n.top);
                }
                b = "auto";
            }
            if (k) {
                y = Math.max(f - i.offsetWidth, 0);
            } else if (A) {
                y = 0;
            }
            if (!o) {
                S = r.top;
            }
        }
        if (O === "below") {
            if (!E && h) {
                if (P && x) {
                    return U(F(F({}, e), {}, {
                        placement: "above"
                    }));
                }
                if (p && j) {
                    return U(F(F({}, e), {}, {
                        placement: "right"
                    }));
                }
                if (p && C) {
                    return U(F(F({}, e), {}, {
                        placement: "left"
                    }));
                }
                if (o) {
                    O = "misaligned";
                    b = 0;
                }
            }
            if (n) {
                b = Math.min(b, n.bottom);
            }
            if (k) {
                y = Math.max(f - i.offsetWidth, 0);
            } else if (A) {
                y = 0;
            }
            if (!o) {
                S = u - r.bottom;
            }
        }
        if (O === "left") {
            if (!C && h) {
                if (j) {
                    return U(F(F({}, e), {}, {
                        placement: "right"
                    }));
                }
                if (p && E) {
                    return U(F(F({}, e), {}, {
                        placement: "below"
                    }));
                }
                if (p && P) {
                    return U(F(F({}, e), {}, {
                        placement: "above"
                    }));
                }
                if (o) {
                    O = "misaligned";
                    b = 0;
                }
            }
            if (T) {
                b = 0;
            } else if (W) {
                b = Math.max(u - i.offsetHeight, 0);
            }
            if (!o) {
                w = r.left;
            }
        }
        if (O === "right") {
            if (!j && h) {
                if (C) {
                    return U(F(F({}, e), {}, {
                        placement: "left"
                    }));
                }
                if (p && E) {
                    return U(F(F({}, e), {}, {
                        placement: "below"
                    }));
                }
                if (p && P) {
                    return U(F(F({}, e), {}, {
                        placement: "above"
                    }));
                }
                if (o) {
                    O = "misaligned";
                    b = 0;
                }
            }
            if (T) {
                b = 0;
            } else if (W) {
                b = Math.max(u - i.offsetHeight, 0);
            }
            if (!o) {
                w = f - r.left;
            }
        }
        return {
            placement: O,
            maxHeight: S,
            maxWidth: w,
            outerContainerStyle: {
                top: b,
                left: y,
                bottom: g
            }
        };
    }
    // CONCATENATED MODULE: ./src/Popover/PopoverProvider.tsx
    var z =  (0, r.createContext)({});
    var K = {
        children: a().node,
        hideArrow: a().bool
    };
    /**
 * Provides a method for controlling certain `Popover` props in components that use `Popover`.
 */    var X = function e(t) {
        var o = t.children, a = t.hideArrow;
        var i = (0, r.useMemo)((function() {
            return {
                hideArrow: a
            };
        }), [ a ]);
        
        return n().createElement(z.Provider, {
            value: i
        }, o);
    };
    X.propTypes = K;
    // CONCATENATED MODULE: ./src/Popover/PopoverMenuContext.tsx
    var Y =  (0, r.createContext)({});
    // CONCATENATED MODULE: external "react-spring"
    const G = require("react-spring");
    // CONCATENATED MODULE: external "styled-components"
    const J = require("styled-components");
    var Q =  e.n(J);
    // CONCATENATED MODULE: ./src/Popover/PopoverStyles.ts
    var Z = 8;
    var ee = Q()(G.animated.div).withConfig({
        displayName: "PopoverStyles__Styled",
        componentId: "sc-1nahsvw-0"
    })([ "position:fixed;z-index:", ";left:-300%;top:-300%;" ], A.variables.zindexPopover);
    // These hex codes are the inverted values of variables.backgroundColorPopup which are not exposed as tokens
        var te = (0, J.css)([ "", "" ], (0, A.pick)({
        light: "#27292e",
        dark: A.variables.white
    }));
    var re = Q().div.withConfig({
        displayName: "PopoverStyles__StyledBox",
        componentId: "sc-1nahsvw-1"
    })([ "", ";", ";", ";" ], A.mixins.reset("block"), (function(e) {
        var t = e.$open;
        return !t && (0, J.css)([ "pointer-events:none;" ]);
    }), (function(e) {
        var t = e.$appearance;
        return t !== "none" && (0, J.css)([ "padding:8px;" ]);
    }));
    var ne = Q().div.withConfig({
        displayName: "PopoverStyles__StyledContent",
        componentId: "sc-1nahsvw-2"
    })([ "border-radius:", ";background-color:", ";color:", ";", "" ], A.variables.borderRadius, (0, 
    A.pickVariant)("$appearance", {
        normal: A.variables.backgroundColorPopup,
        inverted: {
            enterprise: {
                light: A.variables.gray20,
                dark: A.variables.white
            },
            prisma: te
        }
    }), (0, A.pickVariant)("$appearance", {
        normal: A.variables.contentColorDefault,
        inverted: {
            enterprise: {
                light: A.variables.white,
                dark: A.variables.gray30
            },
            prisma: A.variables.contentColorInverted
        }
    }), (0, A.pickVariant)("$appearance", {
        normal: (0, J.css)([ "", ";" ], (0, A.pick)({
            enterprise: {
                light: (0, J.css)([ "box-shadow:0 2px 2px ", ";border:", ";" ], A.mixins.colorWithAlpha(A.variables.gray20, .1), A.variables.border),
                dark: (0, J.css)([ "box-shadow:0 1px 2px #000;border:", ";" ], A.variables.border)
            },
            prisma: (0, J.css)([ "box-shadow:", ";" ], A.variables.overlayShadow)
        }))
    }));
    var oe = Q().div.withConfig({
        displayName: "PopoverStyles__StyledArrow",
        componentId: "sc-1nahsvw-3"
    })([ "width:0;height:0;border-left:", "px solid transparent;border-right:", "px solid transparent;position:absolute;border-bottom-width:", "px;border-bottom-style:solid;", ";" ], Z, Z, Z, (function(e) {
        var t = e.$appearance;
        return t !== "none" && (0, J.css)([ "border-bottom-color:", ";&::before{content:'';display:block;width:0;height:0;border-left:", "px solid transparent;border-right:", "px solid transparent;border-bottom:", "px solid;border-bottom-color:", ";position:absolute;top:1px;left:0;margin-left:-", "px;}" ], (0, 
        A.pickVariant)("$appearance", {
            normal: {
                enterprise: {
                    light: A.variables.borderColor,
                    dark: A.variables.black
                },
                prisma: A.variables.backgroundColorPopup
            },
            inverted: {
                enterprise: {
                    light: A.variables.gray20,
                    dark: A.variables.white
                },
                prisma: te
            }
        }), Z, Z, Z, (0, A.pickVariant)("$appearance", {
            normal: A.variables.backgroundColorPopup,
            inverted: {
                enterprise: {
                    light: A.variables.gray20,
                    dark: A.variables.white
                },
                prisma: te
            }
        }), Z);
    }));
    var ae = Q().svg.withConfig({
        displayName: "PopoverStyles__StyledHitArea",
        componentId: "sc-1nahsvw-4"
    })([ "position:fixed;pointer-events:none;path{pointer-events:auto;stroke-width:0;stroke:transparent;fill:transparent;}" ]);
    // CONCATENATED MODULE: ./src/Popover/PopoverHitArea.tsx
    function ie(e, t) {
        return se(e) || fe(e, t) || ce(e, t) || le();
    }
    function le() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function ce(e, t) {
        if (e) {
            if ("string" == typeof e) return ue(e, t);
            var r = {}.toString.call(e).slice(8, -1);
            return "Object" === r && e.constructor && (r = e.constructor.name), "Map" === r || "Set" === r ? Array.from(e) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? ue(e, t) : void 0;
        }
    }
    function ue(e, t) {
        (null == t || t > e.length) && (t = e.length);
        for (var r = 0, n = Array(t); r < t; r++) {
            n[r] = e[r];
        }
        return n;
    }
    function fe(e, t) {
        var r = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
        if (null != r) {
            var n, o, a, i, l = [], c = !0, u = !1;
            try {
                if (a = (r = r.call(e)).next, 0 === t) {
                    if (Object(r) !== r) return;
                    c = !1;
                } else for (;!(c = (n = a.call(r)).done) && (l.push(n.value), l.length !== t); c = !0) {
                }
            } catch (e) {
                u = !0, o = e;
            } finally {
                try {
                    if (!c && null != r["return"] && (i = r["return"](), Object(i) !== i)) return;
                } finally {
                    if (u) throw o;
                }
            }
            return l;
        }
    }
    function se(e) {
        if (Array.isArray(e)) return e;
    }
    var pe = {
        anchorRect: a().object,
        popoverEl: a().object,
        popoverPlacement: a().oneOf([ "above", "below", "left", "right", "misaligned" ])
    };
    var he = function e(t) {
        var r = t.anchorRect, n = t.popoverEl, o = t.popoverPlacement;
        if (r != null && n != null && o != null) {
            var a = n.getBoundingClientRect();
            if (o === "above" || o === "below") {
                var i = r.left - a.left;
                var l = r.height;
                var c = 0;
                if (o === "above") {
                    l = 0;
                    c = r.height;
                }
                var u = "0 ".concat(l);
                var f = "".concat(a.width, " ").concat(l);
                var s = "".concat(i, " ").concat(l);
                var p = "".concat(i, " ").concat(c);
                var h = "".concat(i + r.width, " ").concat(l);
                var d = "".concat(i + r.width, " ").concat(c);
                var v = "\n                        M ".concat(u, "\n                        S ").concat(s, " , ").concat(p, "\n                        L ").concat(s, "\n                        L ").concat(h, "\n                        L ").concat(d, "\n                        S ").concat(h, " , ").concat(f, "\n                    ");
                return {
                    hitAreaPath: v,
                    hitAreaStyle: {
                        left: a.left,
                        top: r.top,
                        width: a.width,
                        height: r.height
                    }
                };
            }
            if (o === "left" || o === "right") {
                var m = r.top - a.top;
                var b = 0;
                var y = r.width;
                if (o === "right") {
                    b = r.width;
                    y = 0;
                }
                var g = "".concat(b, " 0");
                var w = "".concat(b, " ").concat(a.height);
                var S = "".concat(b, " ").concat(m);
                var O = "".concat(y, " ").concat(m);
                var P = "".concat(b, " ").concat(m + r.height);
                var E = "".concat(y, " ").concat(m + r.height);
                var C = "\n                        M ".concat(g, "\n                        S ").concat(S, " , ").concat(O, "\n                        L ").concat(S, "\n                        L ").concat(P, "\n                        L ").concat(E, "\n                        S ").concat(P, " , ").concat(w, "\n                    ");
                return {
                    hitAreaPath: C,
                    hitAreaStyle: {
                        left: r.left,
                        top: a.top,
                        width: r.width,
                        height: a.height
                    }
                };
            }
        }
        return {
            hitAreaPath: null,
            hitAreaStyle: {}
        };
    };
    var de =  n().forwardRef((function(e, t) {
        var o = e.anchorRect, a = e.popoverEl, i = e.popoverPlacement;
        var l = (0, r.useState)(null), c = ie(l, 2), u = c[0], f = c[1];
        var s = (0, r.useState)({}), p = ie(s, 2), h = p[0], d = p[1];
        (0, r.useEffect)((function() {
            var e = he({
                anchorRect: o,
                popoverEl: a,
                popoverPlacement: i
            }), t = e.hitAreaPath, r = e.hitAreaStyle;
            f(t);
            d(r);
        }), [ o, a, i ]);
        if (u != null) {
            
            return n().createElement(ae, {
                "data-test": "popover-hit-area",
                style: h
            },  n().createElement("path", {
                d: u,
                ref: t
            }));
        }
        return null;
    }));
    de.propTypes = pe;
    /* harmony default export */    const ve = de;
    // CONCATENATED MODULE: ./src/utils/ssrDocument.ts
    /* eslint-disable @typescript-eslint/no-empty-function */
    var me = {
        body: {
            appendChild: function e() {
                return [];
            }
        },
        addEventListener: function e() {},
        removeEventListener: function e() {},
        activeElement: {
            blur: function e() {},
            nodeName: ""
        },
        querySelector: function e() {
            return null;
        },
        querySelectorAll: function e() {
            return [];
        },
        getElementById: function e() {
            return null;
        },
        createEvent: function e() {
            return {
                initEvent: function e() {}
            };
        },
        createElement: function e() {
            return {
                children: [],
                childNodes: [],
                style: {},
                setAttribute: function e() {},
                getElementsByTagName: function e() {
                    return [];
                }
            };
        },
        createElementNS: function e() {
            return {};
        },
        importNode: function e() {
            return null;
        },
        location: {
            hash: "",
            host: "",
            hostname: "",
            href: "",
            origin: "",
            pathname: "",
            protocol: "",
            search: ""
        }
    };
    function be() {
        var e = typeof document !== "undefined" ? document : me;
        return e;
    }
    var ye = be();
    /* harmony default export */    const ge = /* unused pure expression or super */ null && ye;
    // CONCATENATED MODULE: ./src/utils/ssrWindow.ts
    /* eslint-disable @typescript-eslint/no-empty-function */
    var we = {
        document: me,
        navigator: {
            userAgent: ""
        },
        location: {
            hash: "",
            host: "",
            hostname: "",
            href: "",
            origin: "",
            pathname: "",
            protocol: "",
            search: ""
        },
        history: {
            replaceState: function e() {},
            pushState: function e() {},
            go: function e() {},
            back: function e() {}
        },
        CustomEvent: function e() {
            return this;
        },
        addEventListener: function e() {},
        removeEventListener: function e() {},
        getComputedStyle: function e() {
            return {
                getPropertyValue: function e() {
                    return "";
                }
            };
        },
        Image: function e() {},
        Date: function e() {},
        screen: {},
        setTimeout: function e() {},
        clearTimeout: function e() {},
        matchMedia: function e() {
            return {};
        },
        requestAnimationFrame: function e(t) {
            if (typeof setTimeout === "undefined") {
                t();
                return null;
            }
            return setTimeout(t, 0);
        },
        cancelAnimationFrame: function e(t) {
            if (typeof setTimeout === "undefined") {
                return;
            }
            clearTimeout(t);
        }
    };
    function Se() {
        var e = typeof window !== "undefined" ? window : we;
        return e;
    }
    var Oe = Se();
    /* harmony default export */    const Pe = /* unused pure expression or super */ null && Oe;
    // CONCATENATED MODULE: ./src/utils/getBoundingClientRect.ts
    function Ee(e) {
        "@babel/helpers - typeof";
        return Ee = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e;
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        }, Ee(e);
    }
    function Ce(e, t) {
        var r = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var n = Object.getOwnPropertySymbols(e);
            t && (n = n.filter((function(t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable;
            }))), r.push.apply(r, n);
        }
        return r;
    }
    function je(e) {
        for (var t = 1; t < arguments.length; t++) {
            var r = null != arguments[t] ? arguments[t] : {};
            t % 2 ? Ce(Object(r), !0).forEach((function(t) {
                xe(e, t, r[t]);
            })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Ce(Object(r)).forEach((function(t) {
                Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
            }));
        }
        return e;
    }
    function xe(e, t, r) {
        return (t = ke(t)) in e ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = r, e;
    }
    function ke(e) {
        var t = Ae(e, "string");
        return "symbol" == Ee(t) ? t : t + "";
    }
    function Ae(e, t) {
        if ("object" != Ee(e) || !e) return e;
        var r = e[Symbol.toPrimitive];
        if (void 0 !== r) {
            var n = r.call(e, t || "default");
            if ("object" != Ee(n)) return n;
            throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === t ? String : Number)(e);
    }
    // Checks if browser is Safari
        function Te() {
        return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    }
    // Formats return value to DOMRect
        function We(e) {
        return je(je({}, e), {}, {
            top: e.y,
            left: e.x,
            right: e.x + e.width,
            bottom: e.y + e.height
        });
    }
    /**
 * Provides DOMRect information about the size of an element and its position relative to the viewport.
 * Accounts for Safari's use of visual viewport and adds offsets to set as layout viewport.
 * @param {Element} element - The element to be evaluated
 * @param {boolean} offsets - Use when position of element relative to the layout viewport offsets are needed for Safari.
 * @returns {Omit<DOMRect, 'toJSON'>}
 * @public
 */    function Me(e, t) {
        var r, n;
        var o = e.getBoundingClientRect();
        var a = Te();
        if (!t || !a) {
            return o;
        }
        var i = Se();
        var l = o.left + (((r = i.visualViewport) === null || r === void 0 ? void 0 : r.offsetLeft) || 0);
        var c = o.top + (((n = i.visualViewport) === null || n === void 0 ? void 0 : n.offsetTop) || 0);
        var u = o.width, f = o.height;
        return We({
            width: u,
            height: f,
            x: l,
            y: c
        });
    }
    // CONCATENATED MODULE: ./src/utils/updateReactRef.ts
    /**
 * Updates a React ref. Callback refs and object refs (from `createRef` and `useRef`) are supported.
 *
 * @param ref - The React callback or object ref. Can be `null` or `undefined`.
 * @param current - The new value of the ref.
 */
    function qe(e, t) {
        if (e) {
            if (typeof e === "function") {
                e(t);
            } else {
                // the public signature of this util uses React.Ref<T> to mirror the way React types refs.
                // the intention here is to signal "we will take care of setting 'current', not you".
                e.current = t;
 // eslint-disable-line no-param-reassign
                        }
        }
    }
    // CONCATENATED MODULE: ./src/Popover/Popover.tsx
    function Re(e) {
        "@babel/helpers - typeof";
        return Re = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e;
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        }, Re(e);
    }
    function He() {
        return He = Object.assign ? Object.assign.bind() : function(e) {
            for (var t = 1; t < arguments.length; t++) {
                var r = arguments[t];
                for (var n in r) {
                    ({}).hasOwnProperty.call(r, n) && (e[n] = r[n]);
                }
            }
            return e;
        }, He.apply(null, arguments);
    }
    function _e(e) {
        return Le(e) || Ie(e) || Be(e) || De();
    }
    function De() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function Ie(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e);
    }
    function Le(e) {
        if (Array.isArray(e)) return Ue(e);
    }
    function Fe(e, t) {
        var r = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var n = Object.getOwnPropertySymbols(e);
            t && (n = n.filter((function(t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable;
            }))), r.push.apply(r, n);
        }
        return r;
    }
    function Ne(e) {
        for (var t = 1; t < arguments.length; t++) {
            var r = null != arguments[t] ? arguments[t] : {};
            t % 2 ? Fe(Object(r), !0).forEach((function(t) {
                ot(e, t, r[t]);
            })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Fe(Object(r)).forEach((function(t) {
                Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
            }));
        }
        return e;
    }
    function $e(e, t) {
        return Ke(e) || ze(e, t) || Be(e, t) || Ve();
    }
    function Ve() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function Be(e, t) {
        if (e) {
            if ("string" == typeof e) return Ue(e, t);
            var r = {}.toString.call(e).slice(8, -1);
            return "Object" === r && e.constructor && (r = e.constructor.name), "Map" === r || "Set" === r ? Array.from(e) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? Ue(e, t) : void 0;
        }
    }
    function Ue(e, t) {
        (null == t || t > e.length) && (t = e.length);
        for (var r = 0, n = Array(t); r < t; r++) {
            n[r] = e[r];
        }
        return n;
    }
    function ze(e, t) {
        var r = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
        if (null != r) {
            var n, o, a, i, l = [], c = !0, u = !1;
            try {
                if (a = (r = r.call(e)).next, 0 === t) {
                    if (Object(r) !== r) return;
                    c = !1;
                } else for (;!(c = (n = a.call(r)).done) && (l.push(n.value), l.length !== t); c = !0) {
                }
            } catch (e) {
                u = !0, o = e;
            } finally {
                try {
                    if (!c && null != r["return"] && (i = r["return"](), Object(i) !== i)) return;
                } finally {
                    if (u) throw o;
                }
            }
            return l;
        }
    }
    function Ke(e) {
        if (Array.isArray(e)) return e;
    }
    function Xe(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
    }
    function Ye(e, t) {
        for (var r = 0; r < t.length; r++) {
            var n = t[r];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
            Object.defineProperty(e, at(n.key), n);
        }
    }
    function Ge(e, t, r) {
        return t && Ye(e.prototype, t), r && Ye(e, r), Object.defineProperty(e, "prototype", {
            writable: !1
        }), e;
    }
    function Je(e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
        e.prototype = Object.create(t && t.prototype, {
            constructor: {
                value: e,
                writable: !0,
                configurable: !0
            }
        }), Object.defineProperty(e, "prototype", {
            writable: !1
        }), t && Qe(e, t);
    }
    function Qe(e, t) {
        return Qe = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
            return e.__proto__ = t, e;
        }, Qe(e, t);
    }
    function Ze(e) {
        var t = rt();
        return function() {
            var r, n = nt(e);
            if (t) {
                var o = nt(this).constructor;
                r = Reflect.construct(n, arguments, o);
            } else r = n.apply(this, arguments);
            return et(this, r);
        };
    }
    function et(e, t) {
        if (t && ("object" == Re(t) || "function" == typeof t)) return t;
        if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
        return tt(e);
    }
    function tt(e) {
        if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e;
    }
    function rt() {
        try {
            var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
        } catch (e) {}
        return (rt = function t() {
            return !!e;
        })();
    }
    function nt(e) {
        return nt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e);
        }, nt(e);
    }
    function ot(e, t, r) {
        return (t = at(t)) in e ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = r, e;
    }
    function at(e) {
        var t = it(e, "string");
        return "symbol" == Re(t) ? t : t + "";
    }
    function it(e, t) {
        if ("object" != Re(e) || !e) return e;
        var r = e[Symbol.toPrimitive];
        if (void 0 !== r) {
            var n = r.call(e, t || "default");
            if ("object" != Re(n)) return n;
            throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === t ? String : Number)(e);
    }
    /** @public */
    /** @public */
    /** @public */
    /** @public */
    /** @public */    var lt = [ "clickAway", "escapeKey", "offScreen", "tabKey" ];
    var ct = {
        align: a().oneOf([ "center", "edge", "theme", "end" ]),
        anchor: a().object,
        animation: a().bool,
        animationConfig: a().object,
        appearance: a().oneOf([ "normal", "inverted", "none" ]),
        autoCloseWhenOffScreen: a().bool,
        canCoverAnchor: a().bool,
        children: a().oneOfType([ a().node, a().func ]),
        closeReasons: a().arrayOf(a().oneOf(lt)),
        defaultPlacement: a().oneOf([ "above", "below", "left", "right", "vertical", "horizontal" ]),
        elementRef: a().oneOfType([ a().func, a().object ]),
        id: a().string,
        hideArrow: a().bool,
        hitAreaRef: a().oneOfType([ a().func, a().object ]),
        onRequestClose: a().func,
        open: a().bool,
        outerRef: a().oneOfType([ a().func, a().object ]),
        pointTo: a().shape({
            x: a().number,
            y: a().number
        }),
        repositionMode: a().oneOf([ "none", "flip", "any" ]),
        retainFocus: a().bool,
        takeFocus: a().bool,
        splunkTheme: a().object
    };
    var ut = {
        align: "theme",
        animation: true,
        animationConfig: {},
        appearance: "normal",
        autoCloseWhenOffScreen: true,
        canCoverAnchor: false,
        closeReasons: lt,
        defaultPlacement: "below",
        open: false,
        repositionMode: "flip",
        retainFocus: true,
        takeFocus: false
    };
    var ft = {
        passive: false,
        capture: true
    };
    // eslint-disable-next-line @typescript-eslint/ban-types
        function st(e, t) {
        var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
        return !!e && !!t && p()(e, (function(e, n) {
            if (w()(e)) {
                return Math.abs(t[n] - e) <= r;
            }
            return t[n] === e;
        }));
    }
    function pt(e) {
        var t = e.anchorPos, r = e.placement, n = e.outerContainerStyle, o = e.outerContainerEl;
        if (r === "misaligned") {
            return [ {
                display: "none"
            } ];
        }
        var a = {
            display: "block"
        };
        var i = o.offsetHeight / 2 - 22;
        var l = -(o.offsetHeight / 2 - 15);
        var u = t.center - (n.top + o.offsetHeight / 2) - Z / 2;
        var f = c()(u, l, i);
        // 26px is 16px arrow width + 8px padding + half of 3px or 4px border-radius
        // 11px is 16px arrow width - 8px padding + half of 3px or 4px border-radius
                var s = o.offsetWidth / 2 - 26;
        var p = -(o.offsetWidth / 2 - 11);
        // const initHorizontalDiff = -arrowHeight;
                var h = t.middle - (n.left + o.offsetWidth / 2) - Z;
        var d = c()(h, p, s);
        var v = {
            left: {
                translateX: Z / 2,
                translateY: f,
                rotate: 90
            },
            right: {
                translateX: -Z / 2,
                translateY: f,
                rotate: -90
            },
            above: {
                translateX: d,
                translateY: 0,
                rotate: 180
            },
            below: {
                translateX: d,
                translateY: 0,
                rotate: 0
            }
        };
        var m = v[r];
        a.transform = "translate(".concat(m.translateX, "px, ").concat(m.translateY, "px) rotate(").concat(m.rotate, "deg)");
        // set new positions
                var b = {
            left: "right",
            right: "left",
            above: "bottom",
            below: "top"
        };
        a[b[r]] = "1px";
        var y = {
            left: "top",
            right: "top",
            above: "left",
            below: "left"
        };
        a[y[r]] = "50%";
        return [ a, m ];
    }
    function ht(e) {
        var t = e.anchorEl, r = e.offsets, n = r === void 0 ? false : r, o = e.pointTo;
        var a = Me(t, n);
        var i = {
            // these are rounded to avoid causing visual regressions
            // they were previously clientWidth and clientHeight which were already rounded
            width: Math.round(a.width),
            height: Math.round(a.height)
        };
        var l = o && d()(o, "x");
        var c = o && d()(o, "y");
        i.left = l ? a.left + ((o === null || o === void 0 ? void 0 : o.x) || 0) : a.left;
        i.top = c ? a.top + ((o === null || o === void 0 ? void 0 : o.y) || 0) : a.top;
        i.right = l ? i.left + i.width : a.left + i.width || a.right;
        i.bottom = c ? i.top + i.height : a.top + i.height || a.bottom;
        // when pointTo is set, the middle (horizontal) and center (vertical)
        // these values are set to the upper left corner of the anchor
        // which causes the whole Popover to be aligned to the upper left corner
        // (ignoring the "align" prop) and then shifted by the value of "pointTo"
                i.middle = l ? i.left : a.left + (i.right - a.left) / 2;
        i.center = c ? i.top : a.top + (i.bottom - a.top) / 2;
        return i;
    }
    function dt(e) {
        return e !== window && e !== window.document;
    }
    function vt(e, t) {
        var r = Se();
        if (e.top < 0 || e.top > r.innerHeight || e.left < 0 || e.left > r.innerWidth) {
            return true;
        }
        if (t) {
            if (e.height + e.top < t.top || e.top > t.bottom || e.width + e.left < t.left || e.left > t.right) {
                return true;
            }
        }
        return false;
    }
    /**
 * `Popover` is used to create layovers such as dropdowns, contextual menus, or tooltips. Use
 * this only when the other components don't provide sufficient functionality or control. A controlled
 * `Dropdown` covers use cases where you might consider using `Popover` directly.
 */    var mt =  function(e) {
        Je(r, e);
        var t = Ze(r);
        Ge(r, null, [ {
            key: "getDerivedStateFromProps",
            // @docs-props-type PopoverPropsBase
            value: function e(t, r) {
                if (t.open !== r.prevOpen) {
                    return {
                        animating: t.animation,
                        prevOpen: t.open
                    };
                }
                return null;
            }
        } ]);
        function r(e) {
            var n;
            Xe(this, r);
            n = t.call(this, e);
            ot(tt(n), "outerContainerEl", null);
            ot(tt(n), "innerContainerEl", null);
            ot(tt(n), "arrow", null);
            ot(tt(n), "handleScroll", void 0);
            ot(tt(n), "handleWindowScroll", void 0);
            ot(tt(n), "allowAnimationUpdates", true);
            ot(tt(n), "setPlacement", (function(e) {
                var t = Se();
                n.setState((function(r) {
                    var o = n.props, a = o.align, i = o.anchor, l = o.autoCloseWhenOffScreen, c = o.canCoverAnchor, u = o.defaultPlacement, f = o.open, s = o.pointTo, p = o.repositionMode, h = o.splunkTheme;
                    var d = n.context || t;
                    var v = h.isPrisma;
 // If these conditions are not met, we cannot set the popover.
                                        if (!f || !n.outerContainerEl || !i || !r.anchorEl) {
                        if (false) {}
                        return null;
                    }
                    var m = ht({
                        anchorEl: r.anchorEl,
                        pointTo: s
                    });
                    var b = ht({
                        anchorEl: r.anchorEl,
                        offsets: true,
                        pointTo: s
                    });
                    var y = dt(d) ? ht({
                        anchorEl: d,
                        pointTo: s
                    }) : undefined;
                    if (e && l) {
                        if (n.autoCloseWhenOffScreen(m, y)) {
                            return null;
                        }
                    }
                    var g = 8;
                    var w = v ? "edge" : "center";
                    var S = U({
                        align: a === "theme" ? w : a,
                        anchorPos: b,
                        scrollContainerPos: y,
                        canCoverAnchor: c,
                        defaultPlacement: u,
                        repositionMode: p,
                        outerContainerEl: n.outerContainerEl,
                        padding: g,
                        windowWidth: t.innerWidth,
                        windowHeight: t.innerHeight
                    }), O = S.placement, P = S.outerContainerStyle, E = S.maxHeight, C = S.maxWidth;
                    var x = st(b, r.anchorPos) && st(P, r.outerContainerStyle) && O === r.placement && E === r.maxHeight && C === r.maxWidth;
                    var k = true;
                    var A = {};
                    var T;
                    if (n.arrow) {
                        var W, M;
                        var q = pt({
                            anchorPos: b,
                            outerContainerStyle: P,
                            placement: O,
                            outerContainerEl: n.outerContainerEl
                        });
                        var R = $e(q, 2);
                        A = R[0];
                        T = R[1];
                        k = st(j()(A, "transform"), j()(r.arrowStyle, "transform")) && st((W = T) !== null && W !== void 0 ? W : {}, (M = r.arrowStyleTransformMeta) !== null && M !== void 0 ? M : {});
                    }
                    // If none of the position data has changed, do not set state.
                                        if (x && k) {
                        return null;
                    }
                    return {
                        anchorPos: b,
                        arrowStyle: A,
                        arrowStyleTransformMeta: T,
                        outerContainerStyle: P,
                        placement: O,
                        maxHeight: E,
                        maxWidth: C
                    };
                }));
            }));
            ot(tt(n), "handleArrowMount", (function(e) {
                n.arrow = e;
            }));
            ot(tt(n), "handleNewAnchor", (function(e) {
                var t = n.props.pointTo;
                var r;
                if (e && !(e instanceof HTMLElement)) {
                    if (false) {}
                    r = (0, i.findDOMNode)(e);
 // eslint-disable-line react/no-find-dom-node
                                } else {
                    r = e !== null && e !== void 0 ? e : undefined;
                }
                var o = r ? ht({
                    anchorEl: r,
                    pointTo: t
                }) : undefined;
                n.setState({
                    anchorEl: r,
                    anchorPos: o
                });
 // eslint-disable-line react/no-unused-state
                        }));
            ot(tt(n), "handleInnerContainerMount", (function(e) {
                n.innerContainerEl = e;
                if (e && n.props.takeFocus) {
                    f()(D.takeFocus, e);
                }
                qe(n.props.elementRef, e);
            }));
            ot(tt(n), "handleOuterContainerMount", (function(e) {
                n.outerContainerEl = e;
                qe(n.props.outerRef, e);
            }));
            ot(tt(n), "handleTab", (function(e) {
                if (n.innerContainerEl) {
                    if (n.props.retainFocus) {
                        (0, D.handleTab)(n.innerContainerEl, e);
                    } else if ((0, D.isTabKey)(e)) {
                        var t = (0, D.getSortedTabbableElements)(n.innerContainerEl);
                        if (t.length > 0) {
                            var r = e.shiftKey ? t[0] : t[t.length - 1];
                            if (r === e.target) {
                                n.handleRequestClose({
                                    event: e,
                                    reason: "tabKey"
                                });
                            }
                        }
                    }
                }
            }));
            ot(tt(n), "handleRequestClose", (function(e) {
                if (n.props.open) {
                    n.requestClose(e);
                }
            }));
            ot(tt(n), "handleAnimationEnd", (function() {
                if (n.allowAnimationUpdates) {
                    n.setState({
                        animating: false
                    });
                }
            }));
            n.handleScroll = k()(n.setPlacement.bind(tt(n), true), 0);
            n.handleWindowScroll = k()(n.setPlacement.bind(tt(n), true), 0);
            n.setPlacement = k()(n.setPlacement, 0, {
                leading: false
            });
            n.state = {
                animating: false,
                prevOpen: e.open
            };
            return n;
        }
        Ge(r, [ {
            key: "componentDidMount",
            value: function e() {
                this.handleNewAnchor(this.props.anchor);
            }
        }, {
            key: "componentDidUpdate",
            value: function e(t) {
                if (t.anchor !== this.props.anchor) {
                    this.handleNewAnchor(this.props.anchor);
                }
                if (!this.innerContainerEl) {
                    return;
                }
                if (this.props.open || this.state.animating) {
                    this.setPlacement();
                    // make sure that the popover both was not open before and is actually open now
                    // this prevents bugs like #4 in SUI-2054 where popover contents re-rendering due to animation
                    // causes the popover contents to receive focus even though the popover closing
                                        if (!t.open && this.props.open && this.props.takeFocus) {
                        (0, D.takeFocus)(this.innerContainerEl);
                    }
                }
            }
        }, {
            key: "componentWillUnmount",
            value: function e() {
                this.setPlacement.cancel();
 // guaranteed by constructor
                                this.handleScroll.cancel();
                this.allowAnimationUpdates = false;
            }
        }, {
            key: "shouldRenderArrow",
            value: function e(t) {
                var r;
                var n = this.props, o = n.appearance, a = n.hideArrow, i = n.splunkTheme;
                var l = i.isPrisma;
 // if hideArrow or hideArrowContext isn't set, default it to true in Prisma themes
                                var c = (r = a !== null && a !== void 0 ? a : t) !== null && r !== void 0 ? r : l;
                return o !== "none" && !c;
            }
        }, {
            key: "autoCloseWhenOffScreen",
            value: function e(t, r) {
                var n = vt(t, r);
                if (n) {
                    this.requestClose({
                        reason: "offScreen"
                    });
                }
                return n;
            }
        }, {
            key: "requestClose",
            value: function e(t) {
                if (m()(this.props.closeReasons, t.reason)) {
                    var r, n;
                    (r = (n = this.props).onRequestClose) === null || r === void 0 ? void 0 : r.call(n, t);
                }
            }
        }, {
            key: "render",
            value: function e() {
                var t = this;
                var o = this.props, a = o.animation, i = o.animationConfig, l = o.appearance, c = o.children, u = o.closeReasons, f = o.hitAreaRef, s = o.id, p = o.open, h = o.retainFocus;
                var d = this.state, v = d.anchorPos, m = d.animating, b = d.arrowStyle, g = d.outerContainerStyle, S = d.placement;
                var P = this.state, C = P.maxHeight, x = P.maxWidth;
 // eslint-disable-line prefer-const
                // Accommodate the arrow in the maxHeight and maxWidth.
                                if (l !== "none") {
                    if (w()(C)) {
                        C -= 20;
                    }
                    if (w()(x)) {
                        x -= 20;
                    }
                }
                var k = {
                    anchorHeight: v ? v.height : null,
                    anchorWidth: v ? v.width : null,
                    placement: S || null,
                    maxHeight: C || null,
                    maxWidth: x || null
                };
                var A = a ? {
                    opacity: p ? 1 : 0
                } : {
                    opacity: 1
                };
                var W = Se();
                var q = p || m;
                var H = this.context || W;
                var _ = H !== W;
                // EventListeners only need to be rendered when open,
                // otherwise leads to negative performance impacts
                                var D = q ? [ _ &&  n().createElement(M(), {
                    target: H,
                    eventType: "scroll",
                    listener: this.handleScroll,
                    options: ft,
                    key: "eventListener"
                }),  n().createElement(M(), {
                    target: W,
                    eventType: "resize",
                    listener: this.setPlacement,
                    key: "eventListenerOnWindowResize"
                }),  n().createElement(M(), {
                    target: W,
                    eventType: "scroll",
                    listener: this.handleWindowScroll,
                    options: ft,
                    key: "eventListenerOnWindowScroll"
                }) ] : [];
                return [].concat(D, [  n().createElement(R(), {
                    closeReasons: y()(u.filter((function(e) {
                        return e !== "offScreen";
                    })), R().possibleCloseReasons),
                    open: q,
                    onRequestClose: this.handleRequestClose,
                    key: "Layer"
                }, q && this.innerContainerEl && f &&  n().createElement(ve, {
                    anchorRect: v,
                    popoverEl: this.innerContainerEl,
                    popoverPlacement: S,
                    ref: f
                }), q &&  n().createElement(T.Spring, {
                    from: {
                        opacity: a ? 0 : 1
                    },
                    to: A,
                    config: Ne({
                        tension: 300,
                        friction: 20,
                        clamp: true
                    }, i),
                    onRest: this.handleAnimationEnd
                }, (function(e) {
                    
                    return n().createElement(z.Consumer, null, (function(o) {
                        var a = o.hideArrow;
                        
                        return n().createElement(ee, {
                            "data-test": "outer-popover",
                            style: Ne(Ne({}, g), e),
                            ref: t.handleOuterContainerMount
                        },  n().createElement(re, He({
                            $appearance: l,
                            $open: p,
                            "data-test": "popover",
                            ref: t.handleInnerContainerMount,
                            id: s,
                            onKeyDown: t.handleTab
                        }, j()(t.props, [ "anchor" ].concat(_e(E()(r.propTypes))))),  n().createElement(Y.Provider, {
                            value: {
                                retainFocus: h
                            }
                        },  n().createElement(n().Fragment, null, l === "none" && c, t.shouldRenderArrow(a) &&  n().createElement(oe, {
                            "data-test": "popover-arrow",
                            $appearance: l,
                            ref: t.handleArrowMount,
                            style: b
                        }), l !== "none" &&  n().createElement(ne, {
                            $appearance: l
                        }, O()(c) ? c(k) : c)))));
                    }));
                }))) ]);
            }
        } ]);
        return r;
    }(r.Component);
    ot(mt, "contextType", _());
    ot(mt, "defaultProps", ut);
    ot(mt, "propTypes", ct);
    var bt = (0, A.withSplunkTheme)(mt);
    bt.propTypes = mt.propTypes;
    /* harmony default export */    const yt = bt;
    // CONCATENATED MODULE: ./src/Popover/index.ts
    module.exports = t;
    /******/})();