import React from 'react';
import PropTypes from 'prop-types';
import { ComponentProps } from '../utils/types';
interface TreeItemPropsBase {
    /** A unique `id` for this item and used by `Tree` to keep track of the focused item. */
    id: string;
    /** Should contain `Tree.Item`s, can also include other elements to display in between tree items. */
    children?: React.ReactNode;
    /** Content to show on the `Tree.Item`. */
    content?: React.ReactNode;
    /**
     * @private Custom indent to show before `Tree.Item` content.
     */
    customIndent?: React.ReactNode;
    /**
     * A React ref which is set to the DOM element when the component mounts and null when it unmounts.
     */
    elementRef?: React.Ref<HTMLLIElement>;
    /**
     * @private Used only by JSONTree - artifact from before Tree was public.
     * Conventional `endAdornment` in all other cases would instead be just done by including the desired element in `content`.
     * Left in for JSONTree because the need to support the endAdornment conditionally going to the end of the unordered list of children in the expanded view.
     * This is required in JSONTree to handle closing bracket/braces but does not have a known use case for other Tree uses.
     */
    endAdornment?: React.ReactNode;
    /** Expansion state of the `Tree.Item`. */
    expanded?: boolean;
    onFocus?: React.FocusEventHandler<HTMLLIElement>;
    onKeyDown?: React.KeyboardEventHandler<HTMLLIElement>;
    /** Called on expansion state change of the `Tree.Item` and should be used to maintain `expanded`. For proper keyboard accessibility this is required when a `Tree.Item` has children. */
    onToggleExpansion?: TreeItemToggleExpansionHandler;
    /** Called on selection state change of the `Tree.Item` and can be used to maintain optional external `Tree.Item` selection state. */
    onToggleSelection?: TreeItemToggleSelectionHandler;
}
type TreeItemProps = ComponentProps<TreeItemPropsBase, 'li'>;
type TreeItemClickHandler = (event: React.MouseEvent<HTMLSpanElement>, id: string) => void;
type TreeItemKeyDownHandler = (event: React.KeyboardEvent<HTMLLIElement>, id: string, isExpanded: boolean | undefined, childrenCleaned: React.ReactElement[] | undefined | null, handleToggleExpansion: TreeItemToggleExpansionHandler) => void;
/** @public */
type TreeItemToggleExpansionHandler = (event: React.KeyboardEvent<HTMLLIElement> | React.MouseEvent<HTMLSpanElement>, data?: {
    treeItemId?: string;
}) => void;
/** @public */
type TreeItemToggleSelectionHandler = (event: React.KeyboardEvent<HTMLLIElement> | React.MouseEvent<HTMLSpanElement>, data?: {
    treeItemId?: string;
}) => void;
declare function Item({ id, children, content, customIndent, elementRef, endAdornment, expanded, onFocus, onKeyDown, onToggleExpansion, onToggleSelection, ...otherProps }: TreeItemProps): JSX.Element;
declare namespace Item {
    var propTypes: {
        id: PropTypes.Requireable<string>;
        children: PropTypes.Requireable<PropTypes.ReactNodeLike>;
        content: PropTypes.Requireable<PropTypes.ReactNodeLike>;
        customIndent: PropTypes.Requireable<PropTypes.ReactNodeLike>;
        elementRef: PropTypes.Requireable<object>;
        endAdornment: PropTypes.Requireable<PropTypes.ReactNodeLike>;
        expanded: PropTypes.Requireable<boolean>;
        onFocus: PropTypes.Requireable<(...args: any[]) => any>;
        onKeyDown: PropTypes.Requireable<(...args: any[]) => any>;
        onToggleSelection: PropTypes.Requireable<(...args: any[]) => any>;
        onToggleExpansion: PropTypes.Requireable<(...args: any[]) => any>;
    };
}
export default Item;
export { TreeItemClickHandler, TreeItemKeyDownHandler, TreeItemPropsBase, TreeItemToggleExpansionHandler, TreeItemToggleSelectionHandler, };
